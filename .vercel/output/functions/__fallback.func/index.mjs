import process from 'node:process';globalThis._importMeta_={url:import.meta.url,env:process.env};import { createServerClient, parseCookieHeader } from '@supabase/ssr';
import nodemailer from 'nodemailer';
import { FunctionsClient } from '@supabase/functions-js';
import { PostgrestClient } from '@supabase/postgrest-js';
import { RealtimeClient } from '@supabase/realtime-js';
import { StorageClient } from '@supabase/storage-js';
import { AuthClient } from '@supabase/auth-js';
import { createHead as createHead$1, propsToString, renderSSRHead } from 'unhead/server';
import { stringify as stringify$1, uneval } from 'devalue';
import { EventEmitter } from 'node:events';
import { Buffer as Buffer$1 } from 'node:buffer';
import { promises, existsSync } from 'node:fs';
import { resolve as resolve$1, dirname, join } from 'node:path';
import { createHash } from 'node:crypto';
import http from 'node:http';
import https from 'node:https';
import * as node_stream from 'node:stream';
import { walkResolver } from 'unhead/utils';

function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== 'string' && !Array.isArray(e)) { for (const k in e) {
      if (k !== 'default' && !(k in n)) {
        const d = Object.getOwnPropertyDescriptor(e, k);
        if (d) {
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      }
    } }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
}

const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

const HASH_RE$1 = /#/g;
const AMPERSAND_RE$1 = /&/g;
const SLASH_RE$1 = /\//g;
const EQUAL_RE$1 = /=/g;
const PLUS_RE$1 = /\+/g;
const ENC_CARET_RE$1 = /%5e/gi;
const ENC_BACKTICK_RE$1 = /%60/gi;
const ENC_PIPE_RE$1 = /%7c/gi;
const ENC_SPACE_RE$1 = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE$1, "|");
}
function encodeQueryValue$1(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE$1, "%2B").replace(ENC_SPACE_RE$1, "+").replace(HASH_RE$1, "%23").replace(AMPERSAND_RE$1, "%26").replace(ENC_BACKTICK_RE$1, "`").replace(ENC_CARET_RE$1, "^").replace(SLASH_RE$1, "%2F");
}
function encodeQueryKey$1(text) {
  return encodeQueryValue$1(text).replace(EQUAL_RE$1, "%3D");
}
function decode$1(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode$1(text.replace(PLUS_RE$1, " "));
}
function decodeQueryValue(text) {
  return decode$1(text.replace(PLUS_RE$1, " "));
}

function parseQuery$1(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey$1(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey$1(key)}=${encodeQueryValue$1(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey$1(key)}=${encodeQueryValue$1(value)}`;
}
function stringifyQuery$1(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}

const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
const PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
const TRAILING_SLASH_RE$1 = /\/$|\/\?|\/#/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function isScriptProtocol(protocol) {
  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE$1.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s0, ...s] = path.split("?");
  const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
  return (cleanPath || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withLeadingSlash(input = "") {
  return hasLeadingSlash(input) ? input : "/" + input;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    const nextChar = input[_base.length];
    if (!nextChar || nextChar === "/" || nextChar === "?") {
      return input;
    }
  }
  return joinURL(_base, input);
}
function withoutBase(input, base) {
  if (isEmptyURL(base)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (!input.startsWith(_base)) {
    return input;
  }
  const nextChar = input[_base.length];
  if (nextChar && nextChar !== "/" && nextChar !== "?") {
    return input;
  }
  const trimmed = input.slice(_base.length);
  return trimmed[0] === "/" ? trimmed : "/" + trimmed;
}
function withQuery(input, query) {
  const parsed = parseURL$1(input);
  const mergedQuery = { ...parseQuery$1(parsed.search), ...query };
  parsed.search = stringifyQuery$1(mergedQuery);
  return stringifyParsedURL(parsed);
}
function getQuery$1(input) {
  return parseQuery$1(parseURL$1(input).search);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
function joinRelativeURL(..._input) {
  const JOIN_SEGMENT_SPLIT_RE = /\/(?!\/)/;
  const input = _input.filter(Boolean);
  const segments = [];
  let segmentsDepth = 0;
  for (const i of input) {
    if (!i || i === "/") {
      continue;
    }
    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {
      if (!s || s === ".") {
        continue;
      }
      if (s === "..") {
        if (segments.length === 1 && hasProtocol(segments[0])) {
          continue;
        }
        segments.pop();
        segmentsDepth--;
        continue;
      }
      if (sindex === 1 && segments[segments.length - 1]?.endsWith(":/")) {
        segments[segments.length - 1] += "/" + s;
        continue;
      }
      segments.push(s);
      segmentsDepth++;
    }
  }
  let url = segments.join("/");
  if (segmentsDepth >= 0) {
    if (input[0]?.startsWith("/") && !url.startsWith("/")) {
      url = "/" + url;
    } else if (input[0]?.startsWith("./") && !url.startsWith("./")) {
      url = "./" + url;
    }
  } else {
    url = "../".repeat(-1 * segmentsDepth) + url;
  }
  if (input[input.length - 1]?.endsWith("/") && !url.endsWith("/")) {
    url += "/";
  }
  return url;
}

const protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL$1(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

const fieldContentRegExp = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
function serialize$2(name, value, options) {
  const opt = options || {};
  const enc = opt.encode || encodeURIComponent;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  const encodedValue = enc(value);
  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {
    throw new TypeError("argument val is invalid");
  }
  let str = name + "=" + encodedValue;
  if (void 0 !== opt.maxAge && opt.maxAge !== null) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (!isDate$1(opt.expires) || Number.isNaN(opt.expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    const priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low": {
        str += "; Priority=Low";
        break;
      }
      case "medium": {
        str += "; Priority=Medium";
        break;
      }
      case "high": {
        str += "; Priority=High";
        break;
      }
      default: {
        throw new TypeError("option priority is invalid");
      }
    }
  }
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true: {
        str += "; SameSite=Strict";
        break;
      }
      case "lax": {
        str += "; SameSite=Lax";
        break;
      }
      case "strict": {
        str += "; SameSite=Strict";
        break;
      }
      case "none": {
        str += "; SameSite=None";
        break;
      }
      default: {
        throw new TypeError("option sameSite is invalid");
      }
    }
  }
  if (opt.partitioned) {
    str += "; Partitioned";
  }
  return str;
}
function isDate$1(val) {
  return Object.prototype.toString.call(val) === "[object Date]" || val instanceof Date;
}

function parseSetCookie(setCookieValue, options) {
  const parts = (setCookieValue || "").split(";").filter((str) => typeof str === "string" && !!str.trim());
  const nameValuePairStr = parts.shift() || "";
  const parsed = _parseNameValuePair(nameValuePairStr);
  const name = parsed.name;
  let value = parsed.value;
  try {
    value = options?.decode === false ? value : (options?.decode || decodeURIComponent)(value);
  } catch {
  }
  const cookie = {
    name,
    value
  };
  for (const part of parts) {
    const sides = part.split("=");
    const partKey = (sides.shift() || "").trimStart().toLowerCase();
    const partValue = sides.join("=");
    switch (partKey) {
      case "expires": {
        cookie.expires = new Date(partValue);
        break;
      }
      case "max-age": {
        cookie.maxAge = Number.parseInt(partValue, 10);
        break;
      }
      case "secure": {
        cookie.secure = true;
        break;
      }
      case "httponly": {
        cookie.httpOnly = true;
        break;
      }
      case "samesite": {
        cookie.sameSite = partValue;
        break;
      }
      default: {
        cookie[partKey] = partValue;
      }
    }
  }
  return cookie;
}
function _parseNameValuePair(nameValuePairStr) {
  let name = "";
  let value = "";
  const nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("=");
  } else {
    value = nameValuePairStr;
  }
  return { name, value };
}

const NODE_TYPES = {
  NORMAL: 0,
  WILDCARD: 1,
  PLACEHOLDER: 2
};

function createRouter$2(options = {}) {
  const ctx = {
    options,
    rootNode: createRadixNode(),
    staticRoutesMap: {}
  };
  const normalizeTrailingSlash = (p) => options.strictTrailingSlash ? p : p.replace(/\/$/, "") || "/";
  if (options.routes) {
    for (const path in options.routes) {
      insert(ctx, normalizeTrailingSlash(path), options.routes[path]);
    }
  }
  return {
    ctx,
    lookup: (path) => lookup(ctx, normalizeTrailingSlash(path)),
    insert: (path, data) => insert(ctx, normalizeTrailingSlash(path), data),
    remove: (path) => remove$1(ctx, normalizeTrailingSlash(path))
  };
}
function lookup(ctx, path) {
  const staticPathNode = ctx.staticRoutesMap[path];
  if (staticPathNode) {
    return staticPathNode.data;
  }
  const sections = path.split("/");
  const params = {};
  let paramsFound = false;
  let wildcardNode = null;
  let node = ctx.rootNode;
  let wildCardParam = null;
  for (let i = 0; i < sections.length; i++) {
    const section = sections[i];
    if (node.wildcardChildNode !== null) {
      wildcardNode = node.wildcardChildNode;
      wildCardParam = sections.slice(i).join("/");
    }
    const nextNode = node.children.get(section);
    if (nextNode === void 0) {
      if (node && node.placeholderChildren.length > 1) {
        const remaining = sections.length - i;
        node = node.placeholderChildren.find((c) => c.maxDepth === remaining) || null;
      } else {
        node = node.placeholderChildren[0] || null;
      }
      if (!node) {
        break;
      }
      if (node.paramName) {
        params[node.paramName] = section;
      }
      paramsFound = true;
    } else {
      node = nextNode;
    }
  }
  if ((node === null || node.data === null) && wildcardNode !== null) {
    node = wildcardNode;
    params[node.paramName || "_"] = wildCardParam;
    paramsFound = true;
  }
  if (!node) {
    return null;
  }
  if (paramsFound) {
    return {
      ...node.data,
      params: paramsFound ? params : void 0
    };
  }
  return node.data;
}
function insert(ctx, path, data) {
  let isStaticRoute = true;
  const sections = path.split("/");
  let node = ctx.rootNode;
  let _unnamedPlaceholderCtr = 0;
  const matchedNodes = [node];
  for (const section of sections) {
    let childNode;
    if (childNode = node.children.get(section)) {
      node = childNode;
    } else {
      const type = getNodeType(section);
      childNode = createRadixNode({ type, parent: node });
      node.children.set(section, childNode);
      if (type === NODE_TYPES.PLACEHOLDER) {
        childNode.paramName = section === "*" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);
        node.placeholderChildren.push(childNode);
        isStaticRoute = false;
      } else if (type === NODE_TYPES.WILDCARD) {
        node.wildcardChildNode = childNode;
        childNode.paramName = section.slice(
          3
          /* "**:" */
        ) || "_";
        isStaticRoute = false;
      }
      matchedNodes.push(childNode);
      node = childNode;
    }
  }
  for (const [depth, node2] of matchedNodes.entries()) {
    node2.maxDepth = Math.max(matchedNodes.length - depth, node2.maxDepth || 0);
  }
  node.data = data;
  if (isStaticRoute === true) {
    ctx.staticRoutesMap[path] = node;
  }
  return node;
}
function remove$1(ctx, path) {
  let success = false;
  const sections = path.split("/");
  let node = ctx.rootNode;
  for (const section of sections) {
    node = node.children.get(section);
    if (!node) {
      return success;
    }
  }
  if (node.data) {
    const lastSection = sections.at(-1) || "";
    node.data = null;
    if (Object.keys(node.children).length === 0 && node.parent) {
      node.parent.children.delete(lastSection);
      node.parent.wildcardChildNode = null;
      node.parent.placeholderChildren = [];
    }
    success = true;
  }
  return success;
}
function createRadixNode(options = {}) {
  return {
    type: options.type || NODE_TYPES.NORMAL,
    maxDepth: 0,
    parent: options.parent || null,
    children: /* @__PURE__ */ new Map(),
    data: options.data || null,
    paramName: options.paramName || null,
    wildcardChildNode: null,
    placeholderChildren: []
  };
}
function getNodeType(str) {
  if (str.startsWith("**")) {
    return NODE_TYPES.WILDCARD;
  }
  if (str[0] === ":" || str === "*") {
    return NODE_TYPES.PLACEHOLDER;
  }
  return NODE_TYPES.NORMAL;
}

function toRouteMatcher(router) {
  const table = _routerNodeToTable("", router.ctx.rootNode);
  return _createMatcher(table, router.ctx.options.strictTrailingSlash);
}
function _createMatcher(table, strictTrailingSlash) {
  return {
    ctx: { table },
    matchAll: (path) => _matchRoutes(path, table, strictTrailingSlash)
  };
}
function _createRouteTable() {
  return {
    static: /* @__PURE__ */ new Map(),
    wildcard: /* @__PURE__ */ new Map(),
    dynamic: /* @__PURE__ */ new Map()
  };
}
function _matchRoutes(path, table, strictTrailingSlash) {
  if (strictTrailingSlash !== true && path.endsWith("/")) {
    path = path.slice(0, -1) || "/";
  }
  const matches = [];
  for (const [key, value] of _sortRoutesMap(table.wildcard)) {
    if (path === key || path.startsWith(key + "/")) {
      matches.push(value);
    }
  }
  for (const [key, value] of _sortRoutesMap(table.dynamic)) {
    if (path.startsWith(key + "/")) {
      const subPath = "/" + path.slice(key.length).split("/").splice(2).join("/");
      matches.push(..._matchRoutes(subPath, value));
    }
  }
  const staticMatch = table.static.get(path);
  if (staticMatch) {
    matches.push(staticMatch);
  }
  return matches.filter(Boolean);
}
function _sortRoutesMap(m) {
  return [...m.entries()].sort((a, b) => a[0].length - b[0].length);
}
function _routerNodeToTable(initialPath, initialNode) {
  const table = _createRouteTable();
  function _addNode(path, node) {
    if (path) {
      if (node.type === NODE_TYPES.NORMAL && !(path.includes("*") || path.includes(":"))) {
        if (node.data) {
          table.static.set(path, node.data);
        }
      } else if (node.type === NODE_TYPES.WILDCARD) {
        table.wildcard.set(path.replace("/**", ""), node.data);
      } else if (node.type === NODE_TYPES.PLACEHOLDER) {
        const subTable = _routerNodeToTable("", node);
        if (node.data) {
          subTable.static.set("/", node.data);
        }
        table.dynamic.set(path.replace(/\/\*|\/:\w+/, ""), subTable);
        return;
      }
    }
    for (const [childPath, child] of node.children.entries()) {
      _addNode(`${path}/${childPath}`.replace("//", "/"), child);
    }
  }
  _addNode(initialPath, initialNode);
  return table;
}

function isPlainObject$1(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$1(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();
const defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

function o(n){throw new Error(`${n} is not implemented yet!`)}let i$1 = class i extends EventEmitter{__unenv__={};readableEncoding=null;readableEnded=true;readableFlowing=false;readableHighWaterMark=0;readableLength=0;readableObjectMode=false;readableAborted=false;readableDidRead=false;closed=false;errored=null;readable=false;destroyed=false;static from(e,t){return new i(t)}constructor(e){super();}_read(e){}read(e){}setEncoding(e){return this}pause(){return this}resume(){return this}isPaused(){return  true}unpipe(e){return this}unshift(e,t){}wrap(e){return this}push(e,t){return  false}_destroy(e,t){this.removeAllListeners();}destroy(e){return this.destroyed=true,this._destroy(e),this}pipe(e,t){return {}}compose(e,t){throw new Error("Method not implemented.")}[Symbol.asyncDispose](){return this.destroy(),Promise.resolve()}async*[Symbol.asyncIterator](){throw o("Readable.asyncIterator")}iterator(e){throw o("Readable.iterator")}map(e,t){throw o("Readable.map")}filter(e,t){throw o("Readable.filter")}forEach(e,t){throw o("Readable.forEach")}reduce(e,t,r){throw o("Readable.reduce")}find(e,t){throw o("Readable.find")}findIndex(e,t){throw o("Readable.findIndex")}some(e,t){throw o("Readable.some")}toArray(e){throw o("Readable.toArray")}every(e,t){throw o("Readable.every")}flatMap(e,t){throw o("Readable.flatMap")}drop(e,t){throw o("Readable.drop")}take(e,t){throw o("Readable.take")}asIndexedPairs(e){throw o("Readable.asIndexedPairs")}};let l$1 = class l extends EventEmitter{__unenv__={};writable=true;writableEnded=false;writableFinished=false;writableHighWaterMark=0;writableLength=0;writableObjectMode=false;writableCorked=0;closed=false;errored=null;writableNeedDrain=false;writableAborted=false;destroyed=false;_data;_encoding="utf8";constructor(e){super();}pipe(e,t){return {}}_write(e,t,r){if(this.writableEnded){r&&r();return}if(this._data===void 0)this._data=e;else {const s=typeof this._data=="string"?Buffer$1.from(this._data,this._encoding||t||"utf8"):this._data,a=typeof e=="string"?Buffer$1.from(e,t||this._encoding||"utf8"):e;this._data=Buffer$1.concat([s,a]);}this._encoding=t,r&&r();}_writev(e,t){}_destroy(e,t){}_final(e){}write(e,t,r){const s=typeof t=="string"?this._encoding:"utf8",a=typeof t=="function"?t:typeof r=="function"?r:void 0;return this._write(e,s,a),true}setDefaultEncoding(e){return this}end(e,t,r){const s=typeof e=="function"?e:typeof t=="function"?t:typeof r=="function"?r:void 0;if(this.writableEnded)return s&&s(),this;const a=e===s?void 0:e;if(a){const u=t===s?void 0:t;this.write(a,u,s);}return this.writableEnded=true,this.writableFinished=true,this.emit("close"),this.emit("finish"),this}cork(){}uncork(){}destroy(e){return this.destroyed=true,delete this._data,this.removeAllListeners(),this}compose(e,t){throw new Error("Method not implemented.")}[Symbol.asyncDispose](){return Promise.resolve()}};const c$1=class c{allowHalfOpen=true;_destroy;constructor(e=new i$1,t=new l$1){Object.assign(this,e),Object.assign(this,t),this._destroy=m(e._destroy,t._destroy);}};function _(){return Object.assign(c$1.prototype,i$1.prototype),Object.assign(c$1.prototype,l$1.prototype),c$1}function m(...n){return function(...e){for(const t of n)t(...e);}}const g=_();class A extends g{__unenv__={};bufferSize=0;bytesRead=0;bytesWritten=0;connecting=false;destroyed=false;pending=false;localAddress="";localPort=0;remoteAddress="";remoteFamily="";remotePort=0;autoSelectFamilyAttemptedAddresses=[];readyState="readOnly";constructor(e){super();}write(e,t,r){return  false}connect(e,t,r){return this}end(e,t,r){return this}setEncoding(e){return this}pause(){return this}resume(){return this}setTimeout(e,t){return this}setNoDelay(e){return this}setKeepAlive(e,t){return this}address(){return {}}unref(){return this}ref(){return this}destroySoon(){this.destroy();}resetAndDestroy(){const e=new Error("ERR_SOCKET_CLOSED");return e.code="ERR_SOCKET_CLOSED",this.destroy(e),this}}class y extends i$1{aborted=false;httpVersion="1.1";httpVersionMajor=1;httpVersionMinor=1;complete=true;connection;socket;headers={};trailers={};method="GET";url="/";statusCode=200;statusMessage="";closed=false;errored=null;readable=false;constructor(e){super(),this.socket=this.connection=e||new A;}get rawHeaders(){const e=this.headers,t=[];for(const r in e)if(Array.isArray(e[r]))for(const s of e[r])t.push(r,s);else t.push(r,e[r]);return t}get rawTrailers(){return []}setTimeout(e,t){return this}get headersDistinct(){return p(this.headers)}get trailersDistinct(){return p(this.trailers)}}function p(n){const e={};for(const[t,r]of Object.entries(n))t&&(e[t]=(Array.isArray(r)?r:[r]).filter(Boolean));return e}class w extends l$1{statusCode=200;statusMessage="";upgrading=false;chunkedEncoding=false;shouldKeepAlive=false;useChunkedEncodingByDefault=false;sendDate=false;finished=false;headersSent=false;strictContentLength=false;connection=null;socket=null;req;_headers={};constructor(e){super(),this.req=e;}assignSocket(e){e._httpMessage=this,this.socket=e,this.connection=e,this.emit("socket",e),this._flush();}_flush(){this.flushHeaders();}detachSocket(e){}writeContinue(e){}writeHead(e,t,r){e&&(this.statusCode=e),typeof t=="string"&&(this.statusMessage=t,t=void 0);const s=r||t;if(s&&!Array.isArray(s))for(const a in s)this.setHeader(a,s[a]);return this.headersSent=true,this}writeProcessing(){}setTimeout(e,t){return this}appendHeader(e,t){e=e.toLowerCase();const r=this._headers[e],s=[...Array.isArray(r)?r:[r],...Array.isArray(t)?t:[t]].filter(Boolean);return this._headers[e]=s.length>1?s:s[0],this}setHeader(e,t){return this._headers[e.toLowerCase()]=t,this}setHeaders(e){for(const[t,r]of Object.entries(e))this.setHeader(t,r);return this}getHeader(e){return this._headers[e.toLowerCase()]}getHeaders(){return this._headers}getHeaderNames(){return Object.keys(this._headers)}hasHeader(e){return e.toLowerCase()in this._headers}removeHeader(e){delete this._headers[e.toLowerCase()];}addTrailers(e){}flushHeaders(){}writeEarlyHints(e,t){typeof t=="function"&&t();}}const E=(()=>{const n=function(){};return n.prototype=Object.create(null),n})();function R(n={}){const e=new E,t=Array.isArray(n)||H(n)?n:Object.entries(n);for(const[r,s]of t)if(s){if(e[r]===void 0){e[r]=s;continue}e[r]=[...Array.isArray(e[r])?e[r]:[e[r]],...Array.isArray(s)?s:[s]];}return e}function H(n){return typeof n?.entries=="function"}function v(n={}){if(n instanceof Headers)return n;const e=new Headers;for(const[t,r]of Object.entries(n))if(r!==void 0){if(Array.isArray(r)){for(const s of r)e.append(t,String(s));continue}e.set(t,String(r));}return e}const S=new Set([101,204,205,304]);async function b(n,e){const t=new y,r=new w(t);t.url=e.url?.toString()||"/";let s;if(!t.url.startsWith("/")){const d=new URL(t.url);s=d.host,t.url=d.pathname+d.search+d.hash;}t.method=e.method||"GET",t.headers=R(e.headers||{}),t.headers.host||(t.headers.host=e.host||s||"localhost"),t.connection.encrypted=t.connection.encrypted||e.protocol==="https",t.body=e.body||null,t.__unenv__=e.context,await n(t,r);let a=r._data;(S.has(r.statusCode)||t.method.toUpperCase()==="HEAD")&&(a=null,delete r._headers["content-length"]);const u={status:r.statusCode,statusText:r.statusMessage,headers:r._headers,body:a};return t.destroy(),r.destroy(),u}async function C(n,e,t={}){try{const r=await b(n,{url:e,...t});return new Response(r.body,{status:r.status,statusText:r.statusText,headers:v(r.headers)})}catch(r){return new Response(r.toString(),{status:Number.parseInt(r.statusCode||r.code)||500,statusText:r.statusText})}}

function hasProp(obj, prop) {
  try {
    return prop in obj;
  } catch {
    return false;
  }
}

class H3Error extends Error {
  static __h3_error__ = true;
  statusCode = 500;
  fatal = false;
  unhandled = false;
  statusMessage;
  data;
  cause;
  constructor(message, opts = {}) {
    super(message, opts);
    if (opts.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
  toJSON() {
    const obj = {
      message: this.message,
      statusCode: sanitizeStatusCode(this.statusCode, 500)
    };
    if (this.statusMessage) {
      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);
    }
    if (this.data !== void 0) {
      obj.data = this.data;
    }
    return obj;
  }
}
function createError$2(input) {
  if (typeof input === "string") {
    return new H3Error(input);
  }
  if (isError(input)) {
    return input;
  }
  const err = new H3Error(input.message ?? input.statusMessage ?? "", {
    cause: input.cause || input
  });
  if (hasProp(input, "stack")) {
    try {
      Object.defineProperty(err, "stack", {
        get() {
          return input.stack;
        }
      });
    } catch {
      try {
        err.stack = input.stack;
      } catch {
      }
    }
  }
  if (input.data) {
    err.data = input.data;
  }
  if (input.statusCode) {
    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);
  } else if (input.status) {
    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);
  }
  if (input.statusMessage) {
    err.statusMessage = input.statusMessage;
  } else if (input.statusText) {
    err.statusMessage = input.statusText;
  }
  if (err.statusMessage) {
    const originalMessage = err.statusMessage;
    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);
    if (sanitizedMessage !== originalMessage) {
      console.warn(
        "[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default."
      );
    }
  }
  if (input.fatal !== void 0) {
    err.fatal = input.fatal;
  }
  if (input.unhandled !== void 0) {
    err.unhandled = input.unhandled;
  }
  return err;
}
function sendError(event, error, debug) {
  if (event.handled) {
    return;
  }
  const h3Error = isError(error) ? error : createError$2(error);
  const responseBody = {
    statusCode: h3Error.statusCode,
    statusMessage: h3Error.statusMessage,
    stack: [],
    data: h3Error.data
  };
  if (debug) {
    responseBody.stack = (h3Error.stack || "").split("\n").map((l) => l.trim());
  }
  if (event.handled) {
    return;
  }
  const _code = Number.parseInt(h3Error.statusCode);
  setResponseStatus(event, _code, h3Error.statusMessage);
  event.node.res.setHeader("content-type", MIMES.json);
  event.node.res.end(JSON.stringify(responseBody, void 0, 2));
}
function isError(input) {
  return input?.constructor?.__h3_error__ === true;
}

function getQuery(event) {
  return getQuery$1(event.path || "");
}
function getRouterParams(event, opts = {}) {
  let params = event.context.params || {};
  if (opts.decode) {
    params = { ...params };
    for (const key in params) {
      params[key] = decode$1(params[key]);
    }
  }
  return params;
}
function getRouterParam(event, name, opts = {}) {
  const params = getRouterParams(event, opts);
  return params[name];
}
function isMethod(event, expected, allowHead) {
  if (typeof expected === "string") {
    if (event.method === expected) {
      return true;
    }
  } else if (expected.includes(event.method)) {
    return true;
  }
  return false;
}
function assertMethod(event, expected, allowHead) {
  if (!isMethod(event, expected)) {
    throw createError$2({
      statusCode: 405,
      statusMessage: "HTTP method is not allowed."
    });
  }
}
function getRequestHeaders(event) {
  const _headers = {};
  for (const key in event.node.req.headers) {
    const val = event.node.req.headers[key];
    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(", ") : val;
  }
  return _headers;
}
const getHeaders = getRequestHeaders;
function getRequestHeader(event, name) {
  const headers = getRequestHeaders(event);
  const value = headers[name.toLowerCase()];
  return value;
}
const getHeader = getRequestHeader;
function getRequestHost(event, opts = {}) {
  if (opts.xForwardedHost) {
    const _header = event.node.req.headers["x-forwarded-host"];
    const xForwardedHost = (_header || "").split(",").shift()?.trim();
    if (xForwardedHost) {
      return xForwardedHost;
    }
  }
  return event.node.req.headers.host || "localhost";
}
function getRequestProtocol(event, opts = {}) {
  if (opts.xForwardedProto !== false && event.node.req.headers["x-forwarded-proto"] === "https") {
    return "https";
  }
  return event.node.req.connection?.encrypted ? "https" : "http";
}
function getRequestURL(event, opts = {}) {
  const host = getRequestHost(event, opts);
  const protocol = getRequestProtocol(event, opts);
  const path = (event.node.req.originalUrl || event.path).replace(
    /^[/\\]+/g,
    "/"
  );
  return new URL(path, `${protocol}://${host}`);
}

const RawBodySymbol = Symbol.for("h3RawBody");
const ParsedBodySymbol = Symbol.for("h3ParsedBody");
const PayloadMethods$1 = ["PATCH", "POST", "PUT", "DELETE"];
function readRawBody(event, encoding = "utf8") {
  assertMethod(event, PayloadMethods$1);
  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;
  if (_rawBody) {
    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {
      if (Buffer.isBuffer(_resolved)) {
        return _resolved;
      }
      if (typeof _resolved.pipeTo === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.pipeTo(
            new WritableStream({
              write(chunk) {
                chunks.push(chunk);
              },
              close() {
                resolve(Buffer.concat(chunks));
              },
              abort(reason) {
                reject(reason);
              }
            })
          ).catch(reject);
        });
      } else if (typeof _resolved.pipe === "function") {
        return new Promise((resolve, reject) => {
          const chunks = [];
          _resolved.on("data", (chunk) => {
            chunks.push(chunk);
          }).on("end", () => {
            resolve(Buffer.concat(chunks));
          }).on("error", reject);
        });
      }
      if (_resolved.constructor === Object) {
        return Buffer.from(JSON.stringify(_resolved));
      }
      if (_resolved instanceof URLSearchParams) {
        return Buffer.from(_resolved.toString());
      }
      if (_resolved instanceof FormData) {
        return new Response(_resolved).bytes().then((uint8arr) => Buffer.from(uint8arr));
      }
      return Buffer.from(_resolved);
    });
    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;
  }
  if (!Number.parseInt(event.node.req.headers["content-length"] || "") && !/\bchunked\b/i.test(
    String(event.node.req.headers["transfer-encoding"] ?? "")
  )) {
    return Promise.resolve(void 0);
  }
  const promise = event.node.req[RawBodySymbol] = new Promise(
    (resolve, reject) => {
      const bodyData = [];
      event.node.req.on("error", (err) => {
        reject(err);
      }).on("data", (chunk) => {
        bodyData.push(chunk);
      }).on("end", () => {
        resolve(Buffer.concat(bodyData));
      });
    }
  );
  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;
  return result;
}
async function readBody(event, options = {}) {
  const request = event.node.req;
  if (hasProp(request, ParsedBodySymbol)) {
    return request[ParsedBodySymbol];
  }
  const contentType = request.headers["content-type"] || "";
  const body = await readRawBody(event);
  let parsed;
  if (contentType === "application/json") {
    parsed = _parseJSON(body, options.strict ?? true);
  } else if (contentType.startsWith("application/x-www-form-urlencoded")) {
    parsed = _parseURLEncodedBody(body);
  } else if (contentType.startsWith("text/")) {
    parsed = body;
  } else {
    parsed = _parseJSON(body, options.strict ?? false);
  }
  request[ParsedBodySymbol] = parsed;
  return parsed;
}
function getRequestWebStream(event) {
  if (!PayloadMethods$1.includes(event.method)) {
    return;
  }
  const bodyStream = event.web?.request?.body || event._requestBody;
  if (bodyStream) {
    return bodyStream;
  }
  const _hasRawBody = RawBodySymbol in event.node.req || "rawBody" in event.node.req || "body" in event.node.req || "__unenv__" in event.node.req;
  if (_hasRawBody) {
    return new ReadableStream({
      async start(controller) {
        const _rawBody = await readRawBody(event, false);
        if (_rawBody) {
          controller.enqueue(_rawBody);
        }
        controller.close();
      }
    });
  }
  return new ReadableStream({
    start: (controller) => {
      event.node.req.on("data", (chunk) => {
        controller.enqueue(chunk);
      });
      event.node.req.on("end", () => {
        controller.close();
      });
      event.node.req.on("error", (err) => {
        controller.error(err);
      });
    }
  });
}
function _parseJSON(body = "", strict) {
  if (!body) {
    return void 0;
  }
  try {
    return destr(body, { strict });
  } catch {
    throw createError$2({
      statusCode: 400,
      statusMessage: "Bad Request",
      message: "Invalid JSON body"
    });
  }
}
function _parseURLEncodedBody(body) {
  const form = new URLSearchParams(body);
  const parsedForm = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of form.entries()) {
    if (hasProp(parsedForm, key)) {
      if (!Array.isArray(parsedForm[key])) {
        parsedForm[key] = [parsedForm[key]];
      }
      parsedForm[key].push(value);
    } else {
      parsedForm[key] = value;
    }
  }
  return parsedForm;
}

function handleCacheHeaders(event, opts) {
  const cacheControls = ["public", ...opts.cacheControls || []];
  let cacheMatched = false;
  if (opts.maxAge !== void 0) {
    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);
  }
  if (opts.modifiedTime) {
    const modifiedTime = new Date(opts.modifiedTime);
    const ifModifiedSince = event.node.req.headers["if-modified-since"];
    event.node.res.setHeader("last-modified", modifiedTime.toUTCString());
    if (ifModifiedSince && new Date(ifModifiedSince) >= modifiedTime) {
      cacheMatched = true;
    }
  }
  if (opts.etag) {
    event.node.res.setHeader("etag", opts.etag);
    const ifNonMatch = event.node.req.headers["if-none-match"];
    if (ifNonMatch === opts.etag) {
      cacheMatched = true;
    }
  }
  event.node.res.setHeader("cache-control", cacheControls.join(", "));
  if (cacheMatched) {
    event.node.res.statusCode = 304;
    if (!event.handled) {
      event.node.res.end();
    }
    return true;
  }
  return false;
}

const MIMES = {
  html: "text/html",
  json: "application/json"
};

const DISALLOWED_STATUS_CHARS = /[^\u0009\u0020-\u007E]/g;
function sanitizeStatusMessage(statusMessage = "") {
  return statusMessage.replace(DISALLOWED_STATUS_CHARS, "");
}
function sanitizeStatusCode(statusCode, defaultStatusCode = 200) {
  if (!statusCode) {
    return defaultStatusCode;
  }
  if (typeof statusCode === "string") {
    statusCode = Number.parseInt(statusCode, 10);
  }
  if (statusCode < 100 || statusCode > 999) {
    return defaultStatusCode;
  }
  return statusCode;
}

function getDistinctCookieKey(name, opts) {
  return [name, opts.domain || "", opts.path || "/"].join(";");
}
function setCookie(event, name, value, serializeOptions = {}) {
  if (!serializeOptions.path) {
    serializeOptions = { path: "/", ...serializeOptions };
  }
  const newCookie = serialize$2(name, value, serializeOptions);
  const currentCookies = splitCookiesString(
    event.node.res.getHeader("set-cookie")
  );
  if (currentCookies.length === 0) {
    event.node.res.setHeader("set-cookie", newCookie);
    return;
  }
  const newCookieKey = getDistinctCookieKey(name, serializeOptions);
  event.node.res.removeHeader("set-cookie");
  for (const cookie of currentCookies) {
    const parsed = parseSetCookie(cookie);
    const key = getDistinctCookieKey(parsed.name, parsed);
    if (key === newCookieKey) {
      continue;
    }
    event.node.res.appendHeader("set-cookie", cookie);
  }
  event.node.res.appendHeader("set-cookie", newCookie);
}
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString.flatMap((c) => splitCookiesString(c));
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  const cookiesStrings = [];
  let pos = 0;
  let start;
  let ch;
  let lastComma;
  let nextStart;
  let cookiesSeparatorFound;
  const skipWhitespace = () => {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  };
  const notSpecialChar = () => {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  };
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.slice(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.slice(start));
    }
  }
  return cookiesStrings;
}

const defer = typeof setImmediate === "undefined" ? (fn) => fn() : setImmediate;
function send(event, data, type) {
  if (type) {
    defaultContentType(event, type);
  }
  return new Promise((resolve) => {
    defer(() => {
      if (!event.handled) {
        event.node.res.end(data);
      }
      resolve();
    });
  });
}
function sendNoContent(event, code) {
  if (event.handled) {
    return;
  }
  if (!code && event.node.res.statusCode !== 200) {
    code = event.node.res.statusCode;
  }
  const _code = sanitizeStatusCode(code, 204);
  if (_code === 204) {
    event.node.res.removeHeader("content-length");
  }
  event.node.res.writeHead(_code);
  event.node.res.end();
}
function setResponseStatus(event, code, text) {
  if (code) {
    event.node.res.statusCode = sanitizeStatusCode(
      code,
      event.node.res.statusCode
    );
  }
  if (text) {
    event.node.res.statusMessage = sanitizeStatusMessage(text);
  }
}
function getResponseStatus(event) {
  return event.node.res.statusCode;
}
function getResponseStatusText(event) {
  return event.node.res.statusMessage;
}
function defaultContentType(event, type) {
  if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader("content-type")) {
    event.node.res.setHeader("content-type", type);
  }
}
function sendRedirect(event, location, code = 302) {
  event.node.res.statusCode = sanitizeStatusCode(
    code,
    event.node.res.statusCode
  );
  event.node.res.setHeader("location", location);
  const encodedLoc = location.replace(/"/g, "%22");
  const html = `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`;
  return send(event, html, MIMES.html);
}
function getResponseHeader(event, name) {
  return event.node.res.getHeader(name);
}
function setResponseHeaders(event, headers) {
  for (const [name, value] of Object.entries(headers)) {
    event.node.res.setHeader(
      name,
      value
    );
  }
}
const setHeaders = setResponseHeaders;
function setResponseHeader(event, name, value) {
  event.node.res.setHeader(name, value);
}
const setHeader = setResponseHeader;
function appendResponseHeader(event, name, value) {
  let current = event.node.res.getHeader(name);
  if (!current) {
    event.node.res.setHeader(name, value);
    return;
  }
  if (!Array.isArray(current)) {
    current = [current.toString()];
  }
  event.node.res.setHeader(name, [...current, value]);
}
function isStream(data) {
  if (!data || typeof data !== "object") {
    return false;
  }
  if (typeof data.pipe === "function") {
    if (typeof data._read === "function") {
      return true;
    }
    if (typeof data.abort === "function") {
      return true;
    }
  }
  if (typeof data.pipeTo === "function") {
    return true;
  }
  return false;
}
function isWebResponse(data) {
  return typeof Response !== "undefined" && data instanceof Response;
}
function sendStream(event, stream) {
  if (!stream || typeof stream !== "object") {
    throw new Error("[h3] Invalid stream provided.");
  }
  event.node.res._data = stream;
  if (!event.node.res.socket) {
    event._handled = true;
    return Promise.resolve();
  }
  if (hasProp(stream, "pipeTo") && typeof stream.pipeTo === "function") {
    return stream.pipeTo(
      new WritableStream({
        write(chunk) {
          event.node.res.write(chunk);
        }
      })
    ).then(() => {
      event.node.res.end();
    });
  }
  if (hasProp(stream, "pipe") && typeof stream.pipe === "function") {
    return new Promise((resolve, reject) => {
      stream.pipe(event.node.res);
      if (stream.on) {
        stream.on("end", () => {
          event.node.res.end();
          resolve();
        });
        stream.on("error", (error) => {
          reject(error);
        });
      }
      event.node.res.on("close", () => {
        if (stream.abort) {
          stream.abort();
        }
      });
    });
  }
  throw new Error("[h3] Invalid or incompatible stream provided.");
}
function sendWebResponse(event, response) {
  for (const [key, value] of response.headers) {
    if (key === "set-cookie") {
      event.node.res.appendHeader(key, splitCookiesString(value));
    } else {
      event.node.res.setHeader(key, value);
    }
  }
  if (response.status) {
    event.node.res.statusCode = sanitizeStatusCode(
      response.status,
      event.node.res.statusCode
    );
  }
  if (response.statusText) {
    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  }
  if (response.redirected) {
    event.node.res.setHeader("location", response.url);
  }
  if (!response.body) {
    event.node.res.end();
    return;
  }
  return sendStream(event, response.body);
}

const PayloadMethods = /* @__PURE__ */ new Set(["PATCH", "POST", "PUT", "DELETE"]);
const ignoredHeaders = /* @__PURE__ */ new Set([
  "transfer-encoding",
  "accept-encoding",
  "connection",
  "keep-alive",
  "upgrade",
  "expect",
  "host",
  "accept"
]);
async function proxyRequest(event, target, opts = {}) {
  let body;
  let duplex;
  if (PayloadMethods.has(event.method)) {
    if (opts.streamRequest) {
      body = getRequestWebStream(event);
      duplex = "half";
    } else {
      body = await readRawBody(event, false).catch(() => void 0);
    }
  }
  const method = opts.fetchOptions?.method || event.method;
  const fetchHeaders = mergeHeaders$1(
    getProxyRequestHeaders(event, { host: target.startsWith("/") }),
    opts.fetchOptions?.headers,
    opts.headers
  );
  return sendProxy(event, target, {
    ...opts,
    fetchOptions: {
      method,
      body,
      duplex,
      ...opts.fetchOptions,
      headers: fetchHeaders
    }
  });
}
async function sendProxy(event, target, opts = {}) {
  let response;
  try {
    response = await _getFetch(opts.fetch)(target, {
      headers: opts.headers,
      ignoreResponseError: true,
      // make $ofetch.raw transparent
      ...opts.fetchOptions
    });
  } catch (error) {
    throw createError$2({
      status: 502,
      statusMessage: "Bad Gateway",
      cause: error
    });
  }
  event.node.res.statusCode = sanitizeStatusCode(
    response.status,
    event.node.res.statusCode
  );
  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);
  const cookies = [];
  for (const [key, value] of response.headers.entries()) {
    if (key === "content-encoding") {
      continue;
    }
    if (key === "content-length") {
      continue;
    }
    if (key === "set-cookie") {
      cookies.push(...splitCookiesString(value));
      continue;
    }
    event.node.res.setHeader(key, value);
  }
  if (cookies.length > 0) {
    event.node.res.setHeader(
      "set-cookie",
      cookies.map((cookie) => {
        if (opts.cookieDomainRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookieDomainRewrite,
            "domain"
          );
        }
        if (opts.cookiePathRewrite) {
          cookie = rewriteCookieProperty(
            cookie,
            opts.cookiePathRewrite,
            "path"
          );
        }
        return cookie;
      })
    );
  }
  if (opts.onResponse) {
    await opts.onResponse(event, response);
  }
  if (response._data !== void 0) {
    return response._data;
  }
  if (event.handled) {
    return;
  }
  if (opts.sendStream === false) {
    const data = new Uint8Array(await response.arrayBuffer());
    return event.node.res.end(data);
  }
  if (response.body) {
    for await (const chunk of response.body) {
      event.node.res.write(chunk);
    }
  }
  return event.node.res.end();
}
function getProxyRequestHeaders(event, opts) {
  const headers = /* @__PURE__ */ Object.create(null);
  const reqHeaders = getRequestHeaders(event);
  for (const name in reqHeaders) {
    if (!ignoredHeaders.has(name) || name === "host" && opts?.host) {
      headers[name] = reqHeaders[name];
    }
  }
  return headers;
}
function fetchWithEvent(event, req, init, options) {
  return _getFetch(options?.fetch)(req, {
    ...init,
    context: init?.context || event.context,
    headers: {
      ...getProxyRequestHeaders(event, {
        host: typeof req === "string" && req.startsWith("/")
      }),
      ...init?.headers
    }
  });
}
function _getFetch(_fetch) {
  if (_fetch) {
    return _fetch;
  }
  if (globalThis.fetch) {
    return globalThis.fetch;
  }
  throw new Error(
    "fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js."
  );
}
function rewriteCookieProperty(header, map, property) {
  const _map = typeof map === "string" ? { "*": map } : map;
  return header.replace(
    new RegExp(`(;\\s*${property}=)([^;]+)`, "gi"),
    (match, prefix, previousValue) => {
      let newValue;
      if (previousValue in _map) {
        newValue = _map[previousValue];
      } else if ("*" in _map) {
        newValue = _map["*"];
      } else {
        return match;
      }
      return newValue ? prefix + newValue : "";
    }
  );
}
function mergeHeaders$1(defaults, ...inputs) {
  const _inputs = inputs.filter(Boolean);
  if (_inputs.length === 0) {
    return defaults;
  }
  const merged = new Headers(defaults);
  for (const input of _inputs) {
    const entries = Array.isArray(input) ? input : typeof input.entries === "function" ? input.entries() : Object.entries(input);
    for (const [key, value] of entries) {
      if (value !== void 0) {
        merged.set(key, value);
      }
    }
  }
  return merged;
}

class H3Event {
  "__is_event__" = true;
  // Context
  node;
  // Node
  web;
  // Web
  context = {};
  // Shared
  // Request
  _method;
  _path;
  _headers;
  _requestBody;
  // Response
  _handled = false;
  // Hooks
  _onBeforeResponseCalled;
  _onAfterResponseCalled;
  constructor(req, res) {
    this.node = { req, res };
  }
  // --- Request ---
  get method() {
    if (!this._method) {
      this._method = (this.node.req.method || "GET").toUpperCase();
    }
    return this._method;
  }
  get path() {
    return this._path || this.node.req.url || "/";
  }
  get headers() {
    if (!this._headers) {
      this._headers = _normalizeNodeHeaders(this.node.req.headers);
    }
    return this._headers;
  }
  // --- Respoonse ---
  get handled() {
    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;
  }
  respondWith(response) {
    return Promise.resolve(response).then(
      (_response) => sendWebResponse(this, _response)
    );
  }
  // --- Utils ---
  toString() {
    return `[${this.method}] ${this.path}`;
  }
  toJSON() {
    return this.toString();
  }
  // --- Deprecated ---
  /** @deprecated Please use `event.node.req` instead. */
  get req() {
    return this.node.req;
  }
  /** @deprecated Please use `event.node.res` instead. */
  get res() {
    return this.node.res;
  }
}
function isEvent(input) {
  return hasProp(input, "__is_event__");
}
function createEvent(req, res) {
  return new H3Event(req, res);
}
function _normalizeNodeHeaders(nodeHeaders) {
  const headers = new Headers();
  for (const [name, value] of Object.entries(nodeHeaders)) {
    if (Array.isArray(value)) {
      for (const item of value) {
        headers.append(name, item);
      }
    } else if (value) {
      headers.set(name, value);
    }
  }
  return headers;
}

function defineEventHandler(handler) {
  if (typeof handler === "function") {
    handler.__is_handler__ = true;
    return handler;
  }
  const _hooks = {
    onRequest: _normalizeArray(handler.onRequest),
    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)
  };
  const _handler = (event) => {
    return _callHandler(event, handler.handler, _hooks);
  };
  _handler.__is_handler__ = true;
  _handler.__resolve__ = handler.handler.__resolve__;
  _handler.__websocket__ = handler.websocket;
  return _handler;
}
function _normalizeArray(input) {
  return input ? Array.isArray(input) ? input : [input] : void 0;
}
async function _callHandler(event, handler, hooks) {
  if (hooks.onRequest) {
    for (const hook of hooks.onRequest) {
      await hook(event);
      if (event.handled) {
        return;
      }
    }
  }
  const body = await handler(event);
  const response = { body };
  if (hooks.onBeforeResponse) {
    for (const hook of hooks.onBeforeResponse) {
      await hook(event, response);
    }
  }
  return response.body;
}
const eventHandler = defineEventHandler;
function isEventHandler(input) {
  return hasProp(input, "__is_handler__");
}
function toEventHandler(input, _, _route) {
  if (!isEventHandler(input)) {
    console.warn(
      "[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.",
      _route && _route !== "/" ? `
     Route: ${_route}` : "",
      `
     Handler: ${input}`
    );
  }
  return input;
}
function defineLazyEventHandler(factory) {
  let _promise;
  let _resolved;
  const resolveHandler = () => {
    if (_resolved) {
      return Promise.resolve(_resolved);
    }
    if (!_promise) {
      _promise = Promise.resolve(factory()).then((r) => {
        const handler2 = r.default || r;
        if (typeof handler2 !== "function") {
          throw new TypeError(
            "Invalid lazy handler result. It should be a function:",
            handler2
          );
        }
        _resolved = { handler: toEventHandler(r.default || r) };
        return _resolved;
      });
    }
    return _promise;
  };
  const handler = eventHandler((event) => {
    if (_resolved) {
      return _resolved.handler(event);
    }
    return resolveHandler().then((r) => r.handler(event));
  });
  handler.__resolve__ = resolveHandler;
  return handler;
}
const lazyEventHandler = defineLazyEventHandler;

function createApp(options = {}) {
  const stack = [];
  const handler = createAppEventHandler(stack, options);
  const resolve = createResolver(stack);
  handler.__resolve__ = resolve;
  const getWebsocket = cachedFn(() => websocketOptions(resolve, options));
  const app = {
    // @ts-expect-error
    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),
    resolve,
    handler,
    stack,
    options,
    get websocket() {
      return getWebsocket();
    }
  };
  return app;
}
function use(app, arg1, arg2, arg3) {
  if (Array.isArray(arg1)) {
    for (const i of arg1) {
      use(app, i, arg2, arg3);
    }
  } else if (Array.isArray(arg2)) {
    for (const i of arg2) {
      use(app, arg1, i, arg3);
    }
  } else if (typeof arg1 === "string") {
    app.stack.push(
      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })
    );
  } else if (typeof arg1 === "function") {
    app.stack.push(normalizeLayer({ ...arg2, handler: arg1 }));
  } else {
    app.stack.push(normalizeLayer({ ...arg1 }));
  }
  return app;
}
function createAppEventHandler(stack, options) {
  const spacing = options.debug ? 2 : void 0;
  return eventHandler(async (event) => {
    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || "/";
    const _reqPath = event._path || event.node.req.url || "/";
    let _layerPath;
    if (options.onRequest) {
      await options.onRequest(event);
    }
    for (const layer of stack) {
      if (layer.route.length > 1) {
        if (!_reqPath.startsWith(layer.route)) {
          continue;
        }
        _layerPath = _reqPath.slice(layer.route.length) || "/";
      } else {
        _layerPath = _reqPath;
      }
      if (layer.match && !layer.match(_layerPath, event)) {
        continue;
      }
      event._path = _layerPath;
      event.node.req.url = _layerPath;
      const val = await layer.handler(event);
      const _body = val === void 0 ? void 0 : await val;
      if (_body !== void 0) {
        const _response = { body: _body };
        if (options.onBeforeResponse) {
          event._onBeforeResponseCalled = true;
          await options.onBeforeResponse(event, _response);
        }
        await handleHandlerResponse(event, _response.body, spacing);
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, _response);
        }
        return;
      }
      if (event.handled) {
        if (options.onAfterResponse) {
          event._onAfterResponseCalled = true;
          await options.onAfterResponse(event, void 0);
        }
        return;
      }
    }
    if (!event.handled) {
      throw createError$2({
        statusCode: 404,
        statusMessage: `Cannot find any path matching ${event.path || "/"}.`
      });
    }
    if (options.onAfterResponse) {
      event._onAfterResponseCalled = true;
      await options.onAfterResponse(event, void 0);
    }
  });
}
function createResolver(stack) {
  return async (path) => {
    let _layerPath;
    for (const layer of stack) {
      if (layer.route === "/" && !layer.handler.__resolve__) {
        continue;
      }
      if (!path.startsWith(layer.route)) {
        continue;
      }
      _layerPath = path.slice(layer.route.length) || "/";
      if (layer.match && !layer.match(_layerPath, void 0)) {
        continue;
      }
      let res = { route: layer.route, handler: layer.handler };
      if (res.handler.__resolve__) {
        const _res = await res.handler.__resolve__(_layerPath);
        if (!_res) {
          continue;
        }
        res = {
          ...res,
          ..._res,
          route: joinURL(res.route || "/", _res.route || "/")
        };
      }
      return res;
    }
  };
}
function normalizeLayer(input) {
  let handler = input.handler;
  if (handler.handler) {
    handler = handler.handler;
  }
  if (input.lazy) {
    handler = lazyEventHandler(handler);
  } else if (!isEventHandler(handler)) {
    handler = toEventHandler(handler, void 0, input.route);
  }
  return {
    route: withoutTrailingSlash(input.route),
    match: input.match,
    handler
  };
}
function handleHandlerResponse(event, val, jsonSpace) {
  if (val === null) {
    return sendNoContent(event);
  }
  if (val) {
    if (isWebResponse(val)) {
      return sendWebResponse(event, val);
    }
    if (isStream(val)) {
      return sendStream(event, val);
    }
    if (val.buffer) {
      return send(event, val);
    }
    if (val.arrayBuffer && typeof val.arrayBuffer === "function") {
      return val.arrayBuffer().then((arrayBuffer) => {
        return send(event, Buffer.from(arrayBuffer), val.type);
      });
    }
    if (val instanceof Error) {
      throw createError$2(val);
    }
    if (typeof val.end === "function") {
      return true;
    }
  }
  const valType = typeof val;
  if (valType === "string") {
    return send(event, val, MIMES.html);
  }
  if (valType === "object" || valType === "boolean" || valType === "number") {
    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);
  }
  if (valType === "bigint") {
    return send(event, val.toString(), MIMES.json);
  }
  throw createError$2({
    statusCode: 500,
    statusMessage: `[h3] Cannot send ${valType} as response.`
  });
}
function cachedFn(fn) {
  let cache;
  return () => {
    if (!cache) {
      cache = fn();
    }
    return cache;
  };
}
function websocketOptions(evResolver, appOptions) {
  return {
    ...appOptions.websocket,
    async resolve(info) {
      const url = info.request?.url || info.url || "/";
      const { pathname } = typeof url === "string" ? parseURL$1(url) : url;
      const resolved = await evResolver(pathname);
      return resolved?.handler?.__websocket__ || {};
    }
  };
}

const RouterMethods = [
  "connect",
  "delete",
  "get",
  "head",
  "options",
  "post",
  "put",
  "trace",
  "patch"
];
function createRouter$1(opts = {}) {
  const _router = createRouter$2({});
  const routes = {};
  let _matcher;
  const router = {};
  const addRoute = (path, handler, method) => {
    let route = routes[path];
    if (!route) {
      routes[path] = route = { path, handlers: {} };
      _router.insert(path, route);
    }
    if (Array.isArray(method)) {
      for (const m of method) {
        addRoute(path, handler, m);
      }
    } else {
      route.handlers[method] = toEventHandler(handler, void 0, path);
    }
    return router;
  };
  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || "all");
  for (const method of RouterMethods) {
    router[method] = (path, handle) => router.add(path, handle, method);
  }
  const matchHandler = (path = "/", method = "get") => {
    const qIndex = path.indexOf("?");
    if (qIndex !== -1) {
      path = path.slice(0, Math.max(0, qIndex));
    }
    const matched = _router.lookup(path);
    if (!matched || !matched.handlers) {
      return {
        error: createError$2({
          statusCode: 404,
          name: "Not Found",
          statusMessage: `Cannot find any route matching ${path || "/"}.`
        })
      };
    }
    let handler = matched.handlers[method] || matched.handlers.all;
    if (!handler) {
      if (!_matcher) {
        _matcher = toRouteMatcher(_router);
      }
      const _matches = _matcher.matchAll(path).reverse();
      for (const _match of _matches) {
        if (_match.handlers[method]) {
          handler = _match.handlers[method];
          matched.handlers[method] = matched.handlers[method] || handler;
          break;
        }
        if (_match.handlers.all) {
          handler = _match.handlers.all;
          matched.handlers.all = matched.handlers.all || handler;
          break;
        }
      }
    }
    if (!handler) {
      return {
        error: createError$2({
          statusCode: 405,
          name: "Method Not Allowed",
          statusMessage: `Method ${method} is not allowed on this route.`
        })
      };
    }
    return { matched, handler };
  };
  const isPreemptive = opts.preemptive || opts.preemtive;
  router.handler = eventHandler((event) => {
    const match = matchHandler(
      event.path,
      event.method.toLowerCase()
    );
    if ("error" in match) {
      if (isPreemptive) {
        throw match.error;
      } else {
        return;
      }
    }
    event.context.matchedRoute = match.matched;
    const params = match.matched.params || {};
    event.context.params = params;
    return Promise.resolve(match.handler(event)).then((res) => {
      if (res === void 0 && isPreemptive) {
        return null;
      }
      return res;
    });
  });
  router.handler.__resolve__ = async (path) => {
    path = withLeadingSlash(path);
    const match = matchHandler(path);
    if ("error" in match) {
      return;
    }
    let res = {
      route: match.matched.path,
      handler: match.handler
    };
    if (match.handler.__resolve__) {
      const _res = await match.handler.__resolve__(path);
      if (!_res) {
        return;
      }
      res = { ...res, ..._res };
    }
    return res;
  };
  return router;
}
function toNodeListener(app) {
  const toNodeHandle = async function(req, res) {
    const event = createEvent(req, res);
    try {
      await app.handler(event);
    } catch (_error) {
      const error = createError$2(_error);
      if (!isError(_error)) {
        error.unhandled = true;
      }
      setResponseStatus(event, error.statusCode, error.statusMessage);
      if (app.options.onError) {
        await app.options.onError(error, event);
      }
      if (event.handled) {
        return;
      }
      if (error.unhandled || error.fatal) {
        console.error("[h3]", error.fatal ? "[fatal]" : "[unhandled]", error);
      }
      if (app.options.onBeforeResponse && !event._onBeforeResponseCalled) {
        await app.options.onBeforeResponse(event, { body: error });
      }
      await sendError(event, error, !!app.options.debug);
      if (app.options.onAfterResponse && !event._onAfterResponseCalled) {
        await app.options.onAfterResponse(event, { body: error });
      }
    }
  };
  return toNodeHandle;
}

function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
const defaultTask = { run: (function_) => function_() };
const _createTask = () => defaultTask;
const createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}

class Hookable {
  constructor() {
    this._hooks = {};
    this._before = void 0;
    this._after = void 0;
    this._deprecatedMessages = void 0;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = void 0;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = void 0;
      _function = void 0;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index = this._hooks[name].indexOf(function_);
      if (index !== -1) {
        this._hooks[name].splice(index, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook of _hooks) {
      this.hook(name, hook);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map(
      (key) => this.hook(key, hooks[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== void 0) {
        const index = this._before.indexOf(function_);
        if (index !== -1) {
          this._before.splice(index, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== void 0) {
        const index = this._after.indexOf(function_);
        if (index !== -1) {
          this._after.splice(index, 1);
        }
      }
    };
  }
}
function createHooks() {
  return new Hookable();
}

const s$1=globalThis.Headers,i=globalThis.AbortController,l=globalThis.fetch||(()=>{throw new Error("[node-fetch-native] Failed to fetch: `globalThis.fetch` is not available!")});

class FetchError extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if (opts?.cause && !this.cause) {
      this.cause = opts.cause;
    }
  }
}
function createFetchError(ctx) {
  const errorMessage = ctx.error?.message || ctx.error?.toString() || "";
  const method = ctx.request?.method || ctx.options?.method || "GET";
  const url = ctx.request?.url || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}

const payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  if (value instanceof FormData || value instanceof URLSearchParams) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
const textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
const JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (contentType === "text/event-stream") {
    return "stream";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function resolveFetchOptions(request, input, defaults, Headers) {
  const headers = mergeHeaders(
    input?.headers ?? request?.headers,
    defaults?.headers,
    Headers
  );
  let query;
  if (defaults?.query || defaults?.params || input?.params || input?.query) {
    query = {
      ...defaults?.params,
      ...defaults?.query,
      ...input?.params,
      ...input?.query
    };
  }
  return {
    ...defaults,
    ...input,
    query,
    params: query,
    headers
  };
}
function mergeHeaders(input, defaults, Headers) {
  if (!defaults) {
    return new Headers(input);
  }
  const headers = new Headers(defaults);
  if (input) {
    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {
      headers.set(key, value);
    }
  }
  return headers;
}
async function callHooks(context, hooks) {
  if (hooks) {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        await hook(context);
      }
    } else {
      await hooks(context);
    }
  }
}

const retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
const nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch = globalThis.fetch,
    Headers = globalThis.Headers,
    AbortController = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = typeof context.options.retryDelay === "function" ? context.options.retryDelay(context) : context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: resolveFetchOptions(
        _request,
        _options,
        globalOptions.defaults,
        Headers
      ),
      response: void 0,
      error: void 0
    };
    if (context.options.method) {
      context.options.method = context.options.method.toUpperCase();
    }
    if (context.options.onRequest) {
      await callHooks(context, context.options.onRequest);
      if (!(context.options.headers instanceof Headers)) {
        context.options.headers = new Headers(
          context.options.headers || {}
          /* compat */
        );
      }
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query) {
        context.request = withQuery(context.request, context.options.query);
        delete context.options.query;
      }
      if ("query" in context.options) {
        delete context.options.query;
      }
      if ("params" in context.options) {
        delete context.options.params;
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        const contentType = context.options.headers.get("content-type");
        if (typeof context.options.body !== "string") {
          context.options.body = contentType === "application/x-www-form-urlencoded" ? new URLSearchParams(
            context.options.body
          ).toString() : JSON.stringify(context.options.body);
        }
        if (!contentType) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController();
      abortTimeout = setTimeout(() => {
        const error = new Error(
          "[TimeoutError]: The operation was aborted due to timeout"
        );
        error.name = "TimeoutError";
        error.code = 23;
        controller.abort(error);
      }, context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await callHooks(
          context,
          context.options.onRequestError
        );
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324
    // https://github.com/unjs/ofetch/issues/294
    // https://github.com/JakeChampion/fetch/issues/1454
    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body || context.response._bodyInit;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await callHooks(
        context,
        context.options.onResponse
      );
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await callHooks(
          context,
          context.options.onResponseError
        );
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r = await $fetchRaw(request, options);
    return r._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch(...args);
  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({
    ...globalOptions,
    ...customGlobalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...customGlobalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

function createNodeFetch() {
  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || "false");
  if (!useKeepAlive) {
    return l;
  }
  const agentOptions = { keepAlive: true };
  const httpAgent = new http.Agent(agentOptions);
  const httpsAgent = new https.Agent(agentOptions);
  const nodeFetchOptions = {
    agent(parsedURL) {
      return parsedURL.protocol === "http:" ? httpAgent : httpsAgent;
    }
  };
  return function nodeFetchWithKeepAlive(input, init) {
    return l(input, { ...nodeFetchOptions, ...init });
  };
}
const fetch$1 = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();
const Headers$1 = globalThis.Headers || s$1;
const AbortController$1 = globalThis.AbortController || i;
const ofetch = createFetch({ fetch: fetch$1, Headers: Headers$1, AbortController: AbortController$1 });
const $fetch$1 = ofetch;

function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c) => c.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}

const storageKeyProperties = [
  "has",
  "hasItem",
  "get",
  "getItem",
  "getItemRaw",
  "set",
  "setItem",
  "setItemRaw",
  "del",
  "remove",
  "removeItem",
  "getMeta",
  "setMeta",
  "removeMeta",
  "getKeys",
  "clear",
  "mount",
  "unmount"
];
function prefixStorage(storage, base) {
  base = normalizeBaseKey(base);
  if (!base) {
    return storage;
  }
  const nsStorage = { ...storage };
  for (const property of storageKeyProperties) {
    nsStorage[property] = (key = "", ...args) => (
      // @ts-ignore
      storage[property](base + key, ...args)
    );
  }
  nsStorage.getKeys = (key = "", ...arguments_) => storage.getKeys(base + key, ...arguments_).then((keys) => keys.map((key2) => key2.slice(base.length)));
  nsStorage.keys = nsStorage.getKeys;
  nsStorage.getItems = async (items, commonOptions) => {
    const prefixedItems = items.map(
      (item) => typeof item === "string" ? base + item : { ...item, key: base + item.key }
    );
    const results = await storage.getItems(prefixedItems, commonOptions);
    return results.map((entry) => ({
      key: entry.key.slice(base.length),
      value: entry.value
    }));
  };
  nsStorage.setItems = async (items, commonOptions) => {
    const prefixedItems = items.map((item) => ({
      key: base + item.key,
      value: item.value,
      options: item.options
    }));
    return storage.setItems(prefixedItems, commonOptions);
  };
  return nsStorage;
}
function normalizeKey$2(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys) {
  return normalizeKey$2(keys.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey$2(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

function defineDriver$1(factory) {
  return factory;
}

const DRIVER_NAME$1 = "memory";
const memory = defineDriver$1(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME$1,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});

function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey$2(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch$2(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey$2(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r) => r.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey$2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey$2(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r) => r.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey$2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey$2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey$2(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey$2(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey$2(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!mount.driver.flags?.maxDepth) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey$2(key);
          if (!maskedMounts.some((p) => fullKey.startsWith(p))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m) => {
          if (m.driver.clear) {
            return asyncCall(m.driver.clear, m.relativeBase, opts);
          }
          if (m.driver.removeItem) {
            const keys = await m.driver.getKeys(m.relativeBase || "", opts);
            return Promise.all(
              keys.map((key) => m.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a, b) => b.length - a.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch$2(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]?.();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey$2(key) + ":";
      const m = getMount(key);
      return {
        driver: m.driver,
        base: m.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey$2(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m) => ({
        driver: m.driver,
        base: m.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch$2(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

const _assets = {

};

const normalizeKey$1 = function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
};

const assets = {
  getKeys() {
    return Promise.resolve(Object.keys(_assets))
  },
  hasItem (id) {
    id = normalizeKey$1(id);
    return Promise.resolve(id in _assets)
  },
  getItem (id) {
    id = normalizeKey$1(id);
    return Promise.resolve(_assets[id] ? _assets[id].import() : null)
  },
  getMeta (id) {
    id = normalizeKey$1(id);
    return Promise.resolve(_assets[id] ? _assets[id].meta : {})
  }
};

function defineDriver(factory) {
  return factory;
}
function createError$1(driver, message, opts) {
  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, createError$1);
  }
  return err;
}
function createRequiredError(driver, name) {
  if (Array.isArray(name)) {
    return createError$1(
      driver,
      `Missing some of the required options ${name.map((n) => "`" + n + "`").join(", ")}`
    );
  }
  return createError$1(driver, `Missing required option \`${name}\`.`);
}

function ignoreNotfound(err) {
  return err.code === "ENOENT" || err.code === "EISDIR" ? null : err;
}
function ignoreExists(err) {
  return err.code === "EEXIST" ? null : err;
}
async function writeFile(path, data, encoding) {
  await ensuredir(dirname(path));
  return promises.writeFile(path, data, encoding);
}
function readFile(path, encoding) {
  return promises.readFile(path, encoding).catch(ignoreNotfound);
}
function unlink(path) {
  return promises.unlink(path).catch(ignoreNotfound);
}
function readdir(dir) {
  return promises.readdir(dir, { withFileTypes: true }).catch(ignoreNotfound).then((r) => r || []);
}
async function ensuredir(dir) {
  if (existsSync(dir)) {
    return;
  }
  await ensuredir(dirname(dir)).catch(ignoreExists);
  await promises.mkdir(dir).catch(ignoreExists);
}
async function readdirRecursive(dir, ignore, maxDepth) {
  if (ignore && ignore(dir)) {
    return [];
  }
  const entries = await readdir(dir);
  const files = [];
  await Promise.all(
    entries.map(async (entry) => {
      const entryPath = resolve$1(dir, entry.name);
      if (entry.isDirectory()) {
        if (maxDepth === void 0 || maxDepth > 0) {
          const dirFiles = await readdirRecursive(
            entryPath,
            ignore,
            maxDepth === void 0 ? void 0 : maxDepth - 1
          );
          files.push(...dirFiles.map((f) => entry.name + "/" + f));
        }
      } else {
        if (!(ignore && ignore(entry.name))) {
          files.push(entry.name);
        }
      }
    })
  );
  return files;
}
async function rmRecursive(dir) {
  const entries = await readdir(dir);
  await Promise.all(
    entries.map((entry) => {
      const entryPath = resolve$1(dir, entry.name);
      if (entry.isDirectory()) {
        return rmRecursive(entryPath).then(() => promises.rmdir(entryPath));
      } else {
        return promises.unlink(entryPath);
      }
    })
  );
}

const PATH_TRAVERSE_RE = /\.\.:|\.\.$/;
const DRIVER_NAME = "fs-lite";
const unstorage_47drivers_47fs_45lite = defineDriver((opts = {}) => {
  if (!opts.base) {
    throw createRequiredError(DRIVER_NAME, "base");
  }
  opts.base = resolve$1(opts.base);
  const r = (key) => {
    if (PATH_TRAVERSE_RE.test(key)) {
      throw createError$1(
        DRIVER_NAME,
        `Invalid key: ${JSON.stringify(key)}. It should not contain .. segments`
      );
    }
    const resolved = join(opts.base, key.replace(/:/g, "/"));
    return resolved;
  };
  return {
    name: DRIVER_NAME,
    options: opts,
    flags: {
      maxDepth: true
    },
    hasItem(key) {
      return existsSync(r(key));
    },
    getItem(key) {
      return readFile(r(key), "utf8");
    },
    getItemRaw(key) {
      return readFile(r(key));
    },
    async getMeta(key) {
      const { atime, mtime, size, birthtime, ctime } = await promises.stat(r(key)).catch(() => ({}));
      return { atime, mtime, size, birthtime, ctime };
    },
    setItem(key, value) {
      if (opts.readOnly) {
        return;
      }
      return writeFile(r(key), value, "utf8");
    },
    setItemRaw(key, value) {
      if (opts.readOnly) {
        return;
      }
      return writeFile(r(key), value);
    },
    removeItem(key) {
      if (opts.readOnly) {
        return;
      }
      return unlink(r(key));
    },
    getKeys(_base, topts) {
      return readdirRecursive(r("."), opts.ignore, topts?.maxDepth);
    },
    async clear() {
      if (opts.readOnly || opts.noClear) {
        return;
      }
      await rmRecursive(r("."));
    }
  };
});

const storage = createStorage({});

storage.mount('/assets', assets);

storage.mount('data', unstorage_47drivers_47fs_45lite({"driver":"fsLite","base":"./.data/kv"}));

function useStorage(base = "") {
  return base ? prefixStorage(storage, base) : storage;
}

function serialize$1(o){return typeof o=="string"?`'${o}'`:new c().serialize(o)}const c=/*@__PURE__*/function(){class o{#t=new Map;compare(t,r){const e=typeof t,n=typeof r;return e==="string"&&n==="string"?t.localeCompare(r):e==="number"&&n==="number"?t-r:String.prototype.localeCompare.call(this.serialize(t,true),this.serialize(r,true))}serialize(t,r){if(t===null)return "null";switch(typeof t){case "string":return r?t:`'${t}'`;case "bigint":return `${t}n`;case "object":return this.$object(t);case "function":return this.$function(t)}return String(t)}serializeObject(t){const r=Object.prototype.toString.call(t);if(r!=="[object Object]")return this.serializeBuiltInType(r.length<10?`unknown:${r}`:r.slice(8,-1),t);const e=t.constructor,n=e===Object||e===void 0?"":e.name;if(n!==""&&globalThis[n]===e)return this.serializeBuiltInType(n,t);if(typeof t.toJSON=="function"){const i=t.toJSON();return n+(i!==null&&typeof i=="object"?this.$object(i):`(${this.serialize(i)})`)}return this.serializeObjectEntries(n,Object.entries(t))}serializeBuiltInType(t,r){const e=this["$"+t];if(e)return e.call(this,r);if(typeof r?.entries=="function")return this.serializeObjectEntries(t,r.entries());throw new Error(`Cannot serialize ${t}`)}serializeObjectEntries(t,r){const e=Array.from(r).sort((i,a)=>this.compare(i[0],a[0]));let n=`${t}{`;for(let i=0;i<e.length;i++){const[a,l]=e[i];n+=`${this.serialize(a,true)}:${this.serialize(l)}`,i<e.length-1&&(n+=",");}return n+"}"}$object(t){let r=this.#t.get(t);return r===void 0&&(this.#t.set(t,`#${this.#t.size}`),r=this.serializeObject(t),this.#t.set(t,r)),r}$function(t){const r=Function.prototype.toString.call(t);return r.slice(-15)==="[native code] }"?`${t.name||""}()[native]`:`${t.name}(${t.length})${r.replace(/\s*\n\s*/g,"")}`}$Array(t){let r="[";for(let e=0;e<t.length;e++)r+=this.serialize(t[e]),e<t.length-1&&(r+=",");return r+"]"}$Date(t){try{return `Date(${t.toISOString()})`}catch{return "Date(null)"}}$ArrayBuffer(t){return `ArrayBuffer[${new Uint8Array(t).join(",")}]`}$Set(t){return `Set${this.$Array(Array.from(t).sort((r,e)=>this.compare(r,e)))}`}$Map(t){return this.serializeObjectEntries("Map",t.entries())}}for(const s of ["Error","RegExp","URL"])o.prototype["$"+s]=function(t){return `${s}(${t})`};for(const s of ["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"])o.prototype["$"+s]=function(t){return `${s}[${t.join(",")}]`};for(const s of ["BigInt64Array","BigUint64Array"])o.prototype["$"+s]=function(t){return `${s}[${t.join("n,")}${t.length>0?"n":""}]`};return o}();

const e=globalThis.process?.getBuiltinModule?.("crypto")?.hash,r="sha256",s="base64url";function digest(t){if(e)return e(r,t,s);const o=createHash(r).update(t);return globalThis.process?.versions?.webcontainer?o.digest().toString(s):o.digest(s)}

function hash$1(input) {
  return digest(serialize$1(input));
}

const Hasher = /* @__PURE__ */ (() => {
  class Hasher2 {
    buff = "";
    #context = /* @__PURE__ */ new Map();
    write(str) {
      this.buff += str;
    }
    dispatch(value) {
      const type = value === null ? "null" : typeof value;
      return this[type](value);
    }
    object(object) {
      if (object && typeof object.toJSON === "function") {
        return this.object(object.toJSON());
      }
      const objString = Object.prototype.toString.call(object);
      let objType = "";
      const objectLength = objString.length;
      objType = objectLength < 10 ? "unknown:[" + objString + "]" : objString.slice(8, objectLength - 1);
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = this.#context.get(object)) === void 0) {
        this.#context.set(object, this.#context.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
        this.write("buffer:");
        return this.write(object.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object);
        } else {
          this.unknown(object, objType);
        }
      } else {
        const keys = Object.keys(object).sort();
        const extraKeys = [];
        this.write("object:" + (keys.length + extraKeys.length) + ":");
        const dispatchForKey = (key) => {
          this.dispatch(key);
          this.write(":");
          this.dispatch(object[key]);
          this.write(",");
        };
        for (const key of keys) {
          dispatchForKey(key);
        }
        for (const key of extraKeys) {
          dispatchForKey(key);
        }
      }
    }
    array(arr, unordered) {
      unordered = unordered === void 0 ? false : unordered;
      this.write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        for (const entry of arr) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries = arr.map((entry) => {
        const hasher = new Hasher2();
        hasher.dispatch(entry);
        for (const [key, value] of hasher.#context) {
          contextAdditions.set(key, value);
        }
        return hasher.toString();
      });
      this.#context = contextAdditions;
      entries.sort();
      return this.array(entries, false);
    }
    date(date) {
      return this.write("date:" + date.toJSON());
    }
    symbol(sym) {
      return this.write("symbol:" + sym.toString());
    }
    unknown(value, type) {
      this.write(type);
      if (!value) {
        return;
      }
      this.write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          [...value.entries()],
          true
          /* ordered */
        );
      }
    }
    error(err) {
      return this.write("error:" + err.toString());
    }
    boolean(bool) {
      return this.write("bool:" + bool);
    }
    string(string) {
      this.write("string:" + string.length + ":");
      this.write(string);
    }
    function(fn) {
      this.write("fn:");
      if (isNativeFunction(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
    }
    number(number) {
      return this.write("number:" + number);
    }
    null() {
      return this.write("Null");
    }
    undefined() {
      return this.write("Undefined");
    }
    regexp(regex) {
      return this.write("regex:" + regex.toString());
    }
    arraybuffer(arr) {
      this.write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    }
    url(url) {
      return this.write("url:" + url.toString());
    }
    map(map) {
      this.write("map:");
      const arr = [...map];
      return this.array(arr, false);
    }
    set(set) {
      this.write("set:");
      const arr = [...set];
      return this.array(arr, false);
    }
    bigint(number) {
      return this.write("bigint:" + number.toString());
    }
  }
  for (const type of [
    "uint8array",
    "uint8clampedarray",
    "unt8array",
    "uint16array",
    "unt16array",
    "uint32array",
    "unt32array",
    "float32array",
    "float64array"
  ]) {
    Hasher2.prototype[type] = function(arr) {
      this.write(type + ":");
      return this.array([...arr], false);
    };
  }
  function isNativeFunction(f) {
    if (typeof f !== "function") {
      return false;
    }
    return Function.prototype.toString.call(f).slice(
      -15
      /* "[native code] }".length */
    ) === "[native code] }";
  }
  return Hasher2;
})();
function serialize(object) {
  const hasher = new Hasher();
  hasher.dispatch(object);
  return hasher.buff;
}
function hash(value) {
  return digest(typeof value === "string" ? value : serialize(value)).replace(/[-_]/g, "").slice(0, 10);
}

function defaultCacheOptions() {
  return {
    name: "_",
    base: "/cache",
    swr: true,
    maxAge: 1
  };
}
function defineCachedFunction(fn, opts = {}) {
  opts = { ...defaultCacheOptions(), ...opts };
  const pending = {};
  const group = opts.group || "nitro/functions";
  const name = opts.name || fn.name || "_";
  const integrity = opts.integrity || hash([fn, opts]);
  const validate = opts.validate || ((entry) => entry.value !== void 0);
  async function get(key, resolver, shouldInvalidateCache, event) {
    const cacheKey = [opts.base, group, name, key + ".json"].filter(Boolean).join(":").replace(/:\/$/, ":index");
    let entry = await useStorage().getItem(cacheKey).catch((error) => {
      console.error(`[cache] Cache read error.`, error);
      useNitroApp().captureError(error, { event, tags: ["cache"] });
    }) || {};
    if (typeof entry !== "object") {
      entry = {};
      const error = new Error("Malformed data read from cache.");
      console.error("[cache]", error);
      useNitroApp().captureError(error, { event, tags: ["cache"] });
    }
    const ttl = (opts.maxAge ?? 0) * 1e3;
    if (ttl) {
      entry.expires = Date.now() + ttl;
    }
    const expired = shouldInvalidateCache || entry.integrity !== integrity || ttl && Date.now() - (entry.mtime || 0) > ttl || validate(entry) === false;
    const _resolve = async () => {
      const isPending = pending[key];
      if (!isPending) {
        if (entry.value !== void 0 && (opts.staleMaxAge || 0) >= 0 && opts.swr === false) {
          entry.value = void 0;
          entry.integrity = void 0;
          entry.mtime = void 0;
          entry.expires = void 0;
        }
        pending[key] = Promise.resolve(resolver());
      }
      try {
        entry.value = await pending[key];
      } catch (error) {
        if (!isPending) {
          delete pending[key];
        }
        throw error;
      }
      if (!isPending) {
        entry.mtime = Date.now();
        entry.integrity = integrity;
        delete pending[key];
        if (validate(entry) !== false) {
          let setOpts;
          if (opts.maxAge && !opts.swr) {
            setOpts = { ttl: opts.maxAge };
          }
          const promise = useStorage().setItem(cacheKey, entry, setOpts).catch((error) => {
            console.error(`[cache] Cache write error.`, error);
            useNitroApp().captureError(error, { event, tags: ["cache"] });
          });
          if (event?.waitUntil) {
            event.waitUntil(promise);
          }
        }
      }
    };
    const _resolvePromise = expired ? _resolve() : Promise.resolve();
    if (entry.value === void 0) {
      await _resolvePromise;
    } else if (expired && event && event.waitUntil) {
      event.waitUntil(_resolvePromise);
    }
    if (opts.swr && validate(entry) !== false) {
      _resolvePromise.catch((error) => {
        console.error(`[cache] SWR handler error.`, error);
        useNitroApp().captureError(error, { event, tags: ["cache"] });
      });
      return entry;
    }
    return _resolvePromise.then(() => entry);
  }
  return async (...args) => {
    const shouldBypassCache = await opts.shouldBypassCache?.(...args);
    if (shouldBypassCache) {
      return fn(...args);
    }
    const key = await (opts.getKey || getKey)(...args);
    const shouldInvalidateCache = await opts.shouldInvalidateCache?.(...args);
    const entry = await get(
      key,
      () => fn(...args),
      shouldInvalidateCache,
      args[0] && isEvent(args[0]) ? args[0] : void 0
    );
    let value = entry.value;
    if (opts.transform) {
      value = await opts.transform(entry, ...args) || value;
    }
    return value;
  };
}
function cachedFunction(fn, opts = {}) {
  return defineCachedFunction(fn, opts);
}
function getKey(...args) {
  return args.length > 0 ? hash(args) : "";
}
function escapeKey(key) {
  return String(key).replace(/\W/g, "");
}
function defineCachedEventHandler(handler, opts = defaultCacheOptions()) {
  const variableHeaderNames = (opts.varies || []).filter(Boolean).map((h) => h.toLowerCase()).sort();
  const _opts = {
    ...opts,
    getKey: async (event) => {
      const customKey = await opts.getKey?.(event);
      if (customKey) {
        return escapeKey(customKey);
      }
      const _path = event.node.req.originalUrl || event.node.req.url || event.path;
      let _pathname;
      try {
        _pathname = escapeKey(decodeURI(parseURL$1(_path).pathname)).slice(0, 16) || "index";
      } catch {
        _pathname = "-";
      }
      const _hashedPath = `${_pathname}.${hash(_path)}`;
      const _headers = variableHeaderNames.map((header) => [header, event.node.req.headers[header]]).map(([name, value]) => `${escapeKey(name)}.${hash(value)}`);
      return [_hashedPath, ..._headers].join(":");
    },
    validate: (entry) => {
      if (!entry.value) {
        return false;
      }
      if (entry.value.code >= 400) {
        return false;
      }
      if (entry.value.body === void 0) {
        return false;
      }
      if (entry.value.headers.etag === "undefined" || entry.value.headers["last-modified"] === "undefined") {
        return false;
      }
      return true;
    },
    group: opts.group || "nitro/handlers",
    integrity: opts.integrity || hash([handler, opts])
  };
  const _cachedHandler = cachedFunction(
    async (incomingEvent) => {
      const variableHeaders = {};
      for (const header of variableHeaderNames) {
        const value = incomingEvent.node.req.headers[header];
        if (value !== void 0) {
          variableHeaders[header] = value;
        }
      }
      const reqProxy = cloneWithProxy(incomingEvent.node.req, {
        headers: variableHeaders
      });
      const resHeaders = {};
      let _resSendBody;
      const resProxy = cloneWithProxy(incomingEvent.node.res, {
        statusCode: 200,
        writableEnded: false,
        writableFinished: false,
        headersSent: false,
        closed: false,
        getHeader(name) {
          return resHeaders[name];
        },
        setHeader(name, value) {
          resHeaders[name] = value;
          return this;
        },
        getHeaderNames() {
          return Object.keys(resHeaders);
        },
        hasHeader(name) {
          return name in resHeaders;
        },
        removeHeader(name) {
          delete resHeaders[name];
        },
        getHeaders() {
          return resHeaders;
        },
        end(chunk, arg2, arg3) {
          if (typeof chunk === "string") {
            _resSendBody = chunk;
          }
          if (typeof arg2 === "function") {
            arg2();
          }
          if (typeof arg3 === "function") {
            arg3();
          }
          return this;
        },
        write(chunk, arg2, arg3) {
          if (typeof chunk === "string") {
            _resSendBody = chunk;
          }
          if (typeof arg2 === "function") {
            arg2(void 0);
          }
          if (typeof arg3 === "function") {
            arg3();
          }
          return true;
        },
        writeHead(statusCode, headers2) {
          this.statusCode = statusCode;
          if (headers2) {
            if (Array.isArray(headers2) || typeof headers2 === "string") {
              throw new TypeError("Raw headers  is not supported.");
            }
            for (const header in headers2) {
              const value = headers2[header];
              if (value !== void 0) {
                this.setHeader(
                  header,
                  value
                );
              }
            }
          }
          return this;
        }
      });
      const event = createEvent(reqProxy, resProxy);
      event.fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {
        fetch: useNitroApp().localFetch
      });
      event.$fetch = (url, fetchOptions) => fetchWithEvent(event, url, fetchOptions, {
        fetch: globalThis.$fetch
      });
      event.waitUntil = incomingEvent.waitUntil;
      event.context = incomingEvent.context;
      event.context.cache = {
        options: _opts
      };
      const body = await handler(event) || _resSendBody;
      const headers = event.node.res.getHeaders();
      headers.etag = String(
        headers.Etag || headers.etag || `W/"${hash(body)}"`
      );
      headers["last-modified"] = String(
        headers["Last-Modified"] || headers["last-modified"] || (/* @__PURE__ */ new Date()).toUTCString()
      );
      const cacheControl = [];
      if (opts.swr) {
        if (opts.maxAge) {
          cacheControl.push(`s-maxage=${opts.maxAge}`);
        }
        if (opts.staleMaxAge) {
          cacheControl.push(`stale-while-revalidate=${opts.staleMaxAge}`);
        } else {
          cacheControl.push("stale-while-revalidate");
        }
      } else if (opts.maxAge) {
        cacheControl.push(`max-age=${opts.maxAge}`);
      }
      if (cacheControl.length > 0) {
        headers["cache-control"] = cacheControl.join(", ");
      }
      const cacheEntry = {
        code: event.node.res.statusCode,
        headers,
        body
      };
      return cacheEntry;
    },
    _opts
  );
  return defineEventHandler(async (event) => {
    if (opts.headersOnly) {
      if (handleCacheHeaders(event, { maxAge: opts.maxAge })) {
        return;
      }
      return handler(event);
    }
    const response = await _cachedHandler(
      event
    );
    if (event.node.res.headersSent || event.node.res.writableEnded) {
      return response.body;
    }
    if (handleCacheHeaders(event, {
      modifiedTime: new Date(response.headers["last-modified"]),
      etag: response.headers.etag,
      maxAge: opts.maxAge
    })) {
      return;
    }
    event.node.res.statusCode = response.code;
    for (const name in response.headers) {
      const value = response.headers[name];
      if (name === "set-cookie") {
        event.node.res.appendHeader(
          name,
          splitCookiesString(value)
        );
      } else {
        if (value !== void 0) {
          event.node.res.setHeader(name, value);
        }
      }
    }
    return response.body;
  });
}
function cloneWithProxy(obj, overrides) {
  return new Proxy(obj, {
    get(target, property, receiver) {
      if (property in overrides) {
        return overrides[property];
      }
      return Reflect.get(target, property, receiver);
    },
    set(target, property, value, receiver) {
      if (property in overrides) {
        overrides[property] = value;
        return true;
      }
      return Reflect.set(target, property, value, receiver);
    }
  });
}
const cachedEventHandler = defineCachedEventHandler;

function klona(x) {
	if (typeof x !== 'object') return x;

	var k, tmp, str=Object.prototype.toString.call(x);

	if (str === '[object Object]') {
		if (x.constructor !== Object && typeof x.constructor === 'function') {
			tmp = new x.constructor();
			for (k in x) {
				if (x.hasOwnProperty(k) && tmp[k] !== x[k]) {
					tmp[k] = klona(x[k]);
				}
			}
		} else {
			tmp = {}; // null
			for (k in x) {
				if (k === '__proto__') {
					Object.defineProperty(tmp, k, {
						value: klona(x[k]),
						configurable: true,
						enumerable: true,
						writable: true,
					});
				} else {
					tmp[k] = klona(x[k]);
				}
			}
		}
		return tmp;
	}

	if (str === '[object Array]') {
		k = x.length;
		for (tmp=Array(k); k--;) {
			tmp[k] = klona(x[k]);
		}
		return tmp;
	}

	if (str === '[object Set]') {
		tmp = new Set;
		x.forEach(function (val) {
			tmp.add(klona(val));
		});
		return tmp;
	}

	if (str === '[object Map]') {
		tmp = new Map;
		x.forEach(function (val, key) {
			tmp.set(klona(key), klona(val));
		});
		return tmp;
	}

	if (str === '[object Date]') {
		return new Date(+x);
	}

	if (str === '[object RegExp]') {
		tmp = new RegExp(x.source, x.flags);
		tmp.lastIndex = x.lastIndex;
		return tmp;
	}

	if (str === '[object DataView]') {
		return new x.constructor( klona(x.buffer) );
	}

	if (str === '[object ArrayBuffer]') {
		return x.slice(0);
	}

	// ArrayBuffer.isView(x)
	// ~> `new` bcuz `Buffer.slice` => ref
	if (str.slice(-6) === 'Array]') {
		return new x.constructor(x);
	}

	return x;
}

const inlineAppConfig = {
  "nuxt": {}
};



const appConfig = defuFn(inlineAppConfig);

const NUMBER_CHAR_RE = /\d/;
const STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char)) {
    return void 0;
  }
  return char !== char.toLowerCase();
}
function splitByCase(str, separators) {
  const splitters = STR_SPLITTERS;
  const parts = [];
  if (!str || typeof str !== "string") {
    return parts;
  }
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = splitters.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function kebabCase(str, joiner) {
  return str ? (Array.isArray(str) ? str : splitByCase(str)).map((p) => p.toLowerCase()).join(joiner) : "";
}
function snakeCase(str) {
  return kebabCase(str || "", "_");
}

function getEnv(key, opts) {
  const envKey = snakeCase(key).toUpperCase();
  return destr(
    process.env[opts.prefix + envKey] ?? process.env[opts.altPrefix + envKey]
  );
}
function _isObject(input) {
  return typeof input === "object" && !Array.isArray(input);
}
function applyEnv(obj, opts, parentKey = "") {
  for (const key in obj) {
    const subKey = parentKey ? `${parentKey}_${key}` : key;
    const envValue = getEnv(subKey, opts);
    if (_isObject(obj[key])) {
      if (_isObject(envValue)) {
        obj[key] = { ...obj[key], ...envValue };
        applyEnv(obj[key], opts, subKey);
      } else if (envValue === void 0) {
        applyEnv(obj[key], opts, subKey);
      } else {
        obj[key] = envValue ?? obj[key];
      }
    } else {
      obj[key] = envValue ?? obj[key];
    }
    if (opts.envExpansion && typeof obj[key] === "string") {
      obj[key] = _expandFromEnv(obj[key]);
    }
  }
  return obj;
}
const envExpandRx = /\{\{([^{}]*)\}\}/g;
function _expandFromEnv(value) {
  return value.replace(envExpandRx, (match, key) => {
    return process.env[key] || match;
  });
}

const _inlineRuntimeConfig = {
  "app": {
    "baseURL": "/",
    "buildId": "a8862fa3-d3a8-45c9-81bb-5b9e6eee96cd",
    "buildAssetsDir": "/_nuxt/",
    "cdnURL": ""
  },
  "nitro": {
    "envPrefix": "NUXT_",
    "routeRules": {
      "/__nuxt_error": {
        "cache": false,
        "isr": false
      },
      "/_nuxt/builds/meta/**": {
        "headers": {
          "cache-control": "public, max-age=31536000, immutable"
        }
      },
      "/_nuxt/builds/**": {
        "headers": {
          "cache-control": "public, max-age=1, immutable"
        }
      },
      "/_nuxt/**": {
        "headers": {
          "cache-control": "public, max-age=31536000, immutable"
        }
      }
    }
  },
  "public": {
    "supabaseUrl": "https://rqryspxfvfzfghrfqtbm.supabase.co",
    "supabaseKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxcnlzcHhmdmZ6ZmdocmZxdGJtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgwMTY3NTksImV4cCI6MjA4MzU5Mjc1OX0.bptJ9j_zu151GLQO35kdvXOJzWaRL_7d0haRHKS3jDo",
    "baseUrl": "http://localhost:3000",
    "supabase": {
      "url": "https://rqryspxfvfzfghrfqtbm.supabase.co",
      "key": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxcnlzcHhmdmZ6ZmdocmZxdGJtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgwMTY3NTksImV4cCI6MjA4MzU5Mjc1OX0.bptJ9j_zu151GLQO35kdvXOJzWaRL_7d0haRHKS3jDo",
      "redirect": false,
      "redirectOptions": {
        "login": "/login",
        "callback": "/confirm",
        "exclude": [
          "/",
          "/login"
        ],
        "cookieRedirect": false,
        "saveRedirectToCookie": false
      },
      "cookieName": "sb",
      "cookiePrefix": "sb-rqryspxfvfzfghrfqtbm-auth-token",
      "useSsrCookies": true,
      "cookieOptions": {
        "maxAge": 28800,
        "sameSite": "lax",
        "secure": true
      },
      "clientOptions": {}
    }
  },
  "supabaseServiceRoleKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxcnlzcHhmdmZ6ZmdocmZxdGJtIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2ODAxNjc1OSwiZXhwIjoyMDgzNTkyNzU5fQ._AQ67F_-Z9Cvfqv5_ZISgMDbYGRCk2P5wqK1JdFBYA4",
  "supabase": {
    "serviceKey": "",
    "secretKey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJxcnlzcHhmdmZ6ZmdocmZxdGJtIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2ODAxNjc1OSwiZXhwIjoyMDgzNTkyNzU5fQ._AQ67F_-Z9Cvfqv5_ZISgMDbYGRCk2P5wqK1JdFBYA4"
  }
};
const envOptions = {
  prefix: "NITRO_",
  altPrefix: _inlineRuntimeConfig.nitro.envPrefix ?? process.env.NITRO_ENV_PREFIX ?? "_",
  envExpansion: _inlineRuntimeConfig.nitro.envExpansion ?? process.env.NITRO_ENV_EXPANSION ?? false
};
const _sharedRuntimeConfig = _deepFreeze(
  applyEnv(klona(_inlineRuntimeConfig), envOptions)
);
function useRuntimeConfig$1(event) {
  if (!event) {
    return _sharedRuntimeConfig;
  }
  if (event.context.nitro.runtimeConfig) {
    return event.context.nitro.runtimeConfig;
  }
  const runtimeConfig = klona(_inlineRuntimeConfig);
  applyEnv(runtimeConfig, envOptions);
  event.context.nitro.runtimeConfig = runtimeConfig;
  return runtimeConfig;
}
_deepFreeze(klona(appConfig));
function _deepFreeze(object) {
  const propNames = Object.getOwnPropertyNames(object);
  for (const name of propNames) {
    const value = object[name];
    if (value && typeof value === "object") {
      _deepFreeze(value);
    }
  }
  return Object.freeze(object);
}
new Proxy(/* @__PURE__ */ Object.create(null), {
  get: (_, prop) => {
    console.warn(
      "Please use `useRuntimeConfig()` instead of accessing config directly."
    );
    const runtimeConfig = useRuntimeConfig$1();
    if (prop in runtimeConfig) {
      return runtimeConfig[prop];
    }
    return void 0;
  }
});

function createContext(opts = {}) {
  let currentInstance;
  let isSingleton = false;
  const checkConflict = (instance) => {
    if (currentInstance && currentInstance !== instance) {
      throw new Error("Context conflict");
    }
  };
  let als;
  if (opts.asyncContext) {
    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;
    if (_AsyncLocalStorage) {
      als = new _AsyncLocalStorage();
    } else {
      console.warn("[unctx] `AsyncLocalStorage` is not provided.");
    }
  }
  const _getCurrentInstance = () => {
    if (als) {
      const instance = als.getStore();
      if (instance !== void 0) {
        return instance;
      }
    }
    return currentInstance;
  };
  return {
    use: () => {
      const _instance = _getCurrentInstance();
      if (_instance === void 0) {
        throw new Error("Context is not available");
      }
      return _instance;
    },
    tryUse: () => {
      return _getCurrentInstance();
    },
    set: (instance, replace) => {
      if (!replace) {
        checkConflict(instance);
      }
      currentInstance = instance;
      isSingleton = true;
    },
    unset: () => {
      currentInstance = void 0;
      isSingleton = false;
    },
    call: (instance, callback) => {
      checkConflict(instance);
      currentInstance = instance;
      try {
        return als ? als.run(instance, callback) : callback();
      } finally {
        if (!isSingleton) {
          currentInstance = void 0;
        }
      }
    },
    async callAsync(instance, callback) {
      currentInstance = instance;
      const onRestore = () => {
        currentInstance = instance;
      };
      const onLeave = () => currentInstance === instance ? onRestore : void 0;
      asyncHandlers.add(onLeave);
      try {
        const r = als ? als.run(instance, callback) : callback();
        if (!isSingleton) {
          currentInstance = void 0;
        }
        return await r;
      } finally {
        asyncHandlers.delete(onLeave);
      }
    }
  };
}
function createNamespace(defaultOpts = {}) {
  const contexts = {};
  return {
    get(key, opts = {}) {
      if (!contexts[key]) {
        contexts[key] = createContext({ ...defaultOpts, ...opts });
      }
      return contexts[key];
    }
  };
}
const _globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};
const globalKey = "__unctx__";
const defaultNamespace = _globalThis$1[globalKey] || (_globalThis$1[globalKey] = createNamespace());
const getContext$1 = (key, opts = {}) => defaultNamespace.get(key, opts);
const asyncHandlersKey = "__unctx_async_handlers__";
const asyncHandlers = _globalThis$1[asyncHandlersKey] || (_globalThis$1[asyncHandlersKey] = /* @__PURE__ */ new Set());
function executeAsync(function_) {
  const restores = [];
  for (const leaveHandler of asyncHandlers) {
    const restore2 = leaveHandler();
    if (restore2) {
      restores.push(restore2);
    }
  }
  const restore = () => {
    for (const restore2 of restores) {
      restore2();
    }
  };
  let awaitable = function_();
  if (awaitable && typeof awaitable === "object" && "catch" in awaitable) {
    awaitable = awaitable.catch((error) => {
      restore();
      throw error;
    });
  }
  return [awaitable, restore];
}

const config = useRuntimeConfig$1();
const _routeRulesMatcher = toRouteMatcher(
  createRouter$2({ routes: config.nitro.routeRules })
);
function createRouteRulesHandler(ctx) {
  return eventHandler((event) => {
    const routeRules = getRouteRules$1(event);
    if (routeRules.headers) {
      setHeaders(event, routeRules.headers);
    }
    if (routeRules.redirect) {
      let target = routeRules.redirect.to;
      if (target.endsWith("/**")) {
        let targetPath = event.path;
        const strpBase = routeRules.redirect._redirectStripBase;
        if (strpBase) {
          targetPath = withoutBase(targetPath, strpBase);
        }
        target = joinURL(target.slice(0, -3), targetPath);
      } else if (event.path.includes("?")) {
        const query = getQuery$1(event.path);
        target = withQuery(target, query);
      }
      return sendRedirect(event, target, routeRules.redirect.statusCode);
    }
    if (routeRules.proxy) {
      let target = routeRules.proxy.to;
      if (target.endsWith("/**")) {
        let targetPath = event.path;
        const strpBase = routeRules.proxy._proxyStripBase;
        if (strpBase) {
          targetPath = withoutBase(targetPath, strpBase);
        }
        target = joinURL(target.slice(0, -3), targetPath);
      } else if (event.path.includes("?")) {
        const query = getQuery$1(event.path);
        target = withQuery(target, query);
      }
      return proxyRequest(event, target, {
        fetch: ctx.localFetch,
        ...routeRules.proxy
      });
    }
  });
}
function getRouteRules$1(event) {
  event.context._nitro = event.context._nitro || {};
  if (!event.context._nitro.routeRules) {
    event.context._nitro.routeRules = getRouteRulesForPath(
      withoutBase(event.path.split("?")[0], useRuntimeConfig$1().app.baseURL)
    );
  }
  return event.context._nitro.routeRules;
}
function getRouteRulesForPath(path) {
  return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());
}

function joinHeaders(value) {
  return Array.isArray(value) ? value.join(", ") : String(value);
}
function normalizeFetchResponse(response) {
  if (!response.headers.has("set-cookie")) {
    return response;
  }
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: normalizeCookieHeaders(response.headers)
  });
}
function normalizeCookieHeader(header = "") {
  return splitCookiesString(joinHeaders(header));
}
function normalizeCookieHeaders(headers) {
  const outgoingHeaders = new Headers();
  for (const [name, header] of headers) {
    if (name === "set-cookie") {
      for (const cookie of normalizeCookieHeader(header)) {
        outgoingHeaders.append("set-cookie", cookie);
      }
    } else {
      outgoingHeaders.set(name, joinHeaders(header));
    }
  }
  return outgoingHeaders;
}

function isJsonRequest(event) {
  if (hasReqHeader(event, "accept", "text/html")) {
    return false;
  }
  return hasReqHeader(event, "accept", "application/json") || hasReqHeader(event, "user-agent", "curl/") || hasReqHeader(event, "user-agent", "httpie/") || hasReqHeader(event, "sec-fetch-mode", "cors") || event.path.startsWith("/api/") || event.path.endsWith(".json");
}
function hasReqHeader(event, name, includes) {
  const value = getRequestHeader(event, name);
  return value && typeof value === "string" && value.toLowerCase().includes(includes);
}

const errorHandler$0 = (async function errorhandler(error, event, { defaultHandler }) {
  if (event.handled || isJsonRequest(event)) {
    return;
  }
  const defaultRes = await defaultHandler(error, event, { json: true });
  const statusCode = error.statusCode || 500;
  if (statusCode === 404 && defaultRes.status === 302) {
    setResponseHeaders(event, defaultRes.headers);
    setResponseStatus(event, defaultRes.status, defaultRes.statusText);
    return send(event, JSON.stringify(defaultRes.body, null, 2));
  }
  const errorObject = defaultRes.body;
  const url = new URL(errorObject.url);
  errorObject.url = withoutBase(url.pathname, useRuntimeConfig$1(event).app.baseURL) + url.search + url.hash;
  errorObject.message ||= "Server Error";
  errorObject.data ||= error.data;
  errorObject.statusMessage ||= error.statusMessage;
  delete defaultRes.headers["content-type"];
  delete defaultRes.headers["content-security-policy"];
  setResponseHeaders(event, defaultRes.headers);
  const reqHeaders = getRequestHeaders(event);
  const isRenderingError = event.path.startsWith("/__nuxt_error") || !!reqHeaders["x-nuxt-error"];
  const res = isRenderingError ? null : await useNitroApp().localFetch(
    withQuery(joinURL(useRuntimeConfig$1(event).app.baseURL, "/__nuxt_error"), errorObject),
    {
      headers: { ...reqHeaders, "x-nuxt-error": "true" },
      redirect: "manual"
    }
  ).catch(() => null);
  if (event.handled) {
    return;
  }
  if (!res) {
    const { template } = await Promise.resolve().then(function () { return error500$1; });
    setResponseHeader(event, "Content-Type", "text/html;charset=UTF-8");
    return send(event, template(errorObject));
  }
  const html = await res.text();
  for (const [header, value] of res.headers.entries()) {
    if (header === "set-cookie") {
      appendResponseHeader(event, header, value);
      continue;
    }
    setResponseHeader(event, header, value);
  }
  setResponseStatus(event, res.status && res.status !== 200 ? res.status : defaultRes.status, res.statusText || defaultRes.statusText);
  return send(event, html);
});

function defineNitroErrorHandler(handler) {
  return handler;
}

const errorHandler$1 = defineNitroErrorHandler(
  function defaultNitroErrorHandler(error, event) {
    const res = defaultHandler(error, event);
    setResponseHeaders(event, res.headers);
    setResponseStatus(event, res.status, res.statusText);
    return send(event, JSON.stringify(res.body, null, 2));
  }
);
function defaultHandler(error, event, opts) {
  const isSensitive = error.unhandled || error.fatal;
  const statusCode = error.statusCode || 500;
  const statusMessage = error.statusMessage || "Server Error";
  const url = getRequestURL(event, { xForwardedHost: true, xForwardedProto: true });
  if (statusCode === 404) {
    const baseURL = "/";
    if (/^\/[^/]/.test(baseURL) && !url.pathname.startsWith(baseURL)) {
      const redirectTo = `${baseURL}${url.pathname.slice(1)}${url.search}`;
      return {
        status: 302,
        statusText: "Found",
        headers: { location: redirectTo },
        body: `Redirecting...`
      };
    }
  }
  if (isSensitive && !opts?.silent) {
    const tags = [error.unhandled && "[unhandled]", error.fatal && "[fatal]"].filter(Boolean).join(" ");
    console.error(`[request error] ${tags} [${event.method}] ${url}
`, error);
  }
  const headers = {
    "content-type": "application/json",
    // Prevent browser from guessing the MIME types of resources.
    "x-content-type-options": "nosniff",
    // Prevent error page from being embedded in an iframe
    "x-frame-options": "DENY",
    // Prevent browsers from sending the Referer header
    "referrer-policy": "no-referrer",
    // Disable the execution of any js
    "content-security-policy": "script-src 'none'; frame-ancestors 'none';"
  };
  setResponseStatus(event, statusCode, statusMessage);
  if (statusCode === 404 || !getResponseHeader(event, "cache-control")) {
    headers["cache-control"] = "no-cache";
  }
  const body = {
    error: true,
    url: url.href,
    statusCode,
    statusMessage,
    message: isSensitive ? "Server Error" : error.message,
    data: isSensitive ? void 0 : error.data
  };
  return {
    status: statusCode,
    statusText: statusMessage,
    headers,
    body
  };
}

const errorHandlers = [errorHandler$0, errorHandler$1];

async function errorHandler(error, event) {
  for (const handler of errorHandlers) {
    try {
      await handler(error, event, { defaultHandler });
      if (event.handled) {
        return; // Response handled
      }
    } catch(error) {
      // Handler itself thrown, log and continue
      console.error(error);
    }
  }
  // H3 will handle fallback
}

const plugins$1 = [
  
];

const _SxA8c9 = defineEventHandler(() => {});

const _lazy_RvNijS = () => Promise.resolve().then(function () { return info_get$1; });
const _lazy_fB22kp = () => Promise.resolve().then(function () { return login_post$1; });
const _lazy_9eIvpL = () => Promise.resolve().then(function () { return index_get$b; });
const _lazy_nY5Wfk = () => Promise.resolve().then(function () { return index_post$9; });
const _lazy_NtyuzS = () => Promise.resolve().then(function () { return consultaCnpj_post$1; });
const _lazy_7xDu_D = () => Promise.resolve().then(function () { return aniversariantes_get$1; });
const _lazy_8oPbxc = () => Promise.resolve().then(function () { return stats_get$1; });
const _lazy_L3UuSM = () => Promise.resolve().then(function () { return variaveis_get$1; });
const _lazy_1DtCMI = () => Promise.resolve().then(function () { return criar_post$1; });
const _lazy_tCJ0A4 = () => Promise.resolve().then(function () { return index_get$9; });
const _lazy_KMloXw = () => Promise.resolve().then(function () { return _id__delete$5; });
const _lazy_33ZwuU = () => Promise.resolve().then(function () { return _id__get$5; });
const _lazy_5w3hsm = () => Promise.resolve().then(function () { return index_get$7; });
const _lazy_B_99Tp = () => Promise.resolve().then(function () { return index_post$7; });
const _lazy_jj_cE5 = () => Promise.resolve().then(function () { return schema_get$1; });
const _lazy_kJUAG4 = () => Promise.resolve().then(function () { return _id__get$3; });
const _lazy_t2mixh = () => Promise.resolve().then(function () { return _id__patch$3; });
const _lazy_2jvpyD = () => Promise.resolve().then(function () { return enviarAcesso_post$1; });
const _lazy_YJnlrW = () => Promise.resolve().then(function () { return index_get$5; });
const _lazy_BNbVdO = () => Promise.resolve().then(function () { return index_post$5; });
const _lazy_85ihcD = () => Promise.resolve().then(function () { return meusDados_get$1; });
const _lazy_3iq7En = () => Promise.resolve().then(function () { return meusDados_patch$1; });
const _lazy_fhY_Rl = () => Promise.resolve().then(function () { return health_get$1; });
const _lazy_Ckfv8x = () => Promise.resolve().then(function () { return _id__delete$3; });
const _lazy_CjcncK = () => Promise.resolve().then(function () { return _id__patch$1; });
const _lazy_XbT4vE = () => Promise.resolve().then(function () { return enviarEmail_post$1; });
const _lazy_UtNzfp = () => Promise.resolve().then(function () { return html_get$1; });
const _lazy_kdRlfP = () => Promise.resolve().then(function () { return pdf_get$1; });
const _lazy_hj9TvC = () => Promise.resolve().then(function () { return gerar_post$1; });
const _lazy_3CRJ8g = () => Promise.resolve().then(function () { return index_get$3; });
const _lazy_eg4t6r = () => Promise.resolve().then(function () { return _funcionarioId__get$1; });
const _lazy_pIK1nE = () => Promise.resolve().then(function () { return _id__delete$1; });
const _lazy_zaitAP = () => Promise.resolve().then(function () { return index_post$3; });
const _lazy_p3EyA5 = () => Promise.resolve().then(function () { return meusHolerites_get$1; });
const _lazy_UGXuYg = () => Promise.resolve().then(function () { return _id__get$1; });
const _lazy_TzKUtQ = () => Promise.resolve().then(function () { return index_get$1; });
const _lazy_77dzEn = () => Promise.resolve().then(function () { return index_post$1; });
const _lazy_wsWlnR = () => Promise.resolve().then(function () { return testSupabase_get$1; });
const _lazy_r5EtnN = () => Promise.resolve().then(function () { return renderer$1; });

const handlers = [
  { route: '/api/admin/info', handler: _lazy_RvNijS, lazy: true, middleware: false, method: "get" },
  { route: '/api/auth/login', handler: _lazy_fB22kp, lazy: true, middleware: false, method: "post" },
  { route: '/api/cargos', handler: _lazy_9eIvpL, lazy: true, middleware: false, method: "get" },
  { route: '/api/cargos', handler: _lazy_nY5Wfk, lazy: true, middleware: false, method: "post" },
  { route: '/api/consulta-cnpj', handler: _lazy_NtyuzS, lazy: true, middleware: false, method: "post" },
  { route: '/api/dashboard/aniversariantes', handler: _lazy_7xDu_D, lazy: true, middleware: false, method: "get" },
  { route: '/api/dashboard/stats', handler: _lazy_8oPbxc, lazy: true, middleware: false, method: "get" },
  { route: '/api/debug/variaveis', handler: _lazy_L3UuSM, lazy: true, middleware: false, method: "get" },
  { route: '/api/departamentos/criar', handler: _lazy_1DtCMI, lazy: true, middleware: false, method: "post" },
  { route: '/api/departamentos', handler: _lazy_tCJ0A4, lazy: true, middleware: false, method: "get" },
  { route: '/api/empresas/:id', handler: _lazy_KMloXw, lazy: true, middleware: false, method: "delete" },
  { route: '/api/empresas/:id', handler: _lazy_33ZwuU, lazy: true, middleware: false, method: "get" },
  { route: '/api/empresas', handler: _lazy_5w3hsm, lazy: true, middleware: false, method: "get" },
  { route: '/api/empresas', handler: _lazy_B_99Tp, lazy: true, middleware: false, method: "post" },
  { route: '/api/empresas/schema', handler: _lazy_jj_cE5, lazy: true, middleware: false, method: "get" },
  { route: '/api/funcionarios/:id', handler: _lazy_kJUAG4, lazy: true, middleware: false, method: "get" },
  { route: '/api/funcionarios/:id', handler: _lazy_t2mixh, lazy: true, middleware: false, method: "patch" },
  { route: '/api/funcionarios/enviar-acesso', handler: _lazy_2jvpyD, lazy: true, middleware: false, method: "post" },
  { route: '/api/funcionarios', handler: _lazy_YJnlrW, lazy: true, middleware: false, method: "get" },
  { route: '/api/funcionarios', handler: _lazy_BNbVdO, lazy: true, middleware: false, method: "post" },
  { route: '/api/funcionarios/meus-dados', handler: _lazy_85ihcD, lazy: true, middleware: false, method: "get" },
  { route: '/api/funcionarios/meus-dados', handler: _lazy_3iq7En, lazy: true, middleware: false, method: "patch" },
  { route: '/api/health', handler: _lazy_fhY_Rl, lazy: true, middleware: false, method: "get" },
  { route: '/api/holerites/:id', handler: _lazy_Ckfv8x, lazy: true, middleware: false, method: "delete" },
  { route: '/api/holerites/:id', handler: _lazy_CjcncK, lazy: true, middleware: false, method: "patch" },
  { route: '/api/holerites/:id/enviar-email', handler: _lazy_XbT4vE, lazy: true, middleware: false, method: "post" },
  { route: '/api/holerites/:id/html', handler: _lazy_UtNzfp, lazy: true, middleware: false, method: "get" },
  { route: '/api/holerites/:id/pdf', handler: _lazy_kdRlfP, lazy: true, middleware: false, method: "get" },
  { route: '/api/holerites/gerar', handler: _lazy_hj9TvC, lazy: true, middleware: false, method: "post" },
  { route: '/api/holerites', handler: _lazy_3CRJ8g, lazy: true, middleware: false, method: "get" },
  { route: '/api/holerites/itens-personalizados/:funcionarioId', handler: _lazy_eg4t6r, lazy: true, middleware: false, method: "get" },
  { route: '/api/holerites/itens-personalizados/:id', handler: _lazy_pIK1nE, lazy: true, middleware: false, method: "delete" },
  { route: '/api/holerites/itens-personalizados', handler: _lazy_zaitAP, lazy: true, middleware: false, method: "post" },
  { route: '/api/holerites/meus-holerites', handler: _lazy_p3EyA5, lazy: true, middleware: false, method: "get" },
  { route: '/api/jornadas/:id', handler: _lazy_UGXuYg, lazy: true, middleware: false, method: "get" },
  { route: '/api/jornadas', handler: _lazy_TzKUtQ, lazy: true, middleware: false, method: "get" },
  { route: '/api/jornadas', handler: _lazy_77dzEn, lazy: true, middleware: false, method: "post" },
  { route: '/api/test-supabase', handler: _lazy_wsWlnR, lazy: true, middleware: false, method: "get" },
  { route: '/__nuxt_error', handler: _lazy_r5EtnN, lazy: true, middleware: false, method: undefined },
  { route: '/__nuxt_island/**', handler: _SxA8c9, lazy: false, middleware: false, method: undefined },
  { route: '/**', handler: _lazy_r5EtnN, lazy: true, middleware: false, method: undefined }
];

function createNitroApp() {
  const config = useRuntimeConfig$1();
  const hooks = createHooks();
  const captureError = (error, context = {}) => {
    const promise = hooks.callHookParallel("error", error, context).catch((error_) => {
      console.error("Error while capturing another error", error_);
    });
    if (context.event && isEvent(context.event)) {
      const errors = context.event.context.nitro?.errors;
      if (errors) {
        errors.push({ error, context });
      }
      if (context.event.waitUntil) {
        context.event.waitUntil(promise);
      }
    }
  };
  const h3App = createApp({
    debug: destr(false),
    onError: (error, event) => {
      captureError(error, { event, tags: ["request"] });
      return errorHandler(error, event);
    },
    onRequest: async (event) => {
      event.context.nitro = event.context.nitro || { errors: [] };
      const fetchContext = event.node.req?.__unenv__;
      if (fetchContext?._platform) {
        event.context = {
          _platform: fetchContext?._platform,
          // #3335
          ...fetchContext._platform,
          ...event.context
        };
      }
      if (!event.context.waitUntil && fetchContext?.waitUntil) {
        event.context.waitUntil = fetchContext.waitUntil;
      }
      event.fetch = (req, init) => fetchWithEvent(event, req, init, { fetch: localFetch });
      event.$fetch = (req, init) => fetchWithEvent(event, req, init, {
        fetch: $fetch
      });
      event.waitUntil = (promise) => {
        if (!event.context.nitro._waitUntilPromises) {
          event.context.nitro._waitUntilPromises = [];
        }
        event.context.nitro._waitUntilPromises.push(promise);
        if (event.context.waitUntil) {
          event.context.waitUntil(promise);
        }
      };
      event.captureError = (error, context) => {
        captureError(error, { event, ...context });
      };
      await nitroApp$1.hooks.callHook("request", event).catch((error) => {
        captureError(error, { event, tags: ["request"] });
      });
    },
    onBeforeResponse: async (event, response) => {
      await nitroApp$1.hooks.callHook("beforeResponse", event, response).catch((error) => {
        captureError(error, { event, tags: ["request", "response"] });
      });
    },
    onAfterResponse: async (event, response) => {
      await nitroApp$1.hooks.callHook("afterResponse", event, response).catch((error) => {
        captureError(error, { event, tags: ["request", "response"] });
      });
    }
  });
  const router = createRouter$1({
    preemptive: true
  });
  const nodeHandler = toNodeListener(h3App);
  const localCall = (aRequest) => b(
    nodeHandler,
    aRequest
  );
  const localFetch = (input, init) => {
    if (!input.toString().startsWith("/")) {
      return globalThis.fetch(input, init);
    }
    return C(
      nodeHandler,
      input,
      init
    ).then((response) => normalizeFetchResponse(response));
  };
  const $fetch = createFetch({
    fetch: localFetch,
    Headers: Headers$1,
    defaults: { baseURL: config.app.baseURL }
  });
  globalThis.$fetch = $fetch;
  h3App.use(createRouteRulesHandler({ localFetch }));
  for (const h of handlers) {
    let handler = h.lazy ? lazyEventHandler(h.handler) : h.handler;
    if (h.middleware || !h.route) {
      const middlewareBase = (config.app.baseURL + (h.route || "/")).replace(
        /\/+/g,
        "/"
      );
      h3App.use(middlewareBase, handler);
    } else {
      const routeRules = getRouteRulesForPath(
        h.route.replace(/:\w+|\*\*/g, "_")
      );
      if (routeRules.cache) {
        handler = cachedEventHandler(handler, {
          group: "nitro/routes",
          ...routeRules.cache
        });
      }
      router.use(h.route, handler, h.method);
    }
  }
  h3App.use(config.app.baseURL, router.handler);
  const app = {
    hooks,
    h3App,
    router,
    localCall,
    localFetch,
    captureError
  };
  return app;
}
function runNitroPlugins(nitroApp2) {
  for (const plugin of plugins$1) {
    try {
      plugin(nitroApp2);
    } catch (error) {
      nitroApp2.captureError(error, { tags: ["plugin"] });
      throw error;
    }
  }
}
const nitroApp$1 = createNitroApp();
function useNitroApp() {
  return nitroApp$1;
}
runNitroPlugins(nitroApp$1);

function defineRenderHandler(render) {
  const runtimeConfig = useRuntimeConfig$1();
  return eventHandler(async (event) => {
    const nitroApp = useNitroApp();
    const ctx = { event, render, response: void 0 };
    await nitroApp.hooks.callHook("render:before", ctx);
    if (!ctx.response) {
      if (event.path === `${runtimeConfig.app.baseURL}favicon.ico`) {
        setResponseHeader(event, "Content-Type", "image/x-icon");
        return send(
          event,
          "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
        );
      }
      ctx.response = await ctx.render(event);
      if (!ctx.response) {
        const _currentStatus = getResponseStatus(event);
        setResponseStatus(event, _currentStatus === 200 ? 500 : _currentStatus);
        return send(
          event,
          "No response returned from render handler: " + event.path
        );
      }
    }
    await nitroApp.hooks.callHook("render:response", ctx.response, ctx);
    if (ctx.response.headers) {
      setResponseHeaders(event, ctx.response.headers);
    }
    if (ctx.response.statusCode || ctx.response.statusMessage) {
      setResponseStatus(
        event,
        ctx.response.statusCode,
        ctx.response.statusMessage
      );
    }
    return ctx.response.body;
  });
}

const ISR_URL_PARAM = "__isr_route";

const nitroApp = useNitroApp();
const handler = toNodeListener(nitroApp.h3App);
const listener = function(req, res) {
  const isrRoute = req.headers["x-now-route-matches"];
  if (isrRoute) {
    const { [ISR_URL_PARAM]: url } = parseQuery$1(isrRoute);
    if (url && typeof url === "string") {
      const routeRules = getRouteRulesForPath(url);
      if (routeRules.isr) {
        req.url = url;
      }
    }
  } else {
    const queryIndex = req.url.indexOf("?");
    const urlQueryIndex = queryIndex === -1 ? -1 : req.url.indexOf(`${ISR_URL_PARAM}=`, queryIndex);
    if (urlQueryIndex !== -1) {
      const { [ISR_URL_PARAM]: url, ...params } = parseQuery$1(
        req.url.slice(queryIndex)
      );
      if (url && typeof url === "string") {
        const routeRules = getRouteRulesForPath(url);
        if (routeRules.isr) {
          req.url = withQuery(url, params);
        }
      }
    }
  }
  return handler(req, res);
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : "undefined" !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

var shared_cjs_prod = {};

/**
* @vue/shared v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

Object.defineProperty(shared_cjs_prod, '__esModule', { value: true });

// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return ((str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  });
};
const camelizeRE = /-\w/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}

const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "CACHED": -1,
  "-1": "CACHED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `CACHED`,
  [-2]: `BAIL`
};

const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};

const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  if (!styles) return "";
  if (isString(styles)) return styles;
  let ret = "";
  for (const key in styles) {
    const value = styles[key];
    if (isString(value) || typeof value === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$1(a);
  bValidType = isArray$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray$1(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

function normalizeCssVarValue(value) {
  if (value == null) {
    return "initial";
  }
  if (typeof value === "string") {
    return value === "" ? " " : value;
  }
  return String(value);
}

shared_cjs_prod.EMPTY_ARR = EMPTY_ARR;
shared_cjs_prod.EMPTY_OBJ = EMPTY_OBJ;
shared_cjs_prod.NO = NO;
shared_cjs_prod.NOOP = NOOP;
shared_cjs_prod.PatchFlagNames = PatchFlagNames;
shared_cjs_prod.PatchFlags = PatchFlags;
shared_cjs_prod.ShapeFlags = ShapeFlags;
shared_cjs_prod.SlotFlags = SlotFlags;
shared_cjs_prod.camelize = camelize;
shared_cjs_prod.capitalize = capitalize;
shared_cjs_prod.cssVarNameEscapeSymbolsRE = cssVarNameEscapeSymbolsRE;
shared_cjs_prod.def = def;
var escapeHtml_1 = shared_cjs_prod.escapeHtml = escapeHtml;
shared_cjs_prod.escapeHtmlComment = escapeHtmlComment;
shared_cjs_prod.extend = extend;
shared_cjs_prod.genCacheKey = genCacheKey;
shared_cjs_prod.genPropsAccessExp = genPropsAccessExp;
shared_cjs_prod.generateCodeFrame = generateCodeFrame;
shared_cjs_prod.getEscapedCssVarName = getEscapedCssVarName;
shared_cjs_prod.getGlobalThis = getGlobalThis;
shared_cjs_prod.hasChanged = hasChanged;
shared_cjs_prod.hasOwn = hasOwn;
shared_cjs_prod.hyphenate = hyphenate;
shared_cjs_prod.includeBooleanAttr = includeBooleanAttr;
shared_cjs_prod.invokeArrayFns = invokeArrayFns;
shared_cjs_prod.isArray = isArray$1;
shared_cjs_prod.isBooleanAttr = isBooleanAttr;
shared_cjs_prod.isBuiltInDirective = isBuiltInDirective;
shared_cjs_prod.isDate = isDate;
shared_cjs_prod.isFunction = isFunction;
shared_cjs_prod.isGloballyAllowed = isGloballyAllowed;
shared_cjs_prod.isGloballyWhitelisted = isGloballyWhitelisted;
shared_cjs_prod.isHTMLTag = isHTMLTag;
shared_cjs_prod.isIntegerKey = isIntegerKey;
shared_cjs_prod.isKnownHtmlAttr = isKnownHtmlAttr;
shared_cjs_prod.isKnownMathMLAttr = isKnownMathMLAttr;
shared_cjs_prod.isKnownSvgAttr = isKnownSvgAttr;
shared_cjs_prod.isMap = isMap;
shared_cjs_prod.isMathMLTag = isMathMLTag;
shared_cjs_prod.isModelListener = isModelListener;
shared_cjs_prod.isObject = isObject;
shared_cjs_prod.isOn = isOn;
var isPlainObject_1 = shared_cjs_prod.isPlainObject = isPlainObject;
shared_cjs_prod.isPromise = isPromise;
shared_cjs_prod.isRegExp = isRegExp;
shared_cjs_prod.isRenderableAttrValue = isRenderableAttrValue;
shared_cjs_prod.isReservedProp = isReservedProp;
shared_cjs_prod.isSSRSafeAttrName = isSSRSafeAttrName;
shared_cjs_prod.isSVGTag = isSVGTag;
shared_cjs_prod.isSet = isSet;
shared_cjs_prod.isSpecialBooleanAttr = isSpecialBooleanAttr;
shared_cjs_prod.isString = isString;
shared_cjs_prod.isSymbol = isSymbol;
shared_cjs_prod.isVoidTag = isVoidTag;
shared_cjs_prod.looseEqual = looseEqual;
shared_cjs_prod.looseIndexOf = looseIndexOf;
shared_cjs_prod.looseToNumber = looseToNumber;
shared_cjs_prod.makeMap = makeMap;
shared_cjs_prod.normalizeClass = normalizeClass;
shared_cjs_prod.normalizeCssVarValue = normalizeCssVarValue;
shared_cjs_prod.normalizeProps = normalizeProps;
shared_cjs_prod.normalizeStyle = normalizeStyle;
shared_cjs_prod.objectToString = objectToString;
shared_cjs_prod.parseStringStyle = parseStringStyle;
shared_cjs_prod.propsToAttrMap = propsToAttrMap;
shared_cjs_prod.remove = remove;
shared_cjs_prod.slotFlagsText = slotFlagsText;
shared_cjs_prod.stringifyStyle = stringifyStyle;
shared_cjs_prod.toDisplayString = toDisplayString;
shared_cjs_prod.toHandlerKey = toHandlerKey;
shared_cjs_prod.toNumber = toNumber;
shared_cjs_prod.toRawType = toRawType;
shared_cjs_prod.toTypeString = toTypeString;

const _messages = { "appName": "Nuxt", "statusCode": 500, "statusMessage": "Internal server error", "description": "This page is temporarily unavailable.", "refresh": "Refresh this page" };
const template$1 = (messages) => {
  messages = { ..._messages, ...messages };
  return '<!DOCTYPE html><html lang="en"><head><title>' + escapeHtml_1(messages.statusCode) + " - " + escapeHtml_1(messages.statusMessage) + " | " + escapeHtml_1(messages.appName) + `</title><meta charset="utf-8"><meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0" name="viewport"><script>!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();<\/script><style>*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1,h2{font-size:inherit;font-weight:inherit}h1,h2,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }.grid{display:grid}.mb-2{margin-bottom:.5rem}.mb-4{margin-bottom:1rem}.max-w-520px{max-width:520px}.min-h-screen{min-height:100vh}.place-content-center{place-content:center}.overflow-hidden{overflow:hidden}.bg-white{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.px-2{padding-left:.5rem;padding-right:.5rem}.text-center{text-align:center}.text-\\[80px\\]{font-size:80px}.text-2xl{font-size:1.5rem;line-height:2rem}.text-\\[\\#020420\\]{--un-text-opacity:1;color:rgb(2 4 32/var(--un-text-opacity))}.text-\\[\\#64748B\\]{--un-text-opacity:1;color:rgb(100 116 139/var(--un-text-opacity))}.font-semibold{font-weight:600}.leading-none{line-height:1}.tracking-wide{letter-spacing:.025em}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.tabular-nums{--un-numeric-spacing:tabular-nums;font-variant-numeric:var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media(prefers-color-scheme:dark){.dark\\:bg-\\[\\#020420\\]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:text-white{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media(min-width:640px){.sm\\:text-\\[110px\\]{font-size:110px}.sm\\:text-3xl{font-size:1.875rem;line-height:2.25rem}}</style></head><body class="antialiased bg-white dark:bg-[#020420] dark:text-white font-sans grid min-h-screen overflow-hidden place-content-center text-[#020420] tracking-wide"><div class="max-w-520px text-center"><h1 class="font-semibold leading-none mb-4 sm:text-[110px] tabular-nums text-[80px]">` + escapeHtml_1(messages.statusCode) + '</h1><h2 class="font-semibold mb-2 sm:text-3xl text-2xl">' + escapeHtml_1(messages.statusMessage) + '</h2><p class="mb-4 px-2 text-[#64748B] text-md">' + escapeHtml_1(messages.description) + "</p></div></body></html>";
};

const error500$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  template: template$1
}, Symbol.toStringTag, { value: 'Module' }));

const info_get = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const supabaseKey = config.public.supabaseKey;
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?tipo_acesso=eq.admin&select=id,nome_completo,email_login,cargo_id,departamento_id&limit=1`,
      {
        headers: {
          "apikey": supabaseKey,
          "Authorization": `Bearer ${supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!response.ok) {
      throw new Error("Erro ao buscar admin");
    }
    const admins = await response.json();
    if (admins && admins.length > 0) {
      return {
        success: true,
        data: {
          id: admins[0].id,
          nome: admins[0].nome_completo,
          email: admins[0].email_login,
          cargo_id: admins[0].cargo_id,
          departamento_id: admins[0].departamento_id
        }
      };
    }
    return {
      success: true,
      data: {
        id: null,
        nome: "Silvana Qualitec",
        email: "silvana@qualitec.com.br"
      }
    };
  } catch (error) {
    console.error("Erro ao buscar admin:", error);
    return {
      success: true,
      data: {
        id: null,
        nome: "Silvana Qualitec",
        email: "silvana@qualitec.com.br"
      }
    };
  }
});

const info_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: info_get
}, Symbol.toStringTag, { value: 'Module' }));

const login_post = defineEventHandler(async (event) => {
  const { email, senha } = await readBody(event);
  if (!email || !senha) {
    throw createError$2({
      statusCode: 400,
      message: "Email e senha s\xE3o obrigat\xF3rios"
    });
  }
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  console.log("\u{1F527} Config check:");
  console.log("  - supabaseUrl:", supabaseUrl ? supabaseUrl.substring(0, 30) + "..." : "UNDEFINED");
  console.log("  - serviceRoleKey LENGTH:", serviceRoleKey ? serviceRoleKey.length : 0);
  console.log("  - serviceRoleKey FULL:", serviceRoleKey);
  console.log("  - supabaseKey LENGTH:", config.public.supabaseKey ? config.public.supabaseKey.length : 0);
  try {
    console.log("\u{1F510} Tentando login:", { email, senha: "***" });
    console.log("\u{1F310} Supabase URL:", supabaseUrl);
    const url = `${supabaseUrl}/rest/v1/funcionarios?email_login=eq.${encodeURIComponent(email)}&senha=eq.${encodeURIComponent(senha)}&status=eq.ativo&select=id,nome_completo,email_login,tipo_acesso,status,cargo_id,departamento_id`;
    console.log("\u{1F4E1} URL da requisi\xE7\xE3o:", url);
    const response = await fetch(url, {
      headers: {
        "apikey": serviceRoleKey,
        "Authorization": `Bearer ${serviceRoleKey}`,
        "Content-Type": "application/json",
        "Prefer": "return=representation"
      }
    });
    console.log("\u{1F4CA} Status da resposta:", response.status);
    const funcionarios = await response.json();
    console.log("\u{1F465} Funcion\xE1rios encontrados:", funcionarios.length);
    if (!response.ok) {
      console.error("\u274C Erro na resposta do Supabase:", funcionarios);
      throw createError$2({
        statusCode: 401,
        message: "Email ou senha incorretos"
      });
    }
    if (!funcionarios || funcionarios.length === 0) {
      console.log("\u26A0\uFE0F Nenhum funcion\xE1rio encontrado com essas credenciais");
      throw createError$2({
        statusCode: 401,
        message: "Email ou senha incorretos"
      });
    }
    const funcionario = funcionarios[0];
    console.log("\u2705 Login bem-sucedido:", funcionario.nome_completo);
    return {
      success: true,
      user: {
        id: funcionario.id,
        nome: funcionario.nome_completo,
        email: funcionario.email_login,
        tipo: funcionario.tipo_acesso,
        cargo: funcionario.cargo_id,
        departamento: funcionario.departamento_id
      }
    };
  } catch (error) {
    console.error("\u{1F4A5} Erro no login:", error);
    throw createError$2({
      statusCode: 401,
      message: "Email ou senha incorretos"
    });
  }
});

const login_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: login_post
}, Symbol.toStringTag, { value: 'Module' }));

const index_get$a = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/cargos?select=*&order=nome.asc`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!response.ok) {
      throw new Error("Erro ao buscar cargos");
    }
    const cargos = await response.json();
    return { success: true, data: cargos };
  } catch (error) {
    console.error("Erro ao buscar cargos:", error);
    throw createError$2({
      statusCode: 500,
      message: "Erro ao buscar cargos"
    });
  }
});

const index_get$b = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get$a
}, Symbol.toStringTag, { value: 'Module' }));

const index_post$8 = defineEventHandler(async (event) => {
  const body = await readBody(event);
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  console.log("\u{1F4BC} Salvando cargo:", body);
  try {
    let response;
    let url;
    if (body.id) {
      url = `${supabaseUrl}/rest/v1/cargos?id=eq.${body.id}`;
      console.log("\u{1F504} ATUALIZANDO cargo ID:", body.id);
      const { id, ...dadosSemId } = body;
      response = await fetch(url, {
        method: "PATCH",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify(dadosSemId)
      });
    } else {
      url = `${supabaseUrl}/rest/v1/cargos`;
      console.log("\u2795 CRIANDO novo cargo");
      response = await fetch(url, {
        method: "POST",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify(body)
      });
    }
    console.log("\u{1F4CA} Status da resposta:", response.status);
    const responseText = await response.text();
    console.log("\u{1F4E6} Resposta do Supabase:", responseText);
    if (!response.ok) {
      console.error("\u274C Erro HTTP:", response.status, responseText);
      throw new Error(`Erro ao salvar cargo: ${response.status} - ${responseText}`);
    }
    const cargo = responseText ? JSON.parse(responseText) : null;
    console.log("\u2705 Cargo salvo com sucesso!");
    return {
      success: true,
      message: body.id ? "Cargo atualizado com sucesso!" : "Cargo criado com sucesso!",
      data: Array.isArray(cargo) ? cargo[0] : cargo
    };
  } catch (error) {
    console.error("\u{1F4A5} Erro ao salvar cargo:", error.message);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao salvar cargo"
    });
  }
});

const index_post$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_post$8
}, Symbol.toStringTag, { value: 'Module' }));

const consultaCnpj_post = defineEventHandler(async (event) => {
  var _a, _b;
  console.log("\u{1F680} API consulta-cnpj INICIADA");
  console.log("\u{1F4CD} URL:", getRequestURL(event).pathname);
  console.log("\u{1F527} M\xE9todo:", event.method);
  try {
    console.log("\u{1F4E5} Lendo body da requisi\xE7\xE3o...");
    const body = await readBody(event);
    console.log("\u{1F4E6} Body recebido:", body);
    const { cnpj } = body;
    console.log("\u{1F4CB} CNPJ extra\xEDdo:", cnpj);
    if (!cnpj) {
      console.log("\u274C CNPJ n\xE3o fornecido");
      throw createError$2({
        statusCode: 400,
        statusMessage: "CNPJ \xE9 obrigat\xF3rio"
      });
    }
    const cnpjLimpo = cnpj.replace(/[^\d]/g, "");
    console.log("\u{1F9F9} CNPJ limpo:", cnpjLimpo);
    if (cnpjLimpo.length !== 14) {
      console.log("\u274C CNPJ com tamanho inv\xE1lido:", cnpjLimpo.length);
      throw createError$2({
        statusCode: 400,
        statusMessage: "CNPJ deve ter 14 d\xEDgitos"
      });
    }
    console.log("\u{1F310} Consultando ReceitaWS para CNPJ:", cnpjLimpo);
    const response = await $fetch(`https://www.receitaws.com.br/v1/cnpj/${cnpjLimpo}`, {
      headers: {
        "User-Agent": "Sistema-RH/1.0",
        "Accept": "application/json"
      },
      timeout: 15e3
      // 15 segundos de timeout
    });
    console.log("\u{1F4E6} Resposta da ReceitaWS recebida");
    console.log("\u{1F4CA} Status da resposta:", response.status);
    console.log("\u{1F3E2} Nome da empresa:", response.nome);
    if (response.status === "ERROR") {
      console.log("\u274C ReceitaWS retornou erro:", response.message);
      throw createError$2({
        statusCode: 404,
        statusMessage: response.message || "CNPJ n\xE3o encontrado"
      });
    }
    const dadosEmpresa = {
      // Dados principais
      nome: response.nome || "",
      nome_fantasia: response.fantasia || "",
      cnpj: formatarCNPJ(cnpjLimpo),
      // Endereo detalhado
      logradouro: response.logradouro || "",
      numero: response.numero || "",
      complemento: response.complemento || "",
      bairro: response.bairro || "",
      municipio: response.municipio || "",
      uf: response.uf || "",
      cep: response.cep || "",
      endereco_completo: formatarEndereco(response),
      // Contatos
      telefone: response.telefone || "",
      email: response.email || "",
      // Informaes cadastrais
      situacao_cadastral: response.situacao || "",
      inscricao_estadual: obterInscricaoEstadual(response),
      atividade_principal: ((_b = (_a = response.atividade_principal) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) || "",
      natureza_juridica: response.natureza_juridica || "",
      porte: response.porte || "",
      capital_social: response.capital_social || "",
      data_abertura: response.abertura || "",
      // Dados legados para compatibilidade
      razao_social: response.nome || "",
      endereco: formatarEndereco(response)
    };
    console.log("\u2705 Dados processados com sucesso");
    console.log("\u{1F3E2} Inscri\xE7\xE3o Estadual encontrada:", dadosEmpresa.inscricao_estadual);
    console.log("\u{1F4E4} Retornando dados para o frontend");
    return {
      success: true,
      data: dadosEmpresa
    };
  } catch (error) {
    console.error("\u274C ERRO na API consulta-cnpj:", error);
    console.error("\u274C Tipo do erro:", typeof error);
    console.error("\u274C Nome do erro:", error.name);
    console.error("\u274C Mensagem:", error.message);
    console.error("\u274C Stack:", error.stack);
    if (error.statusCode) {
      console.log("\u{1F504} Repassando erro da API externa");
      throw error;
    }
    if (error.name === "FetchError" || error.code === "NETWORK_ERROR") {
      console.log("\u{1F310} Erro de rede detectado");
      throw createError$2({
        statusCode: 503,
        statusMessage: "Servi\xE7o de consulta CNPJ temporariamente indispon\xEDvel. Tente novamente em alguns minutos."
      });
    }
    console.log("\u{1F527} Erro gen\xE9rico, retornando 500");
    throw createError$2({
      statusCode: 500,
      statusMessage: "Erro interno do servidor ao consultar CNPJ"
    });
  }
});
function obterInscricaoEstadual(dados) {
  var _a;
  const possiveisIE = [
    (_a = dados.extra) == null ? void 0 : _a.inscricao_estadual,
    dados.inscricao_estadual,
    dados.ie,
    dados.inscricao
  ];
  for (const ie of possiveisIE) {
    if (ie && ie.trim() && ie.trim() !== "ISENTO" && ie.trim() !== "N\xC3O INFORMADO") {
      console.log("\u{1F50D} Inscri\xE7\xE3o Estadual encontrada:", ie);
      return ie.trim();
    }
  }
  console.log("\u26A0\uFE0F Inscri\xE7\xE3o Estadual n\xE3o encontrada ou isenta");
  return "";
}
function formatarCNPJ(cnpj) {
  return cnpj.replace(/^(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})$/, "$1.$2.$3/$4-$5");
}
function formatarEndereco(dados) {
  const partes = [];
  if (dados.logradouro) partes.push(dados.logradouro);
  if (dados.numero) partes.push(dados.numero);
  if (dados.complemento) partes.push(dados.complemento);
  if (dados.bairro) partes.push(dados.bairro);
  if (dados.municipio) partes.push(dados.municipio);
  if (dados.uf) partes.push(dados.uf);
  if (dados.cep) partes.push(`CEP: ${dados.cep}`);
  return partes.join(", ");
}

const consultaCnpj_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: consultaCnpj_post
}, Symbol.toStringTag, { value: 'Module' }));

async function fetchWithRetry$1(req, init) {
  const retries = 3;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await fetch(req, init);
    } catch (error) {
      if (init?.signal?.aborted) {
        throw error;
      }
      if (attempt === retries) {
        console.error(`Error fetching request ${req}`, error, init);
        throw error;
      }
      console.warn(`Retrying fetch attempt ${attempt + 1} for request: ${req}`);
      await new Promise((resolve) => setTimeout(resolve, 100 * attempt));
    }
  }
  throw new Error("Unreachable code");
}

function setCookies$1(event, cookies) {
  const response = event.node.res;
  const headersWritable = () => !response.headersSent && !response.writableEnded;
  if (!headersWritable()) {
    return;
  }
  for (const { name, value, options } of cookies) {
    if (!headersWritable()) {
      break;
    }
    setCookie(event, name, value, options);
  }
}

function baseURL() {
  return useRuntimeConfig$1().app.baseURL;
}
function buildAssetsDir() {
  return useRuntimeConfig$1().app.buildAssetsDir;
}
function buildAssetsURL(...path) {
  return joinRelativeURL(publicAssetsURL(), buildAssetsDir(), ...path);
}
function publicAssetsURL(...path) {
  const app = useRuntimeConfig$1().app;
  const publicBase = app.cdnURL || app.baseURL;
  return path.length ? joinRelativeURL(publicBase, ...path) : publicBase;
}

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.GMAIL_EMAIL,
    pass: process.env.GMAIL_APP_PASSWORD
  }
});
async function enviarEmail({ to, subject, html }) {
  try {
    const info = await transporter.sendMail({
      from: `"Sistema RH Qualitec" <${process.env.GMAIL_EMAIL}>`,
      to,
      subject,
      html
    });
    console.log("\u2705 Email enviado:", info.messageId);
    return { success: true, messageId: info.messageId };
  } catch (error) {
    console.error("\u274C Erro ao enviar email:", error);
    throw error;
  }
}
async function enviarEmailCredenciais(dados) {
  const html = templateBoasVindas({
    nome: dados.nome,
    email: dados.login,
    senha: dados.senha,
    empresa: dados.empresa
  });
  return await enviarEmail({
    to: dados.para,
    subject: `\u{1F510} Suas Credenciais de Acesso - ${dados.empresa}`,
    html
  });
}
function templateBoasVindas(dados) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <style>
        body {
          font-family: Arial, sans-serif;
          line-height: 1.6;
          color: #333;
          max-width: 600px;
          margin: 0 auto;
          padding: 20px;
        }
        .header {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          padding: 30px;
          text-align: center;
          border-radius: 10px 10px 0 0;
        }
        .content {
          background: #f9fafb;
          padding: 30px;
          border-radius: 0 0 10px 10px;
        }
        .credentials {
          background: white;
          padding: 20px;
          border-radius: 8px;
          margin: 20px 0;
          border-left: 4px solid #667eea;
        }
        .credential-item {
          margin: 10px 0;
        }
        .credential-label {
          font-weight: bold;
          color: #667eea;
        }
        .credential-value {
          font-size: 18px;
          color: #333;
          font-family: monospace;
          background: #f3f4f6;
          padding: 8px 12px;
          border-radius: 4px;
          display: inline-block;
          margin-top: 5px;
        }
        .button {
          display: inline-block;
          background: #667eea;
          color: white;
          padding: 12px 30px;
          text-decoration: none;
          border-radius: 6px;
          margin: 20px 0;
        }
        .footer {
          text-align: center;
          margin-top: 30px;
          padding-top: 20px;
          border-top: 1px solid #e5e7eb;
          color: #6b7280;
          font-size: 14px;
        }
        .warning {
          background: #fef3c7;
          border-left: 4px solid #f59e0b;
          padding: 15px;
          margin: 20px 0;
          border-radius: 4px;
        }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>\u{1F389} Bem-vindo(a) \xE0 ${dados.empresa}!</h1>
      </div>
      
      <div class="content">
        <p>Ol\xE1 <strong>${dados.nome}</strong>,</p>
        
        <p>\xC9 com grande satisfa\xE7\xE3o que damos as boas-vindas \xE0 nossa equipe! Seu cadastro foi realizado com sucesso no Sistema RH.</p>
        
        <div class="credentials">
          <h3>\u{1F510} Seus Dados de Acesso</h3>
          
          <div class="credential-item">
            <div class="credential-label">\u{1F4E7} Email de Login:</div>
            <div class="credential-value">${dados.email}</div>
          </div>
          
          <div class="credential-item">
            <div class="credential-label">\u{1F511} Senha Tempor\xE1ria:</div>
            <div class="credential-value">${dados.senha}</div>
          </div>
        </div>
        
        <div class="warning">
          <strong>\u26A0\uFE0F Importante:</strong> Por seguran\xE7a, recomendamos que voc\xEA altere sua senha no primeiro acesso.
        </div>
        
        <p>Com o Sistema RH voc\xEA poder\xE1:</p>
        <ul>
          <li>\u2705 Visualizar seus holerites</li>
          <li>\u2705 Acompanhar seus benef\xEDcios</li>
          <li>\u2705 Atualizar seus dados pessoais</li>
          <li>\u2705 Consultar sua jornada de trabalho</li>
        </ul>
        
        <center>
          <a href="https://rhqualitec.vercel.app/login" class="button">
            Acessar Sistema RH
          </a>
        </center>
        
        <p>Se tiver alguma d\xFAvida, entre em contato com o departamento de Recursos Humanos.</p>
        
        <p>Seja bem-vindo(a) e sucesso em sua jornada conosco!</p>
        
        <div class="footer">
          <p><strong>Qualitec Instrumentos de Medi\xE7\xE3o</strong></p>
          <p>Este \xE9 um email autom\xE1tico, por favor n\xE3o responda.</p>
        </div>
      </div>
    </body>
    </html>
  `;
}

function gerarHoleriteHTML(holerite, funcionario, empresa) {
  var _a;
  const periodoInicio = new Date(holerite.periodo_inicio);
  const periodoFim = new Date(holerite.periodo_fim);
  const mesAno = periodoInicio.toLocaleDateString("pt-BR", { month: "long", year: "numeric" });
  const dataAdmissao = funcionario.data_admissao ? new Date(funcionario.data_admissao).toLocaleDateString("pt-BR") : "N\xE3o informada";
  const numeroDependentes = funcionario.numero_dependentes || 0;
  const diaInicio = periodoInicio.getDate();
  const diaFim = periodoFim.getDate();
  let tipoFolha = "Folha Mensal";
  let isAdiantamento = false;
  let corTema = "#2563eb";
  let corFundo = "#eff6ff";
  if (diaInicio === 1 && diaFim <= 15) {
    tipoFolha = "Adiantamento Salarial - 1\xAA Quinzena";
    isAdiantamento = true;
    corTema = "#ea580c";
    corFundo = "#fff7ed";
  } else if (diaInicio === 16) {
    tipoFolha = "Folha Quinzenal - 2\xAA Quinzena";
  }
  const cnpjFormatado = ((_a = empresa.cnpj) == null ? void 0 : _a.replace(/^(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})$/, "$1.$2.$3/$4-$5")) || "";
  const salarioBase = Number(holerite.salario_base) || 0;
  const bonus = Number(holerite.bonus) || 0;
  const horasExtras = Number(holerite.horas_extras) || 0;
  const adicionalNoturno = Number(holerite.adicional_noturno) || 0;
  const adicionalPericulosidade = Number(holerite.adicional_periculosidade) || 0;
  const adicionalInsalubridade = Number(holerite.adicional_insalubridade) || 0;
  const comissoes = Number(holerite.comissoes) || 0;
  const inss = Number(holerite.inss) || 0;
  const irrf = Number(holerite.irrf) || 0;
  const valeTransporte = Number(holerite.vale_transporte) || 0;
  const cestaBasica = Number(holerite.cesta_basica_desconto) || 0;
  const planoSaude = Number(holerite.plano_saude) || 0;
  const planoOdonto = Number(holerite.plano_odontologico) || 0;
  const adiantamento = Number(holerite.adiantamento) || 0;
  const faltas = Number(holerite.faltas) || 0;
  const pensaoAlimenticia = Number(funcionario.pensao_alimenticia) || 0;
  const beneficiosPersonalizados = holerite.beneficios || [];
  const descontosPersonalizados = holerite.descontos_personalizados || [];
  let totalBeneficiosPersonalizados = 0;
  beneficiosPersonalizados.forEach((b) => {
    if (b.valor > 0) {
      totalBeneficiosPersonalizados += Number(b.valor) || 0;
    }
  });
  let totalDescontosPersonalizados = 0;
  descontosPersonalizados.forEach((d) => {
    totalDescontosPersonalizados += Number(d.valor) || 0;
  });
  const totalVencimentos = salarioBase + bonus + horasExtras + adicionalNoturno + adicionalPericulosidade + adicionalInsalubridade + comissoes + totalBeneficiosPersonalizados;
  const totalDescontos = inss + irrf + valeTransporte + cestaBasica + planoSaude + planoOdonto + adiantamento + faltas + pensaoAlimenticia + totalDescontosPersonalizados;
  const valorLiquido = totalVencimentos - totalDescontos;
  const fgts = salarioBase * 0.08;
  const agora = /* @__PURE__ */ new Date();
  const dataHoraAssinatura = agora.toLocaleString("pt-BR", {
    timeZone: "America/Sao_Paulo",
    dateStyle: "short",
    timeStyle: "medium"
  });
  let linhasTabela = "";
  if (salarioBase > 0) {
    linhasTabela += `
        <tr>
          <td>8781</td>
          <td>DIAS NORMAIS</td>
          <td class="text-center">30,00</td>
          <td class="text-right">${salarioBase.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
  }
  if (bonus > 0) {
    linhasTabela += `
        <tr>
          <td>100</td>
          <td>B\xD4NUS</td>
          <td class="text-center"></td>
          <td class="text-right">${bonus.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
  }
  if (horasExtras > 0) {
    linhasTabela += `
        <tr>
          <td>200</td>
          <td>HORAS EXTRAS</td>
          <td class="text-center"></td>
          <td class="text-right">${horasExtras.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
  }
  if (adicionalNoturno > 0) {
    linhasTabela += `
        <tr>
          <td>300</td>
          <td>ADICIONAL NOTURNO</td>
          <td class="text-center"></td>
          <td class="text-right">${adicionalNoturno.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
  }
  if (adicionalPericulosidade > 0) {
    linhasTabela += `
        <tr>
          <td>400</td>
          <td>ADICIONAL DE PERICULOSIDADE</td>
          <td class="text-center"></td>
          <td class="text-right">${adicionalPericulosidade.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
  }
  if (adicionalInsalubridade > 0) {
    linhasTabela += `
        <tr>
          <td>500</td>
          <td>ADICIONAL DE INSALUBRIDADE</td>
          <td class="text-center"></td>
          <td class="text-right">${adicionalInsalubridade.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
  }
  if (comissoes > 0) {
    linhasTabela += `
        <tr>
          <td>600</td>
          <td>COMISS\xD5ES</td>
          <td class="text-center"></td>
          <td class="text-right">${comissoes.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
  }
  if (beneficiosPersonalizados && beneficiosPersonalizados.length > 0) {
    let codigoBeneficio = 700;
    beneficiosPersonalizados.forEach((beneficio) => {
      if (beneficio.valor > 0) {
        linhasTabela += `
        <tr>
          <td>${codigoBeneficio}</td>
          <td>${(beneficio.tipo || beneficio.descricao || "BENEF\xCDCIO").toUpperCase()}</td>
          <td class="text-center"></td>
          <td class="text-right">${Number(beneficio.valor).toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
          <td></td>
        </tr>`;
        codigoBeneficio++;
      }
    });
  }
  if (inss > 0) {
    linhasTabela += `
        <tr>
          <td>998</td>
          <td>I.N.S.S.</td>
          <td class="text-center">${holerite.aliquota_inss || "9,23"}</td>
          <td></td>
          <td class="text-right">${inss.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (irrf > 0) {
    linhasTabela += `
        <tr>
          <td>999</td>
          <td>I.R.R.F.</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${irrf.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (adiantamento > 0) {
    linhasTabela += `
        <tr>
          <td>910</td>
          <td>ADIANTAMENTO SALARIAL</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${adiantamento.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (pensaoAlimenticia > 0) {
    linhasTabela += `
        <tr>
          <td>915</td>
          <td>PENS\xC3O ALIMENT\xCDCIA</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${pensaoAlimenticia.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (valeTransporte > 0) {
    linhasTabela += `
        <tr>
          <td>920</td>
          <td>VALE TRANSPORTE</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${valeTransporte.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (cestaBasica > 0) {
    linhasTabela += `
        <tr>
          <td>930</td>
          <td>CESTA B\xC1SICA</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${cestaBasica.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (planoSaude > 0) {
    linhasTabela += `
        <tr>
          <td>940</td>
          <td>PLANO DE SA\xDADE</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${planoSaude.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (planoOdonto > 0) {
    linhasTabela += `
        <tr>
          <td>950</td>
          <td>PLANO ODONTOL\xD3GICO</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${planoOdonto.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (pensaoAlimenticia > 0) {
    linhasTabela += `
        <tr>
          <td>960</td>
          <td>PENS\xC3O ALIMENT\xCDCIA</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${pensaoAlimenticia.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (faltas > 0) {
    linhasTabela += `
        <tr>
          <td>960</td>
          <td>FALTAS</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${faltas.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
  }
  if (descontosPersonalizados && descontosPersonalizados.length > 0) {
    let codigoDesconto = 970;
    descontosPersonalizados.forEach((desconto) => {
      if (desconto.valor > 0) {
        linhasTabela += `
        <tr>
          <td>${codigoDesconto}</td>
          <td>${(desconto.tipo || desconto.descricao || "DESCONTO").toUpperCase()}</td>
          <td class="text-center"></td>
          <td></td>
          <td class="text-right">${Number(desconto.valor).toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        </tr>`;
        codigoDesconto++;
      }
    });
  }
  return `
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Holerite - ${funcionario.nome_completo}</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Arial, sans-serif;
      font-size: 11px;
      line-height: 1.4;
      color: #333;
      padding: 20px;
      background: ${corFundo};
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .header {
      margin-bottom: 20px;
      padding: 20px 20px 15px 20px;
      border-bottom: 3px solid ${corTema};
      background: linear-gradient(135deg, ${corFundo} 0%, white 100%);
      border-radius: 8px 8px 0 0;
    }
    
    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }
    
    .company-name {
      font-size: 16px;
      font-weight: bold;
      text-transform: uppercase;
      color: ${corTema};
    }
    
    .company-cnpj {
      font-size: 11px;
      margin-top: 3px;
      color: #666;
    }
    
    .header-right {
      text-align: right;
    }
    
    .folha-tipo {
      font-size: 14px;
      font-weight: bold;
      color: ${corTema};
      background: white;
      padding: 8px 16px;
      border-radius: 20px;
      border: 2px solid ${corTema};
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .folha-tipo::before {
      content: "${isAdiantamento ? "\u{1F4B0}" : "\u{1F4CA}"}";
      margin-right: 8px;
    }
    
    .competencia {
      font-size: 11px;
      text-transform: capitalize;
      margin-top: 5px;
      color: #666;
    }
    
    .employee-info {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin: 0 20px 20px 20px;
      padding: 15px;
      background: ${corFundo};
      border: 2px solid ${corTema};
      border-radius: 8px;
    }
    
    .info-item {
      font-size: 10px;
    }
    
    .info-label {
      font-weight: bold;
      display: block;
      margin-bottom: 2px;
    }
    
    .info-value {
      display: block;
    }
    
    table {
      width: calc(100% - 40px);
      margin: 0 20px 15px 20px;
      border-collapse: collapse;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    th {
      background: ${corTema};
      color: white;
      padding: 12px 8px;
      text-align: left;
      font-size: 11px;
      font-weight: bold;
      border: none;
    }
    
    td {
      padding: 8px;
      border: 1px solid #e5e7eb;
      font-size: 10px;
      background: white;
    }
    
    tr:nth-child(even) td {
      background: #f9fafb;
    }
    
    .text-right {
      text-align: right;
    }
    
    .text-center {
      text-align: center;
    }
    
    .totals {
      margin: 10px 20px 20px 20px;
      padding: 20px;
      background: linear-gradient(135deg, ${corFundo} 0%, white 100%);
      border: 3px solid ${corTema};
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .total-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      font-size: 12px;
      border-bottom: 1px solid #e5e7eb;
    }
    
    .total-row:last-child {
      border-bottom: none;
    }
    
    .total-row.liquido {
      font-size: 16px;
      font-weight: bold;
      padding: 15px 0 10px 0;
      border-top: 3px solid ${corTema};
      margin-top: 10px;
      color: ${corTema};
    }
    
    .signature {
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border: 1px solid #ddd;
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .signature-image {
      max-width: 200px;
      height: auto;
    }
    
    .signature-text {
      flex: 1;
    }
    
    .signature-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .bases-calculo {
      margin-top: 20px;
    }
    
    .bases-title {
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 10px;
      padding: 5px;
      background: #f0f0f0;
      border: 1px solid #ccc;
    }
    
    .bases-table {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 1px;
      background: #ccc;
      border: 1px solid #ccc;
    }
    
    .base-item {
      background: white;
      padding: 8px 5px;
      font-size: 9px;
      text-align: center;
    }
    
    .base-label {
      font-weight: bold;
      display: block;
      margin-bottom: 3px;
    }
    
    .base-value {
      display: block;
    }
    
    @media print {
      body {
        padding: 0;
      }
      
      .container {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-top">
        <div>
          <div class="company-name">${empresa.nome_fantasia || empresa.nome}</div>
          <div class="company-cnpj">CNPJ: ${cnpjFormatado}</div>
          <div class="company-cnpj">CC: GERAL</div>
          <div class="company-cnpj">Mensalista</div>
        </div>
        <div class="header-right">
          <div class="folha-tipo">${tipoFolha}</div>
          <div class="competencia">${mesAno}</div>
        </div>
      </div>
    </div>
    
    <div class="employee-info">
      <div class="info-item">
        <span class="info-label">C\xF3digo</span>
        <span class="info-value">${funcionario.id}</span>
      </div>
      <div class="info-item" style="grid-column: span 2;">
        <span class="info-label">Nome do Funcion\xE1rio</span>
        <span class="info-value">${funcionario.nome_completo}</span>
        <span class="info-value">${funcionario.cargo_nome || "CARGO N\xC3O DEFINIDO"}</span>
      </div>
      <div class="info-item">
        <span class="info-label">CBO</span>
        <span class="info-value">354125</span>
      </div>
      <div class="info-item">
        <span class="info-label">Departamento</span>
        <span class="info-value">${funcionario.departamento_nome || "Comercial"}</span>
      </div>
      <div class="info-item">
        <span class="info-label">Mat</span>
        <span class="info-value">${funcionario.id}</span>
      </div>
      <div class="info-item">
        <span class="info-label">Admiss\xE3o:</span>
        <span class="info-value">${dataAdmissao}</span>
      </div>
      ${numeroDependentes > 0 ? `
      <div class="info-item">
        <span class="info-label">Dependentes:</span>
        <span class="info-value">${numeroDependentes}</span>
      </div>` : ""}
    </div>
    
    <table>
      <thead>
        <tr>
          <th style="width: 10%;">C\xF3digo</th>
          <th style="width: 40%;">Descri\xE7\xE3o</th>
          <th style="width: 15%;" class="text-center">Refer\xEAncia</th>
          <th style="width: 17.5%;" class="text-right">Vencimentos</th>
          <th style="width: 17.5%;" class="text-right">Descontos</th>
        </tr>
      </thead>
      <tbody>
        ${linhasTabela}
      </tbody>
    </table>
    
    <div class="totals">
      <div class="total-row">
        <span>Total de Vencimentos</span>
        <span>${totalVencimentos.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
      </div>
      <div class="total-row">
        <span>Total de Descontos</span>
        <span>${totalDescontos.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
      </div>
      <div class="total-row liquido">
        <span>Valor L\xEDquido</span>
        <span>${valorLiquido.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
      </div>
    </div>
    
    <div class="signature">
      <img src="/ass.png" alt="Assinatura Digital" class="signature-image" />
      <div class="signature-text">
        <div class="signature-title">Assinado de forma digital por ${empresa.responsavel_nome || "SILVANA APARECIDA BARDUCHI"}</div>
        <div>CPF: ${empresa.responsavel_cpf || "04487488869"}</div>
        <div>Dados: ${dataHoraAssinatura} -03'00'</div>
      </div>
    </div>
    
    <div class="bases-calculo">
      <div class="bases-title">Bases de C\xE1lculo</div>
      <div class="bases-table">
        <div class="base-item">
          <span class="base-label">Sal\xE1rio Base</span>
          <span class="base-value">${salarioBase.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
        </div>
        <div class="base-item">
          <span class="base-label">Sal. Contr. INSS</span>
          <span class="base-value">${(holerite.base_inss || salarioBase).toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
        </div>
        <div class="base-item">
          <span class="base-label">Base C\xE1lc. FGTS</span>
          <span class="base-value">${salarioBase.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
        </div>
        <div class="base-item">
          <span class="base-label">F.G.T.S do M\xEAs</span>
          <span class="base-value">${fgts.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
        </div>
        <div class="base-item">
          <span class="base-label">Base C\xE1lc. IRRF</span>
          <span class="base-value">${(totalVencimentos - inss).toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span>
        </div>
        <div class="base-item">
          <span class="base-label">Faixa IRRF</span>
          <span class="base-value">${holerite.faixa_irrf || "0,00"}</span>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
  `;
}

const serverSupabaseClient$1 = async (event) => {
  if (!event.context._supabaseClient) {
    const { url, key, cookiePrefix, cookieOptions, clientOptions: { auth = {}, global = {} } } = useRuntimeConfig$1(event).public.supabase;
    event.context._supabaseClient = createServerClient(url, key, {
      auth,
      cookies: {
        getAll: () => parseCookieHeader(getHeader(event, "Cookie") ?? ""),
        setAll: (cookies) => setCookies$1(event, cookies)
      },
      cookieOptions: {
        ...cookieOptions,
        name: cookiePrefix
      },
      global: {
        fetch: fetchWithRetry$1,
        ...global
      }
    });
  }
  return event.context._supabaseClient;
};

//#region src/lib/version.ts
const version$1 = "2.91.0";

//#endregion
//#region src/lib/constants.ts
let JS_ENV = "";
if (typeof Deno !== "undefined") JS_ENV = "deno";
else if (typeof document !== "undefined") JS_ENV = "web";
else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") JS_ENV = "react-native";
else JS_ENV = "node";
const DEFAULT_HEADERS = { "X-Client-Info": `supabase-js-${JS_ENV}/${version$1}` };
const DEFAULT_GLOBAL_OPTIONS = { headers: DEFAULT_HEADERS };
const DEFAULT_DB_OPTIONS = { schema: "public" };
const DEFAULT_AUTH_OPTIONS = {
	autoRefreshToken: true,
	persistSession: true,
	detectSessionInUrl: true,
	flowType: "implicit"
};
const DEFAULT_REALTIME_OPTIONS = {};

//#endregion
//#region \0@oxc-project+runtime@0.101.0/helpers/typeof.js
function _typeof(o) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof(o);
}

//#endregion
//#region \0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js
function toPrimitive(t, r) {
	if ("object" != _typeof(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r);
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}

//#endregion
//#region \0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js
function toPropertyKey(t) {
	var i = toPrimitive(t, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}

//#endregion
//#region \0@oxc-project+runtime@0.101.0/helpers/defineProperty.js
function _defineProperty(e, r, t) {
	return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
		value: t,
		enumerable: true,
		configurable: true,
		writable: true
	}) : e[r] = t, e;
}

//#endregion
//#region \0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js
function ownKeys(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread2(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys(Object(t), true).forEach(function(r$1) {
			_defineProperty(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}

//#endregion
//#region src/lib/fetch.ts
const resolveFetch = (customFetch) => {
	if (customFetch) return (...args) => customFetch(...args);
	return (...args) => fetch(...args);
};
const resolveHeadersConstructor = () => {
	return Headers;
};
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
	const fetch$1 = resolveFetch(customFetch);
	const HeadersConstructor = resolveHeadersConstructor();
	return async (input, init) => {
		var _await$getAccessToken;
		const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;
		let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
		if (!headers.has("apikey")) headers.set("apikey", supabaseKey);
		if (!headers.has("Authorization")) headers.set("Authorization", `Bearer ${accessToken}`);
		return fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, { headers }));
	};
};

//#endregion
//#region src/lib/helpers.ts
function ensureTrailingSlash(url) {
	return url.endsWith("/") ? url : url + "/";
}
function applySettingDefaults(options, defaults) {
	var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;
	const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
	const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;
	const result = {
		db: _objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions),
		auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions),
		realtime: _objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),
		storage: {},
		global: _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, { headers: _objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {}) }),
		accessToken: async () => ""
	};
	if (options.accessToken) result.accessToken = options.accessToken;
	else delete result.accessToken;
	return result;
}
/**
* Validates a Supabase client URL
*
* @param {string} supabaseUrl - The Supabase client URL string.
* @returns {URL} - The validated base URL.
* @throws {Error}
*/
function validateSupabaseUrl(supabaseUrl) {
	const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
	if (!trimmedUrl) throw new Error("supabaseUrl is required.");
	if (!trimmedUrl.match(/^https?:\/\//i)) throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
	try {
		return new URL(ensureTrailingSlash(trimmedUrl));
	} catch (_unused) {
		throw Error("Invalid supabaseUrl: Provided URL is malformed.");
	}
}

//#endregion
//#region src/lib/SupabaseAuthClient.ts
var SupabaseAuthClient = class extends AuthClient {
	constructor(options) {
		super(options);
	}
};

//#endregion
//#region src/SupabaseClient.ts
/**
* Supabase Client.
*
* An isomorphic Javascript client for interacting with Postgres.
*/
var SupabaseClient = class {
	/**
	* Create a new client for use in the browser.
	* @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
	* @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
	* @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
	* @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
	* @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
	* @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
	* @param options.realtime Options passed along to realtime-js constructor.
	* @param options.storage Options passed along to the storage-js constructor.
	* @param options.global.fetch A custom fetch implementation.
	* @param options.global.headers Any additional headers to send with each network request.
	* @example
	* ```ts
	* import { createClient } from '@supabase/supabase-js'
	*
	* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
	* const { data } = await supabase.from('profiles').select('*')
	* ```
	*/
	constructor(supabaseUrl, supabaseKey, options) {
		var _settings$auth$storag, _settings$global$head;
		this.supabaseUrl = supabaseUrl;
		this.supabaseKey = supabaseKey;
		const baseUrl = validateSupabaseUrl(supabaseUrl);
		if (!supabaseKey) throw new Error("supabaseKey is required.");
		this.realtimeUrl = new URL("realtime/v1", baseUrl);
		this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
		this.authUrl = new URL("auth/v1", baseUrl);
		this.storageUrl = new URL("storage/v1", baseUrl);
		this.functionsUrl = new URL("functions/v1", baseUrl);
		const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
		const DEFAULTS = {
			db: DEFAULT_DB_OPTIONS,
			realtime: DEFAULT_REALTIME_OPTIONS,
			auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, { storageKey: defaultStorageKey }),
			global: DEFAULT_GLOBAL_OPTIONS
		};
		const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
		this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : "";
		this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};
		if (!settings.accessToken) {
			var _settings$auth;
			this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);
		} else {
			this.accessToken = settings.accessToken;
			this.auth = new Proxy({}, { get: (_, prop) => {
				throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
			} });
		}
		this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
		this.realtime = this._initRealtimeClient(_objectSpread2({
			headers: this.headers,
			accessToken: this._getAccessToken.bind(this)
		}, settings.realtime));
		if (this.accessToken) Promise.resolve(this.accessToken()).then((token) => this.realtime.setAuth(token)).catch((e) => console.warn("Failed to set initial Realtime auth token:", e));
		this.rest = new PostgrestClient(new URL("rest/v1", baseUrl).href, {
			headers: this.headers,
			schema: settings.db.schema,
			fetch: this.fetch
		});
		this.storage = new StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
		if (!settings.accessToken) this._listenForAuthEvents();
	}
	/**
	* Supabase Functions allows you to deploy and invoke edge functions.
	*/
	get functions() {
		return new FunctionsClient(this.functionsUrl.href, {
			headers: this.headers,
			customFetch: this.fetch
		});
	}
	/**
	* Perform a query on a table or a view.
	*
	* @param relation - The table or view name to query
	*/
	from(relation) {
		return this.rest.from(relation);
	}
	/**
	* Select a schema to query or perform an function (rpc) call.
	*
	* The schema needs to be on the list of exposed schemas inside Supabase.
	*
	* @param schema - The schema to query
	*/
	schema(schema) {
		return this.rest.schema(schema);
	}
	/**
	* Perform a function call.
	*
	* @param fn - The function name to call
	* @param args - The arguments to pass to the function call
	* @param options - Named parameters
	* @param options.head - When set to `true`, `data` will not be returned.
	* Useful if you only need the count.
	* @param options.get - When set to `true`, the function will be called with
	* read-only access mode.
	* @param options.count - Count algorithm to use to count rows returned by the
	* function. Only applicable for [set-returning
	* functions](https://www.postgresql.org/docs/current/functions-srf.html).
	*
	* `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
	* hood.
	*
	* `"planned"`: Approximated but fast count algorithm. Uses the Postgres
	* statistics under the hood.
	*
	* `"estimated"`: Uses exact count for low numbers and planned count for high
	* numbers.
	*/
	rpc(fn, args = {}, options = {
		head: false,
		get: false,
		count: void 0
	}) {
		return this.rest.rpc(fn, args, options);
	}
	/**
	* Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
	*
	* @param {string} name - The name of the Realtime channel.
	* @param {Object} opts - The options to pass to the Realtime channel.
	*
	*/
	channel(name, opts = { config: {} }) {
		return this.realtime.channel(name, opts);
	}
	/**
	* Returns all Realtime channels.
	*/
	getChannels() {
		return this.realtime.getChannels();
	}
	/**
	* Unsubscribes and removes Realtime channel from Realtime client.
	*
	* @param {RealtimeChannel} channel - The name of the Realtime channel.
	*
	*/
	removeChannel(channel) {
		return this.realtime.removeChannel(channel);
	}
	/**
	* Unsubscribes and removes all Realtime channels from Realtime client.
	*/
	removeAllChannels() {
		return this.realtime.removeAllChannels();
	}
	async _getAccessToken() {
		var _this = this;
		var _data$session$access_, _data$session;
		if (_this.accessToken) return await _this.accessToken();
		const { data } = await _this.auth.getSession();
		return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;
	}
	_initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch$1) {
		const authHeaders = {
			Authorization: `Bearer ${this.supabaseKey}`,
			apikey: `${this.supabaseKey}`
		};
		return new SupabaseAuthClient({
			url: this.authUrl.href,
			headers: _objectSpread2(_objectSpread2({}, authHeaders), headers),
			storageKey,
			autoRefreshToken,
			persistSession,
			detectSessionInUrl,
			storage,
			userStorage,
			flowType,
			lock,
			debug,
			throwOnError,
			fetch: fetch$1,
			hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
		});
	}
	_initRealtimeClient(options) {
		return new RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, { params: _objectSpread2(_objectSpread2({}, { apikey: this.supabaseKey }), options === null || options === void 0 ? void 0 : options.params) }));
	}
	_listenForAuthEvents() {
		return this.auth.onAuthStateChange((event, session) => {
			this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
		});
	}
	_handleTokenChanged(event, source, token) {
		if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
			this.changedAccessToken = token;
			this.realtime.setAuth(token);
		} else if (event === "SIGNED_OUT") {
			this.realtime.setAuth();
			if (source == "STORAGE") this.auth.signOut();
			this.changedAccessToken = void 0;
		}
	}
};

//#endregion
//#region src/index.ts
/**
* Creates a new Supabase Client.
*
* @example
* ```ts
* import { createClient } from '@supabase/supabase-js'
*
* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
* const { data, error } = await supabase.from('profiles').select('*')
* ```
*/
const createClient = (supabaseUrl, supabaseKey, options) => {
	return new SupabaseClient(supabaseUrl, supabaseKey, options);
};
function shouldShowDeprecationWarning() {
	const _process = globalThis["process"];
	if (!_process) return false;
	const processVersion = _process["version"];
	if (processVersion === void 0 || processVersion === null) return false;
	const versionMatch = processVersion.match(/^v(\d+)\./);
	if (!versionMatch) return false;
	return parseInt(versionMatch[1], 10) <= 18;
}
if (shouldShowDeprecationWarning()) console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");

const serverSupabaseServiceRole = (event) => {
  const config = useRuntimeConfig$1(event);
  const secretKey = config.supabase.secretKey;
  const serviceKey = config.supabase.serviceKey;
  const url = config.public.supabase.url;
  const serverKey = secretKey || serviceKey;
  if (!serverKey) {
    throw new Error("Missing server key. Set either `SUPABASE_SECRET_KEY` (recommended) or `SUPABASE_SERVICE_KEY` (deprecated) in your environment variables.");
  }
  if (!event.context._supabaseServiceRole) {
    event.context._supabaseServiceRole = createClient(url, serverKey, {
      auth: {
        detectSessionInUrl: false,
        persistSession: false,
        autoRefreshToken: false
      },
      global: {
        fetch: fetchWithRetry$1
      }
    });
  }
  return event.context._supabaseServiceRole;
};

const serverSupabaseUser$1 = async (event) => {
  const client = await serverSupabaseClient$1(event);
  const { data, error } = await client.auth.getClaims();
  if (error) {
    throw createError$2({ statusMessage: error?.message });
  }
  return data?.claims ?? null;
};

const aniversariantes_get = defineEventHandler(async (event) => {
  try {
    console.log("[ANIVERSARIANTES] Iniciando busca...");
    const supabase = serverSupabaseServiceRole(event);
    console.log("[ANIVERSARIANTES] Cliente Supabase criado");
    const hoje = /* @__PURE__ */ new Date();
    const mesAtual = hoje.getMonth() + 1;
    console.log("[ANIVERSARIANTES] Buscando aniversariantes do m\xEAs:", mesAtual);
    const { data: aniversariantes, error } = await supabase.from("funcionarios").select(`
        id,
        nome_completo,
        data_nascimento,
        avatar
      `).eq("status", "ativo").not("data_nascimento", "is", null);
    if (error) {
      console.error("[ANIVERSARIANTES] Erro na query:", error);
      throw error;
    }
    console.log("[ANIVERSARIANTES] Funcion\xE1rios encontrados:", (aniversariantes == null ? void 0 : aniversariantes.length) || 0);
    const aniversariantesMes = (aniversariantes == null ? void 0 : aniversariantes.filter((funcionario) => {
      if (!funcionario.data_nascimento) return false;
      const dataNascimento = new Date(funcionario.data_nascimento);
      const mesNascimento = dataNascimento.getMonth() + 1;
      return mesNascimento === mesAtual;
    })) || [];
    console.log("[ANIVERSARIANTES] Aniversariantes do m\xEAs:", aniversariantesMes.length);
    aniversariantesMes.sort((a, b) => {
      const diaA = new Date(a.data_nascimento).getDate();
      const diaB = new Date(b.data_nascimento).getDate();
      return diaA - diaB;
    });
    return aniversariantesMes;
  } catch (error) {
    console.error("[ANIVERSARIANTES] Erro completo:", {
      message: error.message,
      stack: error.stack,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    throw createError$2({
      statusCode: 500,
      statusMessage: `Erro ao buscar aniversariantes: ${error.message}`
    });
  }
});

const aniversariantes_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: aniversariantes_get
}, Symbol.toStringTag, { value: 'Module' }));

const stats_get = defineEventHandler(async (event) => {
  try {
    console.log("[STATS] Iniciando busca de estat\xEDsticas...");
    const supabase = serverSupabaseServiceRole(event);
    console.log("[STATS] Cliente Supabase criado");
    const { data: funcionarios, error: errorFuncionarios } = await supabase.from("funcionarios").select("id", { count: "exact" }).eq("status", "ativo");
    if (errorFuncionarios) {
      console.error("[STATS] Erro ao buscar funcion\xE1rios:", errorFuncionarios);
      throw errorFuncionarios;
    }
    console.log("[STATS] Funcion\xE1rios encontrados:", (funcionarios == null ? void 0 : funcionarios.length) || 0);
    const hoje = /* @__PURE__ */ new Date();
    const inicioMes = new Date(hoje.getFullYear(), hoje.getMonth(), 1);
    const fimMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 0);
    const { data: holerites, error: errorHolerites } = await supabase.from("holerites").select("id", { count: "exact" }).gte("created_at", inicioMes.toISOString()).lte("created_at", fimMes.toISOString());
    if (errorHolerites) {
      console.error("[STATS] Erro ao buscar holerites:", errorHolerites);
      throw errorHolerites;
    }
    console.log("[STATS] Holerites encontrados:", (holerites == null ? void 0 : holerites.length) || 0);
    const { data: empresas, error: errorEmpresas } = await supabase.from("empresas").select("id", { count: "exact" });
    if (errorEmpresas) {
      console.error("[STATS] Erro ao buscar empresas:", errorEmpresas);
      throw errorEmpresas;
    }
    console.log("[STATS] Empresas encontradas:", (empresas == null ? void 0 : empresas.length) || 0);
    const { data: departamentos, error: errorDepartamentos } = await supabase.from("departamentos").select("id", { count: "exact" });
    if (errorDepartamentos) {
      console.error("[STATS] Erro ao buscar departamentos:", errorDepartamentos);
      throw errorDepartamentos;
    }
    console.log("[STATS] Departamentos encontrados:", (departamentos == null ? void 0 : departamentos.length) || 0);
    const mesAtual = hoje.getMonth() + 1;
    const { data: aniversariantes, error: errorAniversariantes } = await supabase.from("funcionarios").select("id").eq("status", "ativo").not("data_nascimento", "is", null).filter("data_nascimento", "like", `%-${mesAtual.toString().padStart(2, "0")}-%`);
    if (errorAniversariantes) {
      console.error("[STATS] Erro ao buscar aniversariantes:", errorAniversariantes);
    }
    console.log("[STATS] Aniversariantes encontrados:", (aniversariantes == null ? void 0 : aniversariantes.length) || 0);
    const stats = {
      totalFuncionarios: (funcionarios == null ? void 0 : funcionarios.length) || 0,
      holeritesMes: (holerites == null ? void 0 : holerites.length) || 0,
      totalEmpresas: (empresas == null ? void 0 : empresas.length) || 0,
      totalDepartamentos: (departamentos == null ? void 0 : departamentos.length) || 0,
      totalAniversariantes: (aniversariantes == null ? void 0 : aniversariantes.length) || 0,
      folhaMensal: 0,
      // Ser calculado se necessrio
      mesAtual: hoje.toLocaleDateString("pt-BR", { month: "long", year: "numeric" })
    };
    console.log("[STATS] Estat\xEDsticas finais:", stats);
    return stats;
  } catch (error) {
    console.error("[STATS] Erro completo:", {
      message: error.message,
      stack: error.stack,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    throw createError$2({
      statusCode: 500,
      statusMessage: `Erro ao buscar estat\xEDsticas: ${error.message}`
    });
  }
});

const stats_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: stats_get
}, Symbol.toStringTag, { value: 'Module' }));

const variaveis_get = defineEventHandler(async (event) => {
  useRuntimeConfig$1();
  {
    throw createError$2({
      statusCode: 403,
      message: "Debug n\xE3o dispon\xEDvel em produ\xE7\xE3o"
    });
  }
});

const variaveis_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: variaveis_get
}, Symbol.toStringTag, { value: 'Module' }));

const criar_post = defineEventHandler(async (event) => {
  const body = await readBody(event);
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  console.log("\u{1F4DD} Salvando departamento:", JSON.stringify(body, null, 2));
  try {
    if (body.id) {
      console.log("\u{1F504} Atualizando departamento ID:", body.id);
      const { id, ...dadosDepartamento } = body;
      const response = await fetch(
        `${supabaseUrl}/rest/v1/departamentos?id=eq.${id}`,
        {
          method: "PATCH",
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`,
            "Content-Type": "application/json",
            "Prefer": "return=representation"
          },
          body: JSON.stringify(dadosDepartamento)
        }
      );
      if (!response.ok) {
        const errorText = await response.text();
        console.error("\u274C Erro ao atualizar:", errorText);
        throw new Error(`Erro ao atualizar departamento: ${errorText}`);
      }
      const departamentoAtualizado = await response.json();
      console.log("\u2705 Departamento atualizado!");
      return {
        success: true,
        message: "Departamento atualizado com sucesso!",
        data: departamentoAtualizado[0]
      };
    } else {
      console.log("\u2795 Criando novo departamento");
      const response = await fetch(
        `${supabaseUrl}/rest/v1/departamentos`,
        {
          method: "POST",
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`,
            "Content-Type": "application/json",
            "Prefer": "return=representation"
          },
          body: JSON.stringify({
            nome: body.nome,
            descricao: body.descricao,
            responsavel: body.responsavel
          })
        }
      );
      if (!response.ok) {
        const errorText = await response.text();
        console.error("\u274C Erro ao criar:", errorText);
        throw new Error(`Erro ao criar departamento: ${errorText}`);
      }
      const departamentoCriado = await response.json();
      console.log("\u2705 Departamento criado!");
      return {
        success: true,
        message: "Departamento criado com sucesso!",
        data: departamentoCriado[0]
      };
    }
  } catch (error) {
    console.error("\u{1F4A5} Erro ao salvar departamento:", error.message);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao salvar departamento"
    });
  }
});

const criar_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: criar_post
}, Symbol.toStringTag, { value: 'Module' }));

const index_get$8 = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const supabaseKey = config.public.supabaseKey;
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/departamentos?select=*&order=nome.asc`,
      {
        headers: {
          "apikey": supabaseKey,
          "Authorization": `Bearer ${supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!response.ok) {
      throw new Error("Erro ao buscar departamentos");
    }
    const departamentos = await response.json();
    return {
      success: true,
      data: departamentos
    };
  } catch (error) {
    console.error("Erro ao buscar departamentos:", error);
    throw createError$2({
      statusCode: 500,
      message: "Erro ao buscar departamentos"
    });
  }
});

const index_get$9 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get$8
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$4 = defineEventHandler(async (event) => {
  const id = getRouterParam(event, "id");
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  console.log("\u{1F5D1}\uFE0F Deletando empresa ID:", id);
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/empresas?id=eq.${id}`,
      {
        method: "DELETE",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    console.log("\u{1F4CA} Status da resposta:", response.status);
    if (!response.ok) {
      const error = await response.text();
      console.error("\u274C Erro ao deletar:", error);
      throw createError$2({
        statusCode: response.status,
        message: "Erro ao deletar empresa"
      });
    }
    console.log("\u2705 Empresa deletada com sucesso!");
    return {
      success: true,
      message: "Empresa deletada com sucesso!"
    };
  } catch (error) {
    console.error("\u{1F4A5} Erro ao deletar empresa:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao deletar empresa"
    });
  }
});

const _id__delete$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$4
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$4 = defineEventHandler(async (event) => {
  const id = getRouterParam(event, "id");
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const supabaseKey = config.public.supabaseKey;
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/empresas?id=eq.${id}&select=*`,
      {
        headers: {
          "apikey": supabaseKey,
          "Authorization": `Bearer ${supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!response.ok) {
      throw new Error("Erro ao buscar empresa");
    }
    const empresas = await response.json();
    if (!empresas || empresas.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Empresa n\xE3o encontrada"
      });
    }
    return { success: true, data: empresas[0] };
  } catch (error) {
    console.error("Erro ao buscar empresa:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao buscar empresa"
    });
  }
});

const _id__get$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$4
}, Symbol.toStringTag, { value: 'Module' }));

const index_get$6 = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const supabaseKey = config.public.supabaseKey;
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/empresas?select=*&order=nome.asc`,
      {
        headers: {
          "apikey": supabaseKey,
          "Authorization": `Bearer ${supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!response.ok) {
      throw new Error("Erro ao buscar empresas");
    }
    const empresas = await response.json();
    return { success: true, data: empresas };
  } catch (error) {
    console.error("Erro ao buscar empresas:", error);
    throw createError$2({
      statusCode: 500,
      message: "Erro ao buscar empresas"
    });
  }
});

const index_get$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get$6
}, Symbol.toStringTag, { value: 'Module' }));

const index_post$6 = defineEventHandler(async (event) => {
  const body = await readBody(event);
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  console.log("\u{1F3E2} Salvando empresa...");
  console.log("\u{1F4DD} Dados recebidos:", JSON.stringify(body, null, 2));
  const dadosFiltrados = {};
  if (body.id) dadosFiltrados.id = body.id;
  if (body.nome) dadosFiltrados.nome = body.nome;
  if (body.nome_fantasia) dadosFiltrados.nome_fantasia = body.nome_fantasia;
  if (body.cnpj) {
    dadosFiltrados.cnpj = body.cnpj.substring(0, 20);
  }
  if (body.inscricao_estadual) {
    dadosFiltrados.inscricao_estadual = body.inscricao_estadual.substring(0, 20);
  }
  if (body.situacao_cadastral) dadosFiltrados.situacao_cadastral = body.situacao_cadastral;
  if (body.telefone) {
    dadosFiltrados.telefone = body.telefone.substring(0, 20);
  }
  if (body.email_holerites) dadosFiltrados.email = body.email_holerites;
  else if (body.email) dadosFiltrados.email = body.email;
  if (body.logradouro || body.numero || body.bairro || body.municipio || body.uf || body.cep) {
    const partes = [];
    if (body.logradouro) partes.push(body.logradouro);
    if (body.numero) partes.push(body.numero);
    if (body.complemento) partes.push(body.complemento);
    if (body.bairro) partes.push(`- ${body.bairro}`);
    if (body.municipio && body.uf) partes.push(`- ${body.municipio}/${body.uf}`);
    if (body.cep) partes.push(`- CEP: ${body.cep}`);
    dadosFiltrados.endereco = partes.join(" ");
  } else if (body.endereco) {
    dadosFiltrados.endereco = body.endereco;
  }
  console.log("\u2705 Dados filtrados (apenas campos v\xE1lidos):", JSON.stringify(dadosFiltrados, null, 2));
  console.log("\u{1F4CF} Tamanhos dos campos:");
  Object.keys(dadosFiltrados).forEach((key) => {
    const value = dadosFiltrados[key];
    if (typeof value === "string") {
      console.log(`   - ${key}: ${value.length} caracteres - "${value}"`);
      if (["cnpj", "inscricao_estadual", "situacao_cadastral", "telefone"].includes(key) && value.length > 20) {
        console.log(`   \u26A0\uFE0F TRUNCANDO ${key} de ${value.length} para 20 caracteres`);
        dadosFiltrados[key] = value.substring(0, 20);
      }
    }
  });
  console.log("\u{1F4E6} Dados finais a serem enviados:", JSON.stringify(dadosFiltrados, null, 2));
  try {
    let response;
    let url;
    if (dadosFiltrados.id) {
      url = `${supabaseUrl}/rest/v1/empresas?id=eq.${dadosFiltrados.id}`;
      console.log("\u{1F504} ATUALIZANDO empresa ID:", dadosFiltrados.id);
      const { id, ...dadosSemId } = dadosFiltrados;
      response = await fetch(url, {
        method: "PATCH",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify(dadosSemId)
      });
    } else {
      url = `${supabaseUrl}/rest/v1/empresas`;
      console.log("\u2795 CRIANDO nova empresa");
      response = await fetch(url, {
        method: "POST",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify(dadosFiltrados)
      });
    }
    console.log("\u{1F4CA} Status da resposta:", response.status);
    const responseText = await response.text();
    console.log("\u{1F4E6} Resposta do Supabase:", responseText);
    if (!response.ok) {
      console.error("\u274C Erro HTTP:", response.status, responseText);
      throw new Error(`Erro ao salvar empresa: ${response.status} - ${responseText}`);
    }
    const empresa = responseText ? JSON.parse(responseText) : null;
    console.log("\u2705 Empresa salva com sucesso!");
    return {
      success: true,
      message: dadosFiltrados.id ? "Empresa atualizada com sucesso!" : "Empresa criada com sucesso!",
      data: Array.isArray(empresa) ? empresa[0] : empresa
    };
  } catch (error) {
    console.error("\u{1F4A5} Erro ao salvar empresa:", error.message);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao salvar empresa"
    });
  }
});

const index_post$7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_post$6
}, Symbol.toStringTag, { value: 'Module' }));

const schema_get = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/empresas?select=*&limit=1`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    const empresas = await response.json();
    if (Array.isArray(empresas) && empresas.length > 0) {
      const colunas = Object.keys(empresas[0]);
      return {
        success: true,
        message: "Colunas da tabela empresas",
        colunas: colunas.sort(),
        exemplo: empresas[0]
      };
    }
    const testResponse = await fetch(
      `${supabaseUrl}/rest/v1/empresas`,
      {
        method: "POST",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify({
          nome: "TESTE",
          cnpj: "00.000.000/0000-00"
        })
      }
    );
    const testResult = await testResponse.json();
    return {
      success: false,
      message: "Nenhuma empresa encontrada. Tentativa de criar teste:",
      status: testResponse.status,
      resultado: testResult
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
});

const schema_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: schema_get
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get$2 = defineEventHandler(async (event) => {
  console.log("\u{1F50D} [API] GET /api/funcionarios/[id] - Iniciando busca");
  try {
    const supabase = serverSupabaseServiceRole(event);
    const id = getRouterParam(event, "id");
    console.log("\u{1F4CB} [API] ID recebido:", id);
    if (!id) {
      console.error("\u274C [API] ID do funcion\xE1rio n\xE3o fornecido");
      throw createError$2({
        statusCode: 400,
        message: "ID do funcion\xE1rio n\xE3o fornecido"
      });
    }
    console.log("\u{1F50D} [API] Buscando funcion\xE1rio no Supabase...");
    const { data: funcionario, error } = await supabase.from("funcionarios").select("*").eq("id", id).single();
    if (error) {
      console.error("\u274C [API] Erro do Supabase:", error);
      throw error;
    }
    if (!funcionario) {
      console.error("\u274C [API] Funcion\xE1rio n\xE3o encontrado para ID:", id);
      throw createError$2({
        statusCode: 404,
        message: "Funcion\xE1rio n\xE3o encontrado"
      });
    }
    console.log("\u2705 [API] Funcion\xE1rio encontrado:", {
      id: funcionario.id,
      nome: funcionario.nome_completo,
      beneficios: funcionario.beneficios ? "Existe" : "Null",
      beneficiosType: typeof funcionario.beneficios,
      keys: Object.keys(funcionario)
    });
    return funcionario;
  } catch (error) {
    console.error("\u274C [API] Erro geral:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao buscar funcion\xE1rio"
    });
  }
});

const _id__get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get$2
}, Symbol.toStringTag, { value: 'Module' }));

const _id__patch$2 = defineEventHandler(async (event) => {
  const supabase = serverSupabaseServiceRole(event);
  const id = getRouterParam(event, "id");
  const body = await readBody(event);
  try {
    console.log("\u270F\uFE0F Atualizando funcion\xE1rio ID:", id);
    const cleanValue = (value) => {
      if (value === "" || value === void 0) return null;
      return value;
    };
    const dadosParaAtualizar = {};
    if (body.nome_completo && body.nome_completo.trim()) {
      dadosParaAtualizar.nome_completo = body.nome_completo.trim();
    }
    if (body.cpf) {
      dadosParaAtualizar.cpf = body.cpf;
    }
    if (body.email_login) {
      dadosParaAtualizar.email_login = body.email_login;
    }
    if (body.rg !== void 0) dadosParaAtualizar.rg = cleanValue(body.rg);
    if (body.data_nascimento !== void 0) dadosParaAtualizar.data_nascimento = cleanValue(body.data_nascimento);
    if (body.sexo !== void 0) dadosParaAtualizar.sexo = cleanValue(body.sexo);
    if (body.telefone !== void 0) dadosParaAtualizar.telefone = cleanValue(body.telefone);
    if (body.email_pessoal !== void 0) dadosParaAtualizar.email_pessoal = cleanValue(body.email_pessoal);
    if (body.empresa_id !== void 0) dadosParaAtualizar.empresa_id = cleanValue(body.empresa_id);
    if (body.departamento_id !== void 0) dadosParaAtualizar.departamento_id = cleanValue(body.departamento_id);
    if (body.cargo_id !== void 0) dadosParaAtualizar.cargo_id = cleanValue(body.cargo_id);
    if (body.jornada_trabalho_id !== void 0) dadosParaAtualizar.jornada_trabalho_id = cleanValue(body.jornada_trabalho_id);
    if (body.responsavel_id !== void 0) dadosParaAtualizar.responsavel_id = cleanValue(body.responsavel_id);
    if (body.tipo_contrato !== void 0) dadosParaAtualizar.tipo_contrato = cleanValue(body.tipo_contrato);
    if (body.data_admissao !== void 0) dadosParaAtualizar.data_admissao = cleanValue(body.data_admissao);
    if (body.matricula !== void 0) dadosParaAtualizar.matricula = cleanValue(body.matricula);
    if (body.senha !== void 0) dadosParaAtualizar.senha = body.senha;
    if (body.tipo_acesso !== void 0) dadosParaAtualizar.tipo_acesso = body.tipo_acesso || "funcionario";
    if (body.status !== void 0) dadosParaAtualizar.status = body.status || "ativo";
    if (body.salario_base !== void 0) dadosParaAtualizar.salario_base = cleanValue(body.salario_base) || 0;
    if (body.numero_dependentes !== void 0) dadosParaAtualizar.numero_dependentes = cleanValue(body.numero_dependentes) || 0;
    if (body.tipo_salario !== void 0) dadosParaAtualizar.tipo_salario = body.tipo_salario || "mensal";
    if (body.banco !== void 0) dadosParaAtualizar.banco = cleanValue(body.banco);
    if (body.agencia !== void 0) dadosParaAtualizar.agencia = cleanValue(body.agencia);
    if (body.conta !== void 0) dadosParaAtualizar.conta = cleanValue(body.conta);
    if (body.tipo_conta !== void 0) dadosParaAtualizar.tipo_conta = cleanValue(body.tipo_conta);
    if (body.forma_pagamento !== void 0) dadosParaAtualizar.forma_pagamento = cleanValue(body.forma_pagamento);
    if (body.beneficios !== void 0) dadosParaAtualizar.beneficios = body.beneficios || null;
    if (body.descontos_personalizados !== void 0) dadosParaAtualizar.descontos_personalizados = body.descontos_personalizados || null;
    if (body.pis_pasep !== void 0) dadosParaAtualizar.pis_pasep = cleanValue(body.pis_pasep);
    console.log("\u{1F4DD} Campos a atualizar:", Object.keys(dadosParaAtualizar));
    const { data, error } = await supabase.from("funcionarios").update(dadosParaAtualizar).eq("id", id).select().single();
    if (error) {
      console.error("\u274C Erro ao atualizar funcion\xE1rio:", error);
      throw error;
    }
    const funcionario = data;
    console.log("\u2705 Funcion\xE1rio atualizado:", funcionario == null ? void 0 : funcionario.id);
    return {
      success: true,
      data: funcionario
    };
  } catch (error) {
    console.error("\u274C Erro:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao atualizar funcion\xE1rio"
    });
  }
});

const _id__patch$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__patch$2
}, Symbol.toStringTag, { value: 'Module' }));

const enviarAcesso_post = defineEventHandler(async (event) => {
  var _a;
  const supabase = serverSupabaseServiceRole(event);
  const body = await readBody(event);
  try {
    const { funcionario_id } = body;
    if (!funcionario_id) {
      throw new Error("ID do funcion\xE1rio \xE9 obrigat\xF3rio");
    }
    console.log("\u{1F50D} Buscando funcion\xE1rio ID:", funcionario_id);
    const { data: funcionario, error } = await supabase.from("funcionarios").select(`
        id,
        nome_completo,
        email_login,
        email_pessoal,
        senha,
        empresa_id,
        empresas:empresa_id(nome)
      `).eq("id", funcionario_id).single();
    if (error || !funcionario) {
      console.error("\u274C Erro ao buscar funcion\xE1rio:", error);
      throw new Error(`Funcion\xE1rio n\xE3o encontrado. ID: ${funcionario_id}`);
    }
    console.log("\u2705 Funcion\xE1rio encontrado:", funcionario.nome_completo);
    if (!funcionario.email_login && !funcionario.email_pessoal || !funcionario.senha) {
      throw new Error("Funcion\xE1rio n\xE3o possui email ou senha cadastrados");
    }
    const emails = [];
    if (funcionario.email_login) emails.push(funcionario.email_login);
    if (funcionario.email_pessoal && funcionario.email_pessoal !== funcionario.email_login) {
      emails.push(funcionario.email_pessoal);
    }
    const emailsEnviados = [];
    const emailsFalhos = [];
    for (const email of emails) {
      try {
        await enviarEmailCredenciais({
          para: email,
          nome: funcionario.nome_completo,
          login: funcionario.email_login,
          senha: funcionario.senha,
          empresa: ((_a = funcionario.empresas) == null ? void 0 : _a.nome) || "Sistema"
        });
        emailsEnviados.push(email);
        console.log("\u2705 Email enviado para:", email);
      } catch (err) {
        console.error("\u274C Erro ao enviar para:", email, err);
        emailsFalhos.push(email);
      }
    }
    if (emailsEnviados.length === 0) {
      throw new Error("N\xE3o foi poss\xEDvel enviar o email para nenhum endere\xE7o");
    }
    return {
      success: true,
      message: `Credenciais enviadas para: ${emailsEnviados.join(", ")}`,
      emails_enviados: emailsEnviados,
      emails_falhos: emailsFalhos.length > 0 ? emailsFalhos : void 0
    };
  } catch (error) {
    console.error("\u274C Erro ao enviar email:", error.message);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao enviar email"
    });
  }
});

const enviarAcesso_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: enviarAcesso_post
}, Symbol.toStringTag, { value: 'Module' }));

const index_get$4 = defineEventHandler(async (event) => {
  try {
    console.log("[FUNCIONARIOS] Iniciando busca de funcion\xE1rios...");
    const supabase = serverSupabaseServiceRole(event);
    console.log("[FUNCIONARIOS] Cliente Supabase criado");
    const { data: funcionarios, error } = await supabase.from("funcionarios").select(`
        *,
        empresas!inner (
          id,
          nome,
          nome_fantasia
        ),
        cargos (
          id,
          nome
        ),
        departamentos (
          id,
          nome
        )
      `).eq("status", "ativo").order("nome_completo");
    if (error) {
      console.error("[FUNCIONARIOS] Erro na query:", error);
      throw error;
    }
    console.log("[FUNCIONARIOS] Funcion\xE1rios encontrados:", (funcionarios == null ? void 0 : funcionarios.length) || 0);
    return funcionarios || [];
  } catch (error) {
    console.error("[FUNCIONARIOS] Erro completo:", {
      message: error.message,
      stack: error.stack,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    throw createError$2({
      statusCode: 500,
      statusMessage: `Erro ao buscar funcion\xE1rios: ${error.message}`
    });
  }
});

const index_get$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get$4
}, Symbol.toStringTag, { value: 'Module' }));

const index_post$4 = defineEventHandler(async (event) => {
  const supabase = serverSupabaseServiceRole(event);
  const user = await serverSupabaseUser$1(event);
  const body = await readBody(event);
  try {
    console.log("\u{1F4DD} Criando funcion\xE1rio:", body.nome_completo);
    console.log("\u{1F4E7} Email fornecido:", body.email_login);
    console.log("\u{1F464} Usu\xE1rio logado:", user == null ? void 0 : user.email);
    let responsavelCadastroId = null;
    if (user == null ? void 0 : user.email) {
      const { data: usuarioLogado } = await supabase.from("funcionarios").select("id, nome_completo").eq("email_login", user.email).single();
      if (usuarioLogado) {
        responsavelCadastroId = usuarioLogado.id;
        console.log("\u2705 Respons\xE1vel pelo cadastro:", usuarioLogado.nome_completo, "(ID:", usuarioLogado.id, ")");
      }
    }
    const cleanValue = (value) => {
      if (value === "" || value === void 0) return null;
      return value;
    };
    const processResponsavelId = (value) => {
      if (!value || value === "" || value === void 0) return null;
      if (typeof value === "string" && isNaN(Number(value))) {
        console.log("\u26A0\uFE0F responsavel_id \xE9 string:", value, "- convertendo para null");
        return null;
      }
      const numericValue = Number(value);
      if (!isNaN(numericValue)) {
        return numericValue;
      }
      return null;
    };
    const emailLogin = cleanValue(body.email_login);
    if (!emailLogin) {
      throw new Error("Email de login \xE9 obrigat\xF3rio");
    }
    const senha = cleanValue(body.senha);
    if (!senha) {
      throw new Error("Senha \xE9 obrigat\xF3ria");
    }
    console.log("\u{1F4E7} Email a ser usado:", emailLogin);
    const dadosParaInserir = {
      nome_completo: body.nome_completo,
      cpf: body.cpf,
      rg: cleanValue(body.rg),
      data_nascimento: cleanValue(body.data_nascimento),
      sexo: cleanValue(body.sexo),
      telefone: cleanValue(body.telefone),
      email_pessoal: cleanValue(body.email_pessoal),
      empresa_id: cleanValue(body.empresa_id),
      departamento_id: cleanValue(body.departamento_id),
      cargo_id: cleanValue(body.cargo_id),
      jornada_trabalho_id: cleanValue(body.jornada_trabalho_id),
      responsavel_id: processResponsavelId(body.responsavel_id),
      responsavel_cadastro_id: responsavelCadastroId,
      // NOVO CAMPO
      tipo_contrato: cleanValue(body.tipo_contrato),
      data_admissao: cleanValue(body.data_admissao),
      matricula: cleanValue(body.matricula),
      email_login: emailLogin,
      senha,
      tipo_acesso: body.tipo_acesso || "funcionario",
      status: body.status || "ativo",
      salario_base: cleanValue(body.salario_base) || 0,
      numero_dependentes: cleanValue(body.numero_dependentes) || 0,
      tipo_salario: body.tipo_salario || "mensal",
      banco: cleanValue(body.banco),
      agencia: cleanValue(body.agencia),
      conta: cleanValue(body.conta),
      tipo_conta: cleanValue(body.tipo_conta),
      forma_pagamento: cleanValue(body.forma_pagamento),
      beneficios: body.beneficios || {},
      descontos_personalizados: body.descontos_personalizados || []
    };
    console.log("\u{1F4E6} Dados a inserir:", JSON.stringify(dadosParaInserir, null, 2));
    const { data: funcionario, error } = await supabase.from("funcionarios").insert(dadosParaInserir).select().single();
    if (error) {
      console.error("\u274C Erro ao criar funcion\xE1rio:", error);
      throw error;
    }
    console.log("\u2705 Funcion\xE1rio criado:", funcionario.id);
    console.log("\u{1F464} Cadastrado por:", responsavelCadastroId ? `ID ${responsavelCadastroId}` : "Sistema");
    return {
      success: true,
      data: funcionario
    };
  } catch (error) {
    console.error("\u274C Erro completo:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao criar funcion\xE1rio"
    });
  }
});

const index_post$5 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_post$4
}, Symbol.toStringTag, { value: 'Module' }));

const meusDados_get = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  const query = getQuery(event);
  const userId = query.userId;
  if (!userId) {
    throw createError$2({
      statusCode: 401,
      message: "Usu\xE1rio n\xE3o autenticado"
    });
  }
  console.log("\u{1F50D} Buscando dados do funcion\xE1rio ID:", userId);
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?id=eq.${userId}&select=*,empresas(id,nome_fantasia,nome,cnpj)`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!response.ok) {
      const errorText = await response.text();
      console.error("\u274C Erro ao buscar funcion\xE1rio:", errorText);
      throw new Error("Erro ao buscar dados do funcion\xE1rio");
    }
    const funcionarios = await response.json();
    console.log("\u{1F4E6} Funcion\xE1rios encontrados:", funcionarios.length);
    if (funcionarios && funcionarios.length > 0) {
      console.log("\u2705 Dados do funcion\xE1rio:", funcionarios[0].nome_completo);
      return {
        success: true,
        data: funcionarios[0]
      };
    }
    console.error("\u274C Funcion\xE1rio n\xE3o encontrado com ID:", userId);
    throw new Error("Funcion\xE1rio n\xE3o encontrado");
  } catch (error) {
    console.error("\u{1F4A5} Erro ao buscar dados:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao buscar dados do funcion\xE1rio"
    });
  }
});

const meusDados_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: meusDados_get
}, Symbol.toStringTag, { value: 'Module' }));

const meusDados_patch = defineEventHandler(async (event) => {
  var _a;
  const body = await readBody(event);
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  const userId = body.userId;
  if (!userId) {
    throw createError$2({
      statusCode: 401,
      message: "Usu\xE1rio n\xE3o autenticado"
    });
  }
  console.log("\u{1F4DD} Atualizando dados do funcion\xE1rio:", userId);
  console.log("\u{1F4E6} Dados recebidos:", JSON.stringify(body, null, 2));
  try {
    const userResponse = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?id=eq.${userId}&select=tipo_acesso`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!userResponse.ok) {
      throw new Error("Erro ao verificar permiss\xF5es do usu\xE1rio");
    }
    const userData = await userResponse.json();
    const isAdmin = ((_a = userData[0]) == null ? void 0 : _a.tipo_acesso) === "admin";
    console.log("\u{1F464} Tipo de usu\xE1rio:", isAdmin ? "Admin" : "Funcion\xE1rio");
    const camposPermitidos = {
      telefone: body.telefone,
      email_pessoal: body.email_pessoal,
      pis_pasep: body.pis_pasep,
      banco: body.banco,
      agencia: body.agencia,
      conta: body.conta,
      tipo_conta: body.tipo_conta,
      forma_pagamento: body.forma_pagamento,
      chave_pix: body.chave_pix,
      avatar: body.avatar,
      // Todos podem alterar avatar
      // Campos que podem ser editados apenas uma vez (verificao no frontend)
      data_nascimento: body.data_nascimento,
      sexo: body.sexo,
      rg: body.rg
    };
    if (isAdmin) {
      if (body.nome_completo !== void 0) camposPermitidos.nome_completo = body.nome_completo;
      if (body.cpf !== void 0) camposPermitidos.cpf = body.cpf;
      if (body.cargo_id !== void 0) camposPermitidos.cargo_id = body.cargo_id;
      if (body.departamento_id !== void 0) camposPermitidos.departamento_id = body.departamento_id;
      if (body.data_admissao !== void 0) camposPermitidos.data_admissao = body.data_admissao;
      if (body.tipo_contrato !== void 0) camposPermitidos.tipo_contrato = body.tipo_contrato;
      if (body.empresa_id !== void 0) camposPermitidos.empresa_id = body.empresa_id;
      if (body.pensao_alimenticia !== void 0) camposPermitidos.pensao_alimenticia = body.pensao_alimenticia;
    } else {
      if (body.pensao_alimenticia !== void 0) {
        console.log("\u26A0\uFE0F Funcion\xE1rio tentou atualizar pens\xE3o aliment\xEDcia - IGNORADO");
      }
    }
    const chavesPermitidas = Object.keys(camposPermitidos);
    chavesPermitidas.forEach((key) => {
      if (camposPermitidos[key] === void 0) {
        delete camposPermitidos[key];
      }
    });
    console.log("\u2705 Campos a atualizar:", JSON.stringify(camposPermitidos, null, 2));
    const response = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?id=eq.${userId}`,
      {
        method: "PATCH",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify(camposPermitidos)
      }
    );
    console.log("\u{1F4CA} Status da resposta:", response.status);
    if (!response.ok) {
      const errorText = await response.text();
      console.error("\u274C Erro ao atualizar:", errorText);
      throw new Error(`Erro ao atualizar dados: ${errorText}`);
    }
    const funcionarioAtualizado = await response.json();
    console.log("\u2705 Dados atualizados com sucesso!");
    return {
      success: true,
      message: "Dados atualizados com sucesso!",
      data: funcionarioAtualizado[0]
    };
  } catch (error) {
    console.error("\u{1F4A5} Erro ao atualizar dados:", error.message);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao atualizar dados"
    });
  }
});

const meusDados_patch$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: meusDados_patch
}, Symbol.toStringTag, { value: 'Module' }));

const health_get = defineEventHandler(async () => {
  try {
    console.log("[HEALTH] Iniciando health check...");
    const config = useRuntimeConfig$1();
    const envCheck = {
      supabaseUrl: !!config.public.supabaseUrl,
      supabaseKey: !!config.public.supabaseKey,
      supabaseServiceRoleKey: !!config.supabaseServiceRoleKey,
      nodeVersion: process.version,
      platform: process.platform,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    console.log("[HEALTH] Vari\xE1veis verificadas:", envCheck);
    const detailedCheck = {
      NUXT_PUBLIC_SUPABASE_URL: !!process.env.NUXT_PUBLIC_SUPABASE_URL,
      NUXT_PUBLIC_SUPABASE_KEY: !!process.env.NUXT_PUBLIC_SUPABASE_KEY,
      SUPABASE_SERVICE_ROLE_KEY: !!process.env.SUPABASE_SERVICE_ROLE_KEY,
      SUPABASE_URL: !!process.env.SUPABASE_URL,
      NUXT_SECRET_KEY: !!process.env.NUXT_SECRET_KEY,
      NODE_ENV: "production",
      VERCEL_ENV: process.env.VERCEL_ENV
    };
    console.log("[HEALTH] Verifica\xE7\xE3o detalhada:", detailedCheck);
    const result = {
      status: "ok",
      message: "Health check passed",
      environment: envCheck,
      detailed: detailedCheck,
      vercel: {
        region: process.env.VERCEL_REGION || "unknown",
        env: process.env.VERCEL_ENV || "unknown",
        url: process.env.VERCEL_URL || "unknown"
      }
    };
    console.log("[HEALTH] Health check conclu\xEDdo com sucesso");
    return result;
  } catch (error) {
    console.error("[HEALTH] Erro no health check:", {
      message: error.message,
      stack: error.stack
    });
    throw createError$2({
      statusCode: 500,
      statusMessage: `Health check failed: ${error.message}`
    });
  }
});

const health_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: health_get
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete$2 = defineEventHandler(async (event) => {
  const id = getRouterParam(event, "id");
  if (!id) {
    throw createError$2({
      statusCode: 400,
      message: "ID do holerite n\xE3o fornecido"
    });
  }
  const supabase = await serverSupabaseServiceRole(event);
  const { error } = await supabase.from("holerites").delete().eq("id", id);
  if (error) {
    console.error("Erro ao excluir holerite:", error);
    throw createError$2({
      statusCode: 500,
      message: "Erro ao excluir holerite"
    });
  }
  return {
    success: true,
    message: "Holerite exclu\xEDdo com sucesso"
  };
});

const _id__delete$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete$2
}, Symbol.toStringTag, { value: 'Module' }));

const _id__patch = defineEventHandler(async (event) => {
  try {
    const supabase = serverSupabaseServiceRole(event);
    const id = getRouterParam(event, "id");
    const body = await readBody(event);
    if (!id) {
      throw createError$2({
        statusCode: 400,
        message: "ID do holerite n\xE3o fornecido"
      });
    }
    const dadosParaAtualizar = {};
    if (body.salario_base !== void 0) dadosParaAtualizar.salario_base = body.salario_base;
    if (body.bonus !== void 0) dadosParaAtualizar.bonus = body.bonus;
    if (body.horas_extras !== void 0) dadosParaAtualizar.horas_extras = body.horas_extras;
    if (body.adicional_noturno !== void 0) dadosParaAtualizar.adicional_noturno = body.adicional_noturno;
    if (body.adicional_periculosidade !== void 0) dadosParaAtualizar.adicional_periculosidade = body.adicional_periculosidade;
    if (body.adicional_insalubridade !== void 0) dadosParaAtualizar.adicional_insalubridade = body.adicional_insalubridade;
    if (body.comissoes !== void 0) dadosParaAtualizar.comissoes = body.comissoes;
    if (body.inss !== void 0) dadosParaAtualizar.inss = body.inss;
    if (body.irrf !== void 0) dadosParaAtualizar.irrf = body.irrf;
    if (body.vale_transporte !== void 0) dadosParaAtualizar.vale_transporte = body.vale_transporte;
    if (body.cesta_basica_desconto !== void 0) dadosParaAtualizar.cesta_basica_desconto = body.cesta_basica_desconto;
    if (body.plano_saude !== void 0) dadosParaAtualizar.plano_saude = body.plano_saude;
    if (body.plano_odontologico !== void 0) dadosParaAtualizar.plano_odontologico = body.plano_odontologico;
    if (body.adiantamento !== void 0) dadosParaAtualizar.adiantamento = body.adiantamento;
    if (body.faltas !== void 0) dadosParaAtualizar.faltas = body.faltas;
    if (body.horas_trabalhadas !== void 0) dadosParaAtualizar.horas_trabalhadas = body.horas_trabalhadas;
    if (body.observacoes !== void 0) dadosParaAtualizar.observacoes = body.observacoes;
    if (body.data_pagamento !== void 0) dadosParaAtualizar.data_pagamento = body.data_pagamento;
    if (body.status !== void 0) dadosParaAtualizar.status = body.status;
    if (Object.keys(dadosParaAtualizar).length === 0) {
      throw createError$2({
        statusCode: 400,
        message: "Nenhum campo para atualizar"
      });
    }
    const { data, error } = await supabase.from("holerites").update(dadosParaAtualizar).eq("id", id).select(`
        *,
        funcionario:funcionarios (
          nome_completo,
          cargo:cargos (nome),
          empresa:empresas (nome_fantasia)
        )
      `).single();
    if (error) {
      console.error("Erro ao atualizar holerite:", error);
      throw error;
    }
    return {
      success: true,
      data
    };
  } catch (error) {
    console.error("Erro ao atualizar holerite:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao atualizar holerite"
    });
  }
});

const _id__patch$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__patch
}, Symbol.toStringTag, { value: 'Module' }));

const enviarEmail_post = defineEventHandler(async (event) => {
  try {
    const config = useRuntimeConfig$1();
    const supabaseUrl = config.public.supabaseUrl;
    const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
    const id = getRouterParam(event, "id");
    if (!id) {
      throw createError$2({
        statusCode: 400,
        message: "ID do holerite n\xE3o fornecido"
      });
    }
    console.log("\u{1F4E7} Buscando holerite ID:", id);
    const holeriteResponse = await fetch(
      `${supabaseUrl}/rest/v1/holerites?id=eq.${id}&select=*`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!holeriteResponse.ok) {
      const errorText = await holeriteResponse.text();
      console.error("\u274C Erro ao buscar holerite:", errorText);
      throw new Error("Erro ao buscar holerite");
    }
    const holerites = await holeriteResponse.json();
    if (!holerites || holerites.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Holerite n\xE3o encontrado"
      });
    }
    const holerite = holerites[0];
    console.log("\u2705 Holerite encontrado:", holerite.id);
    const funcionarioResponse = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?id=eq.${holerite.funcionario_id}&select=*`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!funcionarioResponse.ok) {
      throw new Error("Erro ao buscar funcion\xE1rio");
    }
    const funcionarios = await funcionarioResponse.json();
    if (!funcionarios || funcionarios.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Funcion\xE1rio n\xE3o encontrado"
      });
    }
    const funcionario = funcionarios[0];
    console.log("\u2705 Funcion\xE1rio encontrado:", funcionario.nome_completo);
    const emailDestino = funcionario.email || funcionario.email_login;
    if (!emailDestino) {
      throw createError$2({
        statusCode: 400,
        message: "Funcion\xE1rio n\xE3o possui email cadastrado"
      });
    }
    const periodoInicio = new Date(holerite.periodo_inicio);
    const periodoFim = new Date(holerite.periodo_fim);
    const mesAno = periodoInicio.toLocaleDateString("pt-BR", { month: "long", year: "numeric" });
    let tipoHolerite = "mensal";
    if (periodoInicio.getDate() === 1 && periodoFim.getDate() <= 15) {
      tipoHolerite = "1\xAA quinzena";
    } else if (periodoInicio.getDate() === 16) {
      tipoHolerite = "2\xAA quinzena";
    }
    console.log("\u{1F4E8} Enviando email para:", emailDestino);
    const emailEnviado = await enviarEmail({
      to: emailDestino,
      subject: `Holerite dispon\xEDvel - ${mesAno}`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #2563eb;">Holerite Dispon\xEDvel</h2>
          
          <p>Ol\xE1, <strong>${funcionario.nome_completo}</strong>!</p>
          
          <p>Seu holerite referente a <strong>${mesAno} (${tipoHolerite})</strong> est\xE1 dispon\xEDvel para visualiza\xE7\xE3o.</p>
          
          <div style="background-color: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="margin-top: 0; color: #1f2937;">Resumo do Holerite</h3>
            <p><strong>Per\xEDodo:</strong> ${periodoInicio.toLocaleDateString("pt-BR")} a ${periodoFim.toLocaleDateString("pt-BR")}</p>
            <p><strong>Sal\xE1rio Base:</strong> ${new Intl.NumberFormat("pt-BR", { style: "currency", currency: "BRL" }).format(holerite.salario_base || 0)}</p>
            <p><strong>Sal\xE1rio L\xEDquido:</strong> ${new Intl.NumberFormat("pt-BR", { style: "currency", currency: "BRL" }).format(holerite.salario_liquido || 0)}</p>
          </div>
          
          <p>Acesse o sistema para visualizar os detalhes completos e fazer o download do PDF.</p>
          
          <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 12px;">
            <p>Este \xE9 um email autom\xE1tico. Por favor, n\xE3o responda.</p>
          </div>
        </div>
      `
    });
    if (!emailEnviado || !emailEnviado.success) {
      throw createError$2({
        statusCode: 500,
        message: "Erro ao enviar email"
      });
    }
    console.log("\u2705 Email enviado com sucesso!");
    await fetch(
      `${supabaseUrl}/rest/v1/holerites?id=eq.${id}`,
      {
        method: "PATCH",
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=minimal"
        },
        body: JSON.stringify({ status: "enviado" })
      }
    );
    return {
      success: true,
      message: "Email enviado com sucesso",
      email: emailDestino
    };
  } catch (error) {
    console.error("\u{1F4A5} Erro ao enviar email do holerite:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao enviar email"
    });
  }
});

const enviarEmail_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: enviarEmail_post
}, Symbol.toStringTag, { value: 'Module' }));

const html_get = defineEventHandler(async (event) => {
  const id = getRouterParam(event, "id");
  const supabase = serverSupabaseServiceRole(event);
  try {
    if (!id) {
      throw createError$2({
        statusCode: 400,
        message: "ID do holerite \xE9 obrigat\xF3rio"
      });
    }
    const { data: holerite, error: holeriteError } = await supabase.from("holerites").select("*").eq("id", id).single();
    if (holeriteError || !holerite) {
      throw createError$2({
        statusCode: 404,
        message: "Holerite n\xE3o encontrado"
      });
    }
    const { data: funcionario, error: funcError } = await supabase.from("funcionarios").select("*").eq("id", holerite.funcionario_id).single();
    if (funcError || !funcionario) {
      throw createError$2({
        statusCode: 404,
        message: "Funcion\xE1rio n\xE3o encontrado"
      });
    }
    let cargo = null;
    if (funcionario.cargo_id) {
      const { data: cargoData } = await supabase.from("cargos").select("nome").eq("id", funcionario.cargo_id).single();
      cargo = cargoData;
    }
    let departamento = null;
    if (funcionario.departamento_id) {
      const { data: deptData } = await supabase.from("departamentos").select("nome").eq("id", funcionario.departamento_id).single();
      departamento = deptData;
    }
    const { data: empresa, error: empresaError } = await supabase.from("empresas").select("*").eq("id", funcionario.empresa_id).single();
    if (empresaError || !empresa) {
      throw createError$2({
        statusCode: 404,
        message: "Empresa n\xE3o encontrada"
      });
    }
    const funcionarioData = {
      nome_completo: funcionario.nome_completo,
      cpf: funcionario.cpf,
      cargo: (cargo == null ? void 0 : cargo.nome) || "N\xE3o informado",
      departamento: (departamento == null ? void 0 : departamento.nome) || "N\xE3o informado",
      data_admissao: funcionario.data_admissao,
      numero_dependentes: funcionario.numero_dependentes || 0,
      pensao_alimenticia: funcionario.pensao_alimenticia || 0
    };
    const empresaData = {
      nome: empresa.nome || empresa.nome_fantasia || "Empresa",
      cnpj: empresa.cnpj || "",
      logradouro: empresa.logradouro || "",
      numero: empresa.numero || "",
      complemento: empresa.complemento || "",
      bairro: empresa.bairro || "",
      cidade: empresa.cidade || "",
      estado: empresa.estado || "",
      cep: empresa.cep || ""
    };
    const html = gerarHoleriteHTML(holerite, funcionarioData, empresaData);
    setHeader(event, "Content-Type", "text/html; charset=utf-8");
    setHeader(event, "Content-Disposition", `attachment; filename="holerite-${funcionario.nome_completo.replace(/\s+/g, "-")}.html"`);
    return html;
  } catch (error) {
    console.error("Erro ao gerar HTML:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao gerar HTML do holerite"
    });
  }
});

const html_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: html_get
}, Symbol.toStringTag, { value: 'Module' }));

const pdf_get = defineEventHandler(async (event) => {
  try {
    const config = useRuntimeConfig$1();
    const supabaseUrl = config.public.supabaseUrl;
    const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
    const id = getRouterParam(event, "id");
    if (!id) {
      throw createError$2({
        statusCode: 400,
        message: "ID do holerite n\xE3o fornecido"
      });
    }
    console.log("\u{1F4C4} Gerando holerite HTML para ID:", id);
    const holeriteResponse = await fetch(
      `${supabaseUrl}/rest/v1/holerites?id=eq.${id}&select=*`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!holeriteResponse.ok) {
      throw new Error("Erro ao buscar holerite");
    }
    const holerites = await holeriteResponse.json();
    if (!holerites || holerites.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Holerite n\xE3o encontrado"
      });
    }
    const holerite = holerites[0];
    const funcionarioResponse = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?id=eq.${holerite.funcionario_id}&select=*`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!funcionarioResponse.ok) {
      throw new Error("Erro ao buscar funcion\xE1rio");
    }
    const funcionarios = await funcionarioResponse.json();
    if (!funcionarios || funcionarios.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Funcion\xE1rio n\xE3o encontrado"
      });
    }
    const funcionario = funcionarios[0];
    let cargoNome = "N\xE3o definido";
    if (funcionario.cargo_id) {
      const cargoResponse = await fetch(
        `${supabaseUrl}/rest/v1/cargos?id=eq.${funcionario.cargo_id}&select=nome`,
        {
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`,
            "Content-Type": "application/json"
          }
        }
      );
      if (cargoResponse.ok) {
        const cargos = await cargoResponse.json();
        if (cargos && cargos.length > 0) {
          cargoNome = cargos[0].nome;
        }
      }
    }
    let departamentoNome = "N\xE3o definido";
    if (funcionario.departamento_id) {
      const deptResponse = await fetch(
        `${supabaseUrl}/rest/v1/departamentos?id=eq.${funcionario.departamento_id}&select=nome`,
        {
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`,
            "Content-Type": "application/json"
          }
        }
      );
      if (deptResponse.ok) {
        const departamentos = await deptResponse.json();
        if (departamentos && departamentos.length > 0) {
          departamentoNome = departamentos[0].nome;
        }
      }
    }
    funcionario.cargo_nome = cargoNome;
    funcionario.departamento_nome = departamentoNome;
    funcionario.numero_dependentes = funcionario.numero_dependentes || 0;
    const empresaResponse = await fetch(
      `${supabaseUrl}/rest/v1/empresas?id=eq.${funcionario.empresa_id}&select=*`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!empresaResponse.ok) {
      throw new Error("Erro ao buscar empresa");
    }
    const empresas = await empresaResponse.json();
    if (!empresas || empresas.length === 0) {
      throw createError$2({
        statusCode: 404,
        message: "Empresa n\xE3o encontrada"
      });
    }
    const empresa = empresas[0];
    const html = gerarHoleriteHTML(holerite, funcionario, empresa);
    setResponseHeader(event, "Content-Type", "text/html; charset=utf-8");
    return html;
  } catch (error) {
    console.error("Erro ao gerar holerite:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao gerar holerite"
    });
  }
});

const pdf_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: pdf_get
}, Symbol.toStringTag, { value: 'Module' }));

function round2(valor) {
  return Math.round(valor * 100) / 100;
}
function aplicarTabelaProgressivaMensal(baseIRRF) {
  if (baseIRRF <= 2428.8) {
    return 0;
  } else if (baseIRRF <= 3051) {
    return baseIRRF * 0.075 - 182.16;
  } else if (baseIRRF <= 4052) {
    return baseIRRF * 0.15 - 394.16;
  } else if (baseIRRF <= 5050) {
    return baseIRRF * 0.225 - 675.49;
  } else {
    return baseIRRF * 0.275 - 896;
  }
}
function normalizarDependentes(dependentes) {
  if (dependentes === null || dependentes === void 0 || dependentes === "") {
    return 0;
  }
  const num = Number(dependentes);
  if (isNaN(num) || num < 0) {
    console.warn(`\u26A0\uFE0F N\xFAmero de dependentes inv\xE1lido: ${dependentes}, usando 0`);
    return 0;
  }
  return Math.floor(num);
}
function normalizarPensao(pensao) {
  if (pensao === null || pensao === void 0 || pensao === "") {
    return 0;
  }
  const num = Number(pensao);
  if (isNaN(num) || num < 0) {
    console.warn(`\u26A0\uFE0F Pens\xE3o aliment\xEDcia inv\xE1lida: ${pensao}, usando 0`);
    return 0;
  }
  return round2(num);
}
function calcularRedutorLei15270(baseIRRF) {
  if (baseIRRF <= 5e3) {
    const impostoTabela = aplicarTabelaProgressivaMensal(baseIRRF);
    return impostoTabela;
  } else if (baseIRRF <= 7350) {
    return 978.62 - 0.133145 * baseIRRF;
  } else {
    return 0;
  }
}
function calcularBaseIRRF(salarioBruto, inss, dependentes, pensao, gastosSaude) {
  const deducaoDependentes = dependentes * 189.59;
  let base = salarioBruto - inss - deducaoDependentes - pensao;
  base = base - gastosSaude;
  const baseIRRF = Math.max(0, base);
  const deducoesAplicadas = {
    salarioBruto: round2(salarioBruto),
    inss: round2(inss),
    dependentes: {
      quantidade: dependentes,
      valorUnitario: 189.59,
      totalDeduzido: round2(deducaoDependentes)
    },
    pensaoAlimenticia: round2(pensao),
    gastosSaude: round2(gastosSaude),
    baseCalculada: round2(base),
    baseIRRF: round2(baseIRRF),
    baseNegativaAjustada: base < 0
  };
  if (base < 0) {
    console.warn(`\u26A0\uFE0F Base IRRF seria negativa (R$ ${base.toFixed(2)}), ajustada para R$ 0,00`);
  }
  return { baseIRRF: round2(baseIRRF), deducoesAplicadas };
}
const gerar_post = defineEventHandler(async (event) => {
  try {
    const supabase = serverSupabaseServiceRole(event);
    const body = await readBody(event);
    const {
      periodo_inicio,
      periodo_fim,
      funcionario_ids,
      tipo = "mensal",
      recriar = false
    } = body;
    console.log(`\u{1F3AF} Tipo de gera\xE7\xE3o: ${tipo}`);
    console.log(`\u{1F4C5} Per\xEDodo: ${periodo_inicio} a ${periodo_fim}`);
    let query = supabase.from("funcionarios").select("id, nome_completo, salario_base, numero_dependentes, pensao_alimenticia, tipo_contrato").eq("status", "ativo");
    if (funcionario_ids && funcionario_ids.length > 0) {
      query = query.in("id", funcionario_ids);
    }
    const { data: funcionarios, error: funcError } = await query;
    if (funcError) throw funcError;
    if (!funcionarios || funcionarios.length === 0) {
      return {
        success: false,
        message: "Nenhum funcion\xE1rio ativo encontrado"
      };
    }
    console.log("\u{1F465} Funcion\xE1rios encontrados:", funcionarios.length);
    const hoje = /* @__PURE__ */ new Date();
    const inicio = periodo_inicio || `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, "0")}-01`;
    const fim = periodo_fim || `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, "0")}-15`;
    const holeritesCriados = [];
    const erros = [];
    for (const func of funcionarios) {
      try {
        console.log(`
\u{1F504} Processando funcion\xE1rio: ${func.nome_completo}`);
        const { data: existente } = await supabase.from("holerites").select("id").eq("funcionario_id", func.id).eq("periodo_inicio", inicio).eq("periodo_fim", fim).maybeSingle();
        if (existente && !recriar) {
          console.log(`\u26A0\uFE0F Holerite j\xE1 existe para ${func.nome_completo}`);
          erros.push({
            funcionario: func.nome_completo,
            erro: "Holerite j\xE1 existe para este per\xEDodo"
          });
          continue;
        }
        if (existente && recriar) {
          console.log(`\u{1F504} Recriando holerite para ${func.nome_completo}`);
          await supabase.from("holerites").delete().eq("id", existente.id);
        }
        const salarioBase = func.salario_base || 0;
        const isAdiantamento = tipo === "adiantamento";
        if (isAdiantamento) {
          const valorAdiantamento = salarioBase * 0.4;
          console.log(`\u{1F4B0} ADIANTAMENTO: 40% de R$ ${salarioBase.toFixed(2)} = R$ ${valorAdiantamento.toFixed(2)}`);
          const dadosAdiantamento = {
            funcionario_id: func.id,
            periodo_inicio: inicio,
            periodo_fim: fim,
            data_pagamento: fim,
            salario_base: valorAdiantamento,
            // Todos os outros campos zerados
            bonus: 0,
            horas_extras: 0,
            adicional_noturno: 0,
            adicional_periculosidade: 0,
            adicional_insalubridade: 0,
            comissoes: 0,
            inss: 0,
            base_inss: 0,
            aliquota_inss: 0,
            irrf: 0,
            base_irrf: 0,
            aliquota_irrf: 0,
            vale_transporte: 0,
            cesta_basica_desconto: 0,
            plano_saude: 0,
            plano_odontologico: 0,
            adiantamento: 0,
            faltas: 0,
            outros_descontos: 0,
            beneficios: [],
            descontos_personalizados: [],
            status: "gerado",
            observacoes: `Adiantamento salarial (40%) - Sal\xE1rio base: R$ ${salarioBase.toFixed(2)}`
          };
          const { data: holerite, error: holeriteError } = await supabase.from("holerites").insert(dadosAdiantamento).select().single();
          if (holeriteError) throw holeriteError;
          await supabase.from("holerites").update({
            total_proventos: valorAdiantamento,
            total_descontos: 0,
            salario_liquido: valorAdiantamento
          }).eq("id", holerite.id);
          console.log(`\u2705 Adiantamento criado: R$ ${valorAdiantamento.toFixed(2)}`);
          holeritesCriados.push({
            funcionario: func.nome_completo,
            holerite_id: holerite.id
          });
        } else {
          const mesAno = inicio.substring(0, 7);
          const { data: adiantamentos } = await supabase.from("holerites").select("salario_base, observacoes").eq("funcionario_id", func.id).gte("periodo_inicio", mesAno + "-01").lt("periodo_fim", mesAno + "-16");
          let totalAdiantamentos = 0;
          if (adiantamentos && adiantamentos.length > 0) {
            totalAdiantamentos = adiantamentos.reduce((sum, h) => {
              var _a;
              if ((_a = h.observacoes) == null ? void 0 : _a.includes("Adiantamento")) {
                return sum + (h.salario_base || 0);
              }
              return sum;
            }, 0);
            console.log(`\u{1F4B8} Adiantamentos do m\xEAs: R$ ${totalAdiantamentos.toFixed(2)}`);
          }
          let inss = 0;
          let aliquotaEfetiva = 0;
          const tipoContrato = func.tipo_contrato || "CLT";
          if (tipoContrato === "PJ") {
            inss = 0;
            aliquotaEfetiva = 0;
            console.log(`\u{1F4BC} Funcion\xE1rio PJ - Sem desconto de INSS`);
          } else {
            if (salarioBase <= 1518) {
              inss = salarioBase * 0.075;
              aliquotaEfetiva = 7.5;
            } else if (salarioBase <= 2793.88) {
              inss = 1518 * 0.075 + (salarioBase - 1518) * 0.09;
              aliquotaEfetiva = inss / salarioBase * 100;
            } else if (salarioBase <= 4190.83) {
              inss = 1518 * 0.075 + (2793.88 - 1518) * 0.09 + (salarioBase - 2793.88) * 0.12;
              aliquotaEfetiva = inss / salarioBase * 100;
            } else if (salarioBase <= 8157.41) {
              inss = 1518 * 0.075 + (2793.88 - 1518) * 0.09 + (4190.83 - 2793.88) * 0.12 + (salarioBase - 4190.83) * 0.14;
              aliquotaEfetiva = inss / salarioBase * 100;
            } else {
              inss = 1518 * 0.075 + (2793.88 - 1518) * 0.09 + (4190.83 - 2793.88) * 0.12 + (8157.41 - 4190.83) * 0.14;
              aliquotaEfetiva = inss / salarioBase * 100;
            }
            inss = Math.round(inss * 100) / 100;
            aliquotaEfetiva = Math.round(aliquotaEfetiva * 100) / 100;
          }
          let irrf = 0;
          let baseIRRF = 0;
          let aliquotaIRRF = 0;
          let deducoesAplicadas = null;
          if (tipoContrato === "PJ") {
            irrf = 0;
            baseIRRF = 0;
            aliquotaIRRF = 0;
            console.log(`\u{1F4BC} Funcion\xE1rio PJ - Sem desconto de IRRF`);
          } else {
            const numeroDependentes = normalizarDependentes(func.numero_dependentes);
            const pensaoAlimenticia = normalizarPensao(func.pensao_alimenticia);
            const gastosSaude = 0;
            const calculoIRRF = calcularBaseIRRF(
              salarioBase,
              inss,
              numeroDependentes,
              pensaoAlimenticia,
              gastosSaude
            );
            baseIRRF = calculoIRRF.baseIRRF;
            deducoesAplicadas = calculoIRRF.deducoesAplicadas;
            const irrfTabelaNormal = aplicarTabelaProgressivaMensal(baseIRRF);
            const redutorLei15270 = calcularRedutorLei15270(baseIRRF);
            irrf = Math.max(0, round2(irrfTabelaNormal - redutorLei15270));
            aliquotaIRRF = baseIRRF > 0 ? round2(irrf / baseIRRF * 100) : 0;
          }
          let faixaIRRF = "";
          if (tipoContrato === "PJ") {
            faixaIRRF = "pj_sem_irrf";
          } else if (baseIRRF <= 5e3) {
            faixaIRRF = "isencao";
          } else if (baseIRRF <= 7350) {
            faixaIRRF = "reducao_gradual";
          } else {
            faixaIRRF = "sem_reducao";
          }
          console.log(`\u{1F4CA} C\xC1LCULOS MENSAIS:`);
          console.log(`   Tipo Contrato: ${tipoContrato}`);
          console.log(`   Sal\xE1rio Base: R$ ${salarioBase.toFixed(2)}`);
          console.log(`   INSS: R$ ${inss.toFixed(2)} (${aliquotaEfetiva}%)`);
          if (tipoContrato !== "PJ" && deducoesAplicadas) {
            const numeroDependentes = normalizarDependentes(func.numero_dependentes);
            const pensaoAlimenticia = normalizarPensao(func.pensao_alimenticia);
            console.log(`   Dependentes: ${numeroDependentes} \xD7 R$ 189,59 = R$ ${deducoesAplicadas.dependentes.totalDeduzido.toFixed(2)}`);
            console.log(`   Pens\xE3o Aliment\xEDcia: R$ ${pensaoAlimenticia.toFixed(2)}`);
            console.log(`   Base IRRF: R$ ${baseIRRF.toFixed(2)}`);
            if (deducoesAplicadas.baseNegativaAjustada) {
              console.log(`   \u26A0\uFE0F Base ajustada (era negativa): R$ ${deducoesAplicadas.baseCalculada.toFixed(2)} \u2192 R$ ${baseIRRF.toFixed(2)}`);
            }
            const irrfTabelaNormal = aplicarTabelaProgressivaMensal(baseIRRF);
            const redutorLei15270 = calcularRedutorLei15270(baseIRRF);
            console.log(`   IRRF Tabela Normal: R$ ${irrfTabelaNormal.toFixed(2)}`);
            console.log(`   Redutor Lei 15.270: R$ ${redutorLei15270.toFixed(2)}`);
          }
          console.log(`   IRRF Final: R$ ${irrf.toFixed(2)} (${aliquotaIRRF}%)`);
          console.log(`   Faixa: ${faixaIRRF}`);
          console.log(`   Adiantamentos: R$ ${totalAdiantamentos.toFixed(2)}`);
          if (tipoContrato === "PJ") {
            console.log(`   \u{1F4BC} PJ: Sal\xE1rio integral sem descontos obrigat\xF3rios`);
          }
          const dadosMensal = {
            funcionario_id: func.id,
            periodo_inicio: inicio,
            periodo_fim: fim,
            data_pagamento: fim,
            salario_base: salarioBase,
            bonus: 0,
            horas_extras: 0,
            adicional_noturno: 0,
            adicional_periculosidade: 0,
            adicional_insalubridade: 0,
            comissoes: 0,
            inss,
            base_inss: salarioBase,
            aliquota_inss: aliquotaEfetiva,
            irrf,
            base_irrf: baseIRRF,
            aliquota_irrf: aliquotaIRRF,
            vale_transporte: 0,
            cesta_basica_desconto: 0,
            plano_saude: 0,
            plano_odontologico: 0,
            adiantamento: totalAdiantamentos,
            faltas: 0,
            outros_descontos: 0,
            beneficios: [],
            descontos_personalizados: [],
            status: "gerado",
            observacoes: totalAdiantamentos > 0 ? `Folha mensal - Desconto de adiantamento: R$ ${totalAdiantamentos.toFixed(2)}` : "Folha mensal"
          };
          const { data: holerite, error: holeriteError } = await supabase.from("holerites").insert(dadosMensal).select().single();
          if (holeriteError) throw holeriteError;
          const totalProventos = salarioBase;
          const totalDescontos = inss + irrf + totalAdiantamentos;
          const salarioLiquido = totalProventos - totalDescontos;
          await supabase.from("holerites").update({
            total_proventos: totalProventos,
            total_descontos: totalDescontos,
            salario_liquido: salarioLiquido
          }).eq("id", holerite.id);
          console.log(`\u2705 Folha mensal criada:`);
          console.log(`   Proventos: R$ ${totalProventos.toFixed(2)}`);
          console.log(`   Descontos: R$ ${totalDescontos.toFixed(2)}`);
          console.log(`   L\xEDquido: R$ ${salarioLiquido.toFixed(2)}`);
          holeritesCriados.push({
            funcionario: func.nome_completo,
            holerite_id: holerite.id
          });
        }
      } catch (error) {
        console.error(`\u274C Erro ao gerar holerite para ${func.nome_completo}:`, error.message);
        erros.push({
          funcionario: func.nome_completo,
          erro: error.message
        });
      }
    }
    return {
      success: true,
      message: `${holeritesCriados.length} holerite(s) gerado(s) com sucesso`,
      total_gerados: holeritesCriados.length,
      total_erros: erros.length,
      holerites: holeritesCriados,
      erros: erros.length > 0 ? erros : void 0
    };
  } catch (error) {
    console.error("Erro ao gerar holerites:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao gerar holerites"
    });
  }
});

const gerar_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: gerar_post
}, Symbol.toStringTag, { value: 'Module' }));

const index_get$2 = defineEventHandler(async (event) => {
  try {
    console.log("[HOLERITES] Iniciando busca de holerites...");
    const supabase = serverSupabaseServiceRole(event);
    console.log("[HOLERITES] Cliente Supabase criado");
    const { data: holerites, error } = await supabase.from("holerites").select(`
        *,
        funcionarios!inner (
          id,
          nome_completo,
          cpf,
          cargos (
            id,
            nome
          ),
          departamentos (
            id,
            nome
          ),
          empresas (
            id,
            nome,
            nome_fantasia
          )
        )
      `).order("created_at", { ascending: false }).limit(50);
    if (error) {
      console.error("[HOLERITES] Erro na query:", error);
      throw error;
    }
    console.log("[HOLERITES] Holerites encontrados:", (holerites == null ? void 0 : holerites.length) || 0);
    const holeritesTratados = (holerites == null ? void 0 : holerites.map((h) => {
      var _a, _b, _c;
      return {
        ...h,
        funcionario: {
          id: h.funcionarios.id,
          nome_completo: h.funcionarios.nome_completo,
          cpf: h.funcionarios.cpf,
          cargo: ((_a = h.funcionarios.cargos) == null ? void 0 : _a.nome) || "Cargo n\xE3o definido",
          empresa: ((_b = h.funcionarios.empresas) == null ? void 0 : _b.nome_fantasia) || ((_c = h.funcionarios.empresas) == null ? void 0 : _c.nome) || "Empresa n\xE3o definida"
        }
      };
    })) || [];
    console.log("[HOLERITES] Holerites tratados:", holeritesTratados.length);
    return holeritesTratados;
  } catch (error) {
    console.error("[HOLERITES] Erro completo:", {
      message: error.message,
      stack: error.stack,
      details: error.details,
      hint: error.hint,
      code: error.code
    });
    throw createError$2({
      statusCode: 500,
      statusMessage: `Erro ao buscar holerites: ${error.message}`
    });
  }
});

const index_get$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get$2
}, Symbol.toStringTag, { value: 'Module' }));

const _funcionarioId__get = defineEventHandler(async (event) => {
  const funcionarioId = getRouterParam(event, "funcionarioId");
  const supabase = serverSupabaseServiceRole(event);
  try {
    const { data, error } = await supabase.from("holerite_itens_personalizados").select("*").eq("funcionario_id", funcionarioId).order("created_at", { ascending: false });
    if (error) {
      console.error("Erro ao buscar itens personalizados:", error);
      if (error.code === "PGRST205" || error.code === "42P01") {
        return {
          success: true,
          data: [],
          warning: "Tabela holerite_itens_personalizados n\xE3o existe. Execute o SQL de cria\xE7\xE3o."
        };
      }
      throw error;
    }
    return { success: true, data: data || [] };
  } catch (error) {
    console.error("Erro ao buscar itens personalizados:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao buscar itens personalizados"
    });
  }
});

const _funcionarioId__get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _funcionarioId__get
}, Symbol.toStringTag, { value: 'Module' }));

const _id__delete = defineEventHandler(async (event) => {
  const id = getRouterParam(event, "id");
  const supabase = serverSupabaseServiceRole(event);
  try {
    const { error } = await supabase.from("holerite_itens_personalizados").delete().eq("id", id);
    if (error) throw error;
    return { success: true };
  } catch (error) {
    console.error("Erro ao deletar item personalizado:", error);
    throw createError$2({
      statusCode: 500,
      message: error.message
    });
  }
});

const _id__delete$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__delete
}, Symbol.toStringTag, { value: 'Module' }));

const index_post$2 = defineEventHandler(async (event) => {
  const supabase = serverSupabaseServiceRole(event);
  const body = await readBody(event);
  try {
    const { data, error } = await supabase.from("holerite_itens_personalizados").insert([{
      funcionario_id: body.funcionario_id,
      tipo: body.tipo,
      descricao: body.descricao,
      valor: body.valor,
      vigencia_tipo: body.vigencia_tipo,
      data_inicio: body.data_inicio,
      data_fim: body.data_fim || null,
      observacoes: body.observacoes || null,
      ativo: true
    }]).select().single();
    if (error) {
      console.error("Erro ao criar item personalizado:", error);
      if (error.code === "PGRST205" || error.code === "42P01") {
        throw createError$2({
          statusCode: 500,
          message: "Tabela holerite_itens_personalizados n\xE3o existe. Execute o SQL: EXECUTAR-ITENS-PERSONALIZADOS.sql no Supabase SQL Editor."
        });
      }
      throw error;
    }
    return { success: true, data };
  } catch (error) {
    console.error("Erro ao criar item personalizado:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao criar item personalizado"
    });
  }
});

const index_post$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_post$2
}, Symbol.toStringTag, { value: 'Module' }));

const meusHolerites_get = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  const query = getQuery(event);
  const funcionarioId = query.funcionarioId;
  console.log("\u{1F50D} [MEUS-HOLERITES] Requisi\xE7\xE3o recebida");
  console.log("\u{1F50D} [MEUS-HOLERITES] Query params:", query);
  console.log("\u{1F50D} [MEUS-HOLERITES] Funcion\xE1rio ID:", funcionarioId);
  console.log("\u{1F50D} [MEUS-HOLERITES] Headers da requisi\xE7\xE3o:", getHeaders(event));
  if (!funcionarioId) {
    console.error("\u274C [MEUS-HOLERITES] Funcion\xE1rio n\xE3o identificado");
    throw createError$2({
      statusCode: 401,
      message: "Funcion\xE1rio n\xE3o identificado"
    });
  }
  console.log("\u{1F50D} [MEUS-HOLERITES] Buscando holerites para funcion\xE1rio ID:", funcionarioId);
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/holerites?funcionario_id=eq.${funcionarioId}&status=neq.gerado&select=*&order=periodo_inicio.desc`,
      {
        headers: {
          "apikey": serviceRoleKey,
          "Authorization": `Bearer ${serviceRoleKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    console.log("\u{1F4CA} [MEUS-HOLERITES] Status da resposta Supabase:", response.status);
    console.log("\u{1F4CA} [MEUS-HOLERITES] Headers da resposta Supabase:", Object.fromEntries(response.headers.entries()));
    if (!response.ok) {
      const errorText = await response.text();
      console.error("\u274C [MEUS-HOLERITES] Erro ao buscar holerites:", errorText);
      throw new Error("Erro ao buscar holerites");
    }
    const holerites = await response.json();
    console.log("\u{1F4E6} [MEUS-HOLERITES] Holerites encontrados:", holerites.length);
    console.log("\u{1F4E6} [MEUS-HOLERITES] Dados dos holerites:", JSON.stringify(holerites, null, 2));
    console.log('   (Holerites com status "gerado" n\xE3o s\xE3o exibidos)');
    return holerites || [];
  } catch (error) {
    console.error("\u{1F4A5} [MEUS-HOLERITES] Erro ao buscar holerites:", error);
    console.error("\u{1F4A5} [MEUS-HOLERITES] Stack trace:", error.stack);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao buscar holerites"
    });
  }
});

const meusHolerites_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: meusHolerites_get
}, Symbol.toStringTag, { value: 'Module' }));

const _id__get = defineEventHandler(async (event) => {
  try {
    const supabase = serverSupabaseServiceRole(event);
    const id = getRouterParam(event, "id");
    if (!id) {
      throw createError$2({
        statusCode: 400,
        message: "ID da jornada n\xE3o fornecido"
      });
    }
    const { data: jornada, error } = await supabase.from("jornadas_trabalho").select("*").eq("id", id).single();
    if (error) {
      console.error("Erro ao buscar jornada:", error);
      throw error;
    }
    if (!jornada) {
      throw createError$2({
        statusCode: 404,
        message: "Jornada n\xE3o encontrada"
      });
    }
    return jornada;
  } catch (error) {
    console.error("Erro ao buscar jornada:", error);
    throw createError$2({
      statusCode: error.statusCode || 500,
      message: error.message || "Erro ao buscar jornada"
    });
  }
});

const _id__get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _id__get
}, Symbol.toStringTag, { value: 'Module' }));

const index_get = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const supabaseKey = config.public.supabaseKey;
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/jornadas_trabalho?select=*&order=nome.asc`,
      {
        headers: {
          "apikey": supabaseKey,
          "Authorization": `Bearer ${supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    if (!response.ok) {
      throw new Error("Erro ao buscar jornadas");
    }
    const jornadas = await response.json();
    const jornadasComHorarios = await Promise.all(
      jornadas.map(async (jornada) => {
        const horariosResponse = await fetch(
          `${supabaseUrl}/rest/v1/jornada_horarios?jornada_id=eq.${jornada.id}&select=*&order=dia_semana.asc`,
          {
            headers: {
              "apikey": supabaseKey,
              "Authorization": `Bearer ${supabaseKey}`,
              "Content-Type": "application/json"
            }
          }
        );
        const horarios = horariosResponse.ok ? await horariosResponse.json() : [];
        return {
          ...jornada,
          horarios
        };
      })
    );
    return { success: true, data: jornadasComHorarios };
  } catch (error) {
    console.error("Erro ao buscar jornadas:", error);
    throw createError$2({
      statusCode: 500,
      message: "Erro ao buscar jornadas"
    });
  }
});

const index_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_get
}, Symbol.toStringTag, { value: 'Module' }));

const index_post = defineEventHandler(async (event) => {
  const body = await readBody(event);
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const serviceRoleKey = config.supabaseServiceRoleKey || config.public.supabaseKey;
  console.log("\u23F0 Salvando jornada:", JSON.stringify(body, null, 2));
  try {
    let jornadaId = body.id;
    if (jornadaId) {
      console.log("\u{1F504} ATUALIZANDO jornada ID:", jornadaId);
      const { id, horarios, ...dadosJornada } = body;
      console.log("\u{1F4DD} Dados da jornada:", JSON.stringify(dadosJornada, null, 2));
      const response = await fetch(
        `${supabaseUrl}/rest/v1/jornadas_trabalho?id=eq.${jornadaId}`,
        {
          method: "PATCH",
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`,
            "Content-Type": "application/json",
            "Prefer": "return=representation"
          },
          body: JSON.stringify(dadosJornada)
        }
      );
      console.log("\u{1F4CA} Status PATCH:", response.status);
      if (!response.ok) {
        const errorText = await response.text();
        console.error("\u274C Erro ao atualizar:", errorText);
        throw new Error(`Erro ao atualizar jornada: ${errorText}`);
      }
    } else {
      console.log("\u2795 CRIANDO nova jornada");
      const { horarios, ...dadosJornada } = body;
      console.log("\u{1F4DD} Dados da jornada:", JSON.stringify(dadosJornada, null, 2));
      const response = await fetch(
        `${supabaseUrl}/rest/v1/jornadas_trabalho`,
        {
          method: "POST",
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`,
            "Content-Type": "application/json",
            "Prefer": "return=representation"
          },
          body: JSON.stringify(dadosJornada)
        }
      );
      console.log("\u{1F4CA} Status POST:", response.status);
      if (!response.ok) {
        const errorText = await response.text();
        console.error("\u274C Erro ao criar:", errorText);
        throw new Error(`Erro ao criar jornada: ${errorText}`);
      }
      const jornadas = await response.json();
      console.log("\u{1F4E6} Jornada criada:", jornadas);
      jornadaId = jornadas[0].id;
      console.log("\u{1F194} ID da jornada criada:", jornadaId);
    }
    if (body.horarios && Array.isArray(body.horarios)) {
      await fetch(
        `${supabaseUrl}/rest/v1/jornada_horarios?jornada_id=eq.${jornadaId}`,
        {
          method: "DELETE",
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`
          }
        }
      );
      const horariosParaSalvar = body.horarios.map((h) => ({
        jornada_id: jornadaId,
        dia_semana: h.dia_semana,
        entrada: h.entrada,
        saida: h.saida,
        intervalo_inicio: h.intervalo_inicio,
        intervalo_fim: h.intervalo_fim,
        horas_brutas: h.horas_brutas,
        horas_intervalo: h.horas_intervalo,
        horas_liquidas: h.horas_liquidas,
        trabalha: h.trabalha
      }));
      await fetch(
        `${supabaseUrl}/rest/v1/jornada_horarios`,
        {
          method: "POST",
          headers: {
            "apikey": serviceRoleKey,
            "Authorization": `Bearer ${serviceRoleKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(horariosParaSalvar)
        }
      );
    }
    console.log("\u2705 Jornada salva com sucesso!");
    return {
      success: true,
      message: body.id ? "Jornada atualizada com sucesso!" : "Jornada criada com sucesso!",
      data: { id: jornadaId }
    };
  } catch (error) {
    console.error("\u{1F4A5} Erro ao salvar jornada:", error.message);
    throw createError$2({
      statusCode: 500,
      message: error.message || "Erro ao salvar jornada"
    });
  }
});

const index_post$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: index_post
}, Symbol.toStringTag, { value: 'Module' }));

const testSupabase_get = defineEventHandler(async (event) => {
  const config = useRuntimeConfig$1();
  const supabaseUrl = config.public.supabaseUrl;
  const supabaseKey = config.public.supabaseKey;
  const serviceRoleKey = config.supabaseServiceRoleKey;
  const results = {
    config: {
      supabaseUrl: supabaseUrl ? "\u2705 Configurado" : "\u274C N\xE3o configurado",
      supabaseUrlValue: supabaseUrl ? supabaseUrl.substring(0, 30) + "..." : "undefined",
      supabaseKey: supabaseKey ? "\u2705 Configurado" : "\u274C N\xE3o configurado",
      supabaseKeyValue: supabaseKey ? supabaseKey.substring(0, 30) + "..." : "undefined",
      serviceRoleKey: serviceRoleKey ? "\u2705 Configurado" : "\u274C N\xE3o configurado",
      serviceRoleKeyValue: serviceRoleKey ? serviceRoleKey.substring(0, 30) + "..." : "undefined",
      // Mostrar variveis de ambiente diretas
      envCheck: {
        NUXT_PUBLIC_SUPABASE_URL: process.env.NUXT_PUBLIC_SUPABASE_URL ? "Existe" : "N\xE3o existe",
        NUXT_PUBLIC_SUPABASE_KEY: process.env.NUXT_PUBLIC_SUPABASE_KEY ? "Existe" : "N\xE3o existe",
        SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY ? "Existe" : "N\xE3o existe"
      }
    },
    tests: []
  };
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/`,
      {
        headers: {
          "apikey": serviceRoleKey || supabaseKey,
          "Authorization": `Bearer ${serviceRoleKey || supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    results.tests.push({
      test: "Conex\xE3o com Supabase",
      status: response.ok ? "\u2705 OK" : "\u274C Falhou",
      statusCode: response.status
    });
  } catch (error) {
    results.tests.push({
      test: "Conex\xE3o com Supabase",
      status: "\u274C Erro",
      error: error.message
    });
  }
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?select=count`,
      {
        headers: {
          "apikey": serviceRoleKey || supabaseKey,
          "Authorization": `Bearer ${serviceRoleKey || supabaseKey}`,
          "Content-Type": "application/json",
          "Prefer": "count=exact"
        }
      }
    );
    const data = await response.json();
    results.tests.push({
      test: "Tabela funcionarios",
      status: response.ok ? "\u2705 Existe" : "\u274C N\xE3o existe",
      statusCode: response.status,
      data
    });
  } catch (error) {
    results.tests.push({
      test: "Tabela funcionarios",
      status: "\u274C Erro",
      error: error.message
    });
  }
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?email_login=eq.silvana@qualitec.ind.br&select=id,nome_completo,email_login,tipo_acesso,status`,
      {
        headers: {
          "apikey": serviceRoleKey || supabaseKey,
          "Authorization": `Bearer ${serviceRoleKey || supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    const funcionarios = await response.json();
    results.tests.push({
      test: "Buscar Silvana",
      status: funcionarios.length > 0 ? "\u2705 Encontrada" : "\u26A0\uFE0F N\xE3o encontrada",
      statusCode: response.status,
      count: funcionarios.length,
      data: funcionarios
    });
  } catch (error) {
    results.tests.push({
      test: "Buscar Silvana",
      status: "\u274C Erro",
      error: error.message
    });
  }
  try {
    const response = await fetch(
      `${supabaseUrl}/rest/v1/funcionarios?email_login=eq.silvana@qualitec.ind.br&senha=eq.Qualitec2025Silvana&select=id,nome_completo,email_login,tipo_acesso,status`,
      {
        headers: {
          "apikey": serviceRoleKey || supabaseKey,
          "Authorization": `Bearer ${serviceRoleKey || supabaseKey}`,
          "Content-Type": "application/json"
        }
      }
    );
    const funcionarios = await response.json();
    results.tests.push({
      test: "Buscar Silvana com senha",
      status: funcionarios.length > 0 ? "\u2705 Credenciais corretas" : "\u26A0\uFE0F Senha incorreta",
      statusCode: response.status,
      count: funcionarios.length,
      data: funcionarios
    });
  } catch (error) {
    results.tests.push({
      test: "Buscar Silvana com senha",
      status: "\u274C Erro",
      error: error.message
    });
  }
  const tabelas = [
    "empresas",
    "departamentos",
    "cargos",
    "jornadas_trabalho",
    "funcionarios",
    "holerites",
    "funcionario_beneficios",
    "feriados"
  ];
  for (const tabela of tabelas) {
    try {
      const response = await fetch(
        `${supabaseUrl}/rest/v1/${tabela}?select=count&limit=1`,
        {
          headers: {
            "apikey": serviceRoleKey || supabaseKey,
            "Authorization": `Bearer ${serviceRoleKey || supabaseKey}`,
            "Content-Type": "application/json",
            "Prefer": "count=exact"
          }
        }
      );
      results.tests.push({
        test: `Tabela ${tabela}`,
        status: response.ok ? "\u2705 Existe" : "\u274C N\xE3o existe",
        statusCode: response.status
      });
    } catch (error) {
      results.tests.push({
        test: `Tabela ${tabela}`,
        status: "\u274C Erro",
        error: error.message
      });
    }
  }
  return results;
});

const testSupabase_get$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: testSupabase_get
}, Symbol.toStringTag, { value: 'Module' }));

function createRendererContext({ manifest, precomputed, buildAssetsURL }) {
  if (!manifest && !precomputed) {
    throw new Error("Either manifest or precomputed data must be provided");
  }
  const ctx = {
    // Options
    buildAssetsURL: buildAssetsURL || withLeadingSlash,
    manifest,
    precomputed,
    updateManifest,
    // Internal cache
    _dependencies: {},
    _dependencySets: {},
    _entrypoints: []
  };
  function updateManifest(manifest2) {
    const manifestEntries = Object.entries(manifest2);
    ctx.manifest = manifest2;
    ctx._dependencies = {};
    ctx._dependencySets = {};
    ctx._entrypoints = manifestEntries.filter((e) => e[1].isEntry).map(([module]) => module);
  }
  if (precomputed) {
    ctx._dependencies = precomputed.dependencies;
    ctx._entrypoints = precomputed.entrypoints;
  } else if (manifest) {
    updateManifest(manifest);
  }
  return ctx;
}
function getModuleDependencies(id, rendererContext) {
  if (rendererContext._dependencies[id]) {
    return rendererContext._dependencies[id];
  }
  const dependencies = rendererContext._dependencies[id] = {
    scripts: {},
    styles: {},
    preload: {},
    prefetch: {}
  };
  if (!rendererContext.manifest) {
    return dependencies;
  }
  const meta = rendererContext.manifest[id];
  if (!meta) {
    return dependencies;
  }
  if (meta.file) {
    dependencies.preload[id] = meta;
    if (meta.isEntry || meta.sideEffects) {
      dependencies.scripts[id] = meta;
    }
  }
  for (const css of meta.css || []) {
    dependencies.styles[css] = dependencies.preload[css] = dependencies.prefetch[css] = rendererContext.manifest[css];
  }
  for (const asset of meta.assets || []) {
    dependencies.preload[asset] = dependencies.prefetch[asset] = rendererContext.manifest[asset];
  }
  for (const depId of meta.imports || []) {
    const depDeps = getModuleDependencies(depId, rendererContext);
    for (const key in depDeps.styles) {
      dependencies.styles[key] = depDeps.styles[key];
    }
    for (const key in depDeps.preload) {
      dependencies.preload[key] = depDeps.preload[key];
    }
    for (const key in depDeps.prefetch) {
      dependencies.prefetch[key] = depDeps.prefetch[key];
    }
  }
  const filteredPreload = {};
  for (const id2 in dependencies.preload) {
    const dep = dependencies.preload[id2];
    if (dep.preload) {
      filteredPreload[id2] = dep;
    }
  }
  dependencies.preload = filteredPreload;
  return dependencies;
}
function getAllDependencies(ids, rendererContext) {
  let cacheKey = "";
  const sortedIds = [...ids].sort();
  for (let i = 0; i < sortedIds.length; i++) {
    if (i > 0) cacheKey += ",";
    cacheKey += sortedIds[i];
  }
  if (rendererContext._dependencySets[cacheKey]) {
    return rendererContext._dependencySets[cacheKey];
  }
  const allDeps = {
    scripts: {},
    styles: {},
    preload: {},
    prefetch: {}
  };
  for (const id of ids) {
    const deps = getModuleDependencies(id, rendererContext);
    for (const key in deps.scripts) {
      allDeps.scripts[key] = deps.scripts[key];
    }
    for (const key in deps.styles) {
      allDeps.styles[key] = deps.styles[key];
    }
    for (const key in deps.preload) {
      allDeps.preload[key] = deps.preload[key];
    }
    for (const key in deps.prefetch) {
      allDeps.prefetch[key] = deps.prefetch[key];
    }
    for (const dynamicDepId of rendererContext.manifest?.[id]?.dynamicImports || []) {
      const dynamicDeps = getModuleDependencies(dynamicDepId, rendererContext);
      for (const key in dynamicDeps.scripts) {
        allDeps.prefetch[key] = dynamicDeps.scripts[key];
      }
      for (const key in dynamicDeps.styles) {
        allDeps.prefetch[key] = dynamicDeps.styles[key];
      }
      for (const key in dynamicDeps.preload) {
        allDeps.prefetch[key] = dynamicDeps.preload[key];
      }
    }
  }
  const filteredPrefetch = {};
  for (const id in allDeps.prefetch) {
    const dep = allDeps.prefetch[id];
    if (dep.prefetch) {
      filteredPrefetch[id] = dep;
    }
  }
  allDeps.prefetch = filteredPrefetch;
  for (const id in allDeps.preload) {
    delete allDeps.prefetch[id];
  }
  for (const style in allDeps.styles) {
    delete allDeps.preload[style];
    delete allDeps.prefetch[style];
  }
  rendererContext._dependencySets[cacheKey] = allDeps;
  return allDeps;
}
function getRequestDependencies(ssrContext, rendererContext) {
  if (ssrContext._requestDependencies) {
    return ssrContext._requestDependencies;
  }
  const ids = new Set(Array.from([
    ...rendererContext._entrypoints,
    ...ssrContext.modules || ssrContext._registeredComponents || []
  ]));
  const deps = getAllDependencies(ids, rendererContext);
  ssrContext._requestDependencies = deps;
  return deps;
}
function renderStyles(ssrContext, rendererContext) {
  const { styles } = getRequestDependencies(ssrContext, rendererContext);
  let result = "";
  for (const key in styles) {
    const resource = styles[key];
    result += `<link rel="stylesheet" href="${rendererContext.buildAssetsURL(resource.file)}" crossorigin>`;
  }
  return result;
}
function renderResourceHints(ssrContext, rendererContext) {
  const { preload, prefetch } = getRequestDependencies(ssrContext, rendererContext);
  let result = "";
  for (const key in preload) {
    const resource = preload[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    const rel = resource.module ? "modulepreload" : "preload";
    const crossorigin = resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? " crossorigin" : "";
    if (resource.resourceType && resource.mimeType) {
      result += `<link rel="${rel}" as="${resource.resourceType}" type="${resource.mimeType}"${crossorigin} href="${href}">`;
    } else if (resource.resourceType) {
      result += `<link rel="${rel}" as="${resource.resourceType}"${crossorigin} href="${href}">`;
    } else {
      result += `<link rel="${rel}"${crossorigin} href="${href}">`;
    }
  }
  for (const key in prefetch) {
    const resource = prefetch[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    const crossorigin = resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? " crossorigin" : "";
    if (resource.resourceType && resource.mimeType) {
      result += `<link rel="prefetch" as="${resource.resourceType}" type="${resource.mimeType}"${crossorigin} href="${href}">`;
    } else if (resource.resourceType) {
      result += `<link rel="prefetch" as="${resource.resourceType}"${crossorigin} href="${href}">`;
    } else {
      result += `<link rel="prefetch"${crossorigin} href="${href}">`;
    }
  }
  return result;
}
function renderResourceHeaders(ssrContext, rendererContext) {
  const { preload, prefetch } = getRequestDependencies(ssrContext, rendererContext);
  const links = [];
  for (const key in preload) {
    const resource = preload[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    const rel = resource.module ? "modulepreload" : "preload";
    let header = `<${href}>; rel="${rel}"`;
    if (resource.resourceType) {
      header += `; as="${resource.resourceType}"`;
    }
    if (resource.mimeType) {
      header += `; type="${resource.mimeType}"`;
    }
    if (resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module) {
      header += "; crossorigin";
    }
    links.push(header);
  }
  for (const key in prefetch) {
    const resource = prefetch[key];
    const href = rendererContext.buildAssetsURL(resource.file);
    let header = `<${href}>; rel="prefetch"`;
    if (resource.resourceType) {
      header += `; as="${resource.resourceType}"`;
    }
    if (resource.mimeType) {
      header += `; type="${resource.mimeType}"`;
    }
    if (resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module) {
      header += "; crossorigin";
    }
    links.push(header);
  }
  return {
    link: links.join(", ")
  };
}
function getPreloadLinks(ssrContext, rendererContext) {
  const { preload } = getRequestDependencies(ssrContext, rendererContext);
  const result = [];
  for (const key in preload) {
    const resource = preload[key];
    result.push({
      rel: resource.module ? "modulepreload" : "preload",
      as: resource.resourceType,
      type: resource.mimeType ?? null,
      crossorigin: resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? "" : null,
      href: rendererContext.buildAssetsURL(resource.file)
    });
  }
  return result;
}
function getPrefetchLinks(ssrContext, rendererContext) {
  const { prefetch } = getRequestDependencies(ssrContext, rendererContext);
  const result = [];
  for (const key in prefetch) {
    const resource = prefetch[key];
    result.push({
      rel: "prefetch",
      as: resource.resourceType,
      type: resource.mimeType ?? null,
      crossorigin: resource.resourceType === "style" || resource.resourceType === "font" || resource.resourceType === "script" || resource.module ? "" : null,
      href: rendererContext.buildAssetsURL(resource.file)
    });
  }
  return result;
}
function renderScripts(ssrContext, rendererContext) {
  const { scripts } = getRequestDependencies(ssrContext, rendererContext);
  let result = "";
  for (const key in scripts) {
    const resource = scripts[key];
    if (resource.module) {
      result += `<script type="module" src="${rendererContext.buildAssetsURL(resource.file)}" crossorigin><\/script>`;
    } else {
      result += `<script src="${rendererContext.buildAssetsURL(resource.file)}" defer crossorigin><\/script>`;
    }
  }
  return result;
}
function createRenderer$1(createApp, renderOptions) {
  const rendererContext = createRendererContext(renderOptions);
  return {
    rendererContext,
    async renderToString(ssrContext) {
      ssrContext._registeredComponents = ssrContext._registeredComponents || /* @__PURE__ */ new Set();
      const _createApp = await Promise.resolve(createApp).then((r) => "default" in r ? r.default : r);
      const app = await _createApp(ssrContext);
      const html = await renderOptions.renderToString(app, ssrContext);
      const wrap = (fn) => () => fn(ssrContext, rendererContext);
      return {
        html,
        renderResourceHeaders: wrap(renderResourceHeaders),
        renderResourceHints: wrap(renderResourceHints),
        renderStyles: wrap(renderStyles),
        renderScripts: wrap(renderScripts)
      };
    }
  };
}

var vue$1 = {exports: {}};

var vue_cjs_prod = {};

function createMock(name, overrides = {}) {
  const proxyFn = function () {
    /** noop */
  };
  proxyFn.prototype.name = name;
  const props = {};
  const proxy = new Proxy(proxyFn, {
    get(_target, prop) {
      if (prop === "caller") {
        return null;
      }
      if (prop === "__createMock__") {
        return createMock;
      }
      if (prop === "__mock__") {
        return true;
      }
      if (prop in overrides) {
        return overrides[prop];
      }
      if (prop === "then") {
        return (fn) => Promise.resolve(fn());
      }
      if (prop === "catch") {
        return (_fn) => Promise.resolve();
      }
      if (prop === "finally") {
        return (fn) => Promise.resolve(fn());
      }
      return (props[prop] =
        props[prop] || createMock(`${name}.${prop.toString()}`));
    },
    apply(_target, _this, _args) {
      return createMock(`${name}()`);
    },
    construct(_target, _args, _newT) {
      return createMock(`[${name}]`);
    },
    enumerate() {
      return [];
    },
  });
  return proxy;
}

const proxy = createMock("mock");

const proxy$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: proxy
}, Symbol.toStringTag, { value: 'Module' }));

const require$$2 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(proxy$1);

var runtimeDom_cjs_prod = {};

var runtimeCore_cjs_prod = {};

var reactivity_cjs_prod = {};

/**
* @vue/reactivity v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

Object.defineProperty(reactivity_cjs_prod, '__esModule', { value: true });

var shared$2 = shared_cjs_prod;

let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal track `on` calls, allow `on` call multiple times
     */
    this._on = 0;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}

let activeSub;
const EffectFlags = {
  "ACTIVE": 1,
  "1": "ACTIVE",
  "RUNNING": 2,
  "2": "RUNNING",
  "TRACKING": 4,
  "4": "TRACKING",
  "NOTIFIED": 8,
  "8": "NOTIFIED",
  "DIRTY": 16,
  "16": "DIRTY",
  "ALLOW_RECURSE": 32,
  "32": "ALLOW_RECURSE",
  "PAUSED": 64,
  "64": "PAUSED",
  "EVALUATED": 128,
  "128": "EVALUATED"
};
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 1 | 4;
    /**
     * @internal
     */
    this.next = void 0;
    /**
     * @internal
     */
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= -17;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {
    return;
  }
  computed.flags |= 2;
  const dep = computed.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || shared$2.hasChanged(value, computed._value)) {
      computed.flags |= 128;
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    shared$2.extend(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function onEffectCleanup(fn, failSilently = false) {
  if (activeSub instanceof ReactiveEffect) {
    activeSub.cleanup = fn;
  }
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}

let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    /**
     * Link between this dep and the current active effect
     */
    this.activeLink = void 0;
    /**
     * Doubly linked list representing the subscribing effects (tail)
     */
    this.subs = void 0;
    /**
     * For object property deps cleanup
     */
    this.map = void 0;
    this.key = void 0;
    /**
     * Subscriber counter
     */
    this.sc = 0;
    /**
     * @internal
     */
    this.__v_skip = true;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = /* @__PURE__ */ Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = /* @__PURE__ */ Symbol(
  ""
);
const ARRAY_ITERATE_KEY = /* @__PURE__ */ Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = shared$2.isArray(target);
    const isArrayIndex = targetIsArray && shared$2.isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !shared$2.isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (shared$2.isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (shared$2.isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (shared$2.isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}

function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
function toWrapped(target, item) {
  if (isReadonly(target)) {
    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
  }
  return toReactive(item);
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => shared$2.isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toWrapped(this, value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(
      this,
      "filter",
      fn,
      thisArg,
      (v) => v.map((item) => toWrapped(this, item)),
      arguments
    );
  },
  find(fn, thisArg) {
    return apply(
      this,
      "find",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(
      this,
      "findLast",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", (item) => toWrapped(this, item));
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toWrapped(self, item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toWrapped(self, item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}

const isNonTrackableKeys = /* @__PURE__ */ shared$2.makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(shared$2.isSymbol)
);
function hasOwnProperty(key) {
  if (!shared$2.isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = shared$2.isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (shared$2.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value = targetIsArray && shared$2.isIntegerKey(key) ? res : res.value;
      return isReadonly2 && shared$2.isObject(value) ? readonly(value) : value;
    }
    if (shared$2.isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    const isArrayWithIntegerKey = shared$2.isArray(target) && shared$2.isIntegerKey(key);
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return true;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : shared$2.hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (shared$2.hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = shared$2.hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!shared$2.isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      shared$2.isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = shared$2.isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return shared$2.extend(
      // inheriting all iterator properties
      Object.create(innerIterator),
      {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        }
      }
    );
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if (shared$2.hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if (shared$2.hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      !readonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  shared$2.extend(
    instrumentations,
    readonly ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (shared$2.hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0);
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      shared$2.hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(shared$2.toRawType(value));
}
// @__NO_SIDE_EFFECTS__
function reactive(target) {
  if (/* @__PURE__ */ isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
// @__NO_SIDE_EFFECTS__
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
// @__NO_SIDE_EFFECTS__
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
// @__NO_SIDE_EFFECTS__
function shallowReadonly$1(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!shared$2.isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
// @__NO_SIDE_EFFECTS__
function isReactive(value) {
  if (/* @__PURE__ */ isReadonly(value)) {
    return /* @__PURE__ */ isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
// @__NO_SIDE_EFFECTS__
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
// @__NO_SIDE_EFFECTS__
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
// @__NO_SIDE_EFFECTS__
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
// @__NO_SIDE_EFFECTS__
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? /* @__PURE__ */ toRaw(raw) : observed;
}
function markRaw(value) {
  if (!shared$2.hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    shared$2.def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => shared$2.isObject(value) ? /* @__PURE__ */ reactive(value) : value;
const toReadonly = (value) => shared$2.isObject(value) ? /* @__PURE__ */ readonly(value) : value;

// @__NO_SIDE_EFFECTS__
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
// @__NO_SIDE_EFFECTS__
function ref(value) {
  return createRef(value, false);
}
// @__NO_SIDE_EFFECTS__
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (/* @__PURE__ */ isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (shared$2.hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    {
      ref2.dep.trigger();
    }
  }
}
function unref(ref2) {
  return /* @__PURE__ */ isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return shared$2.isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (/* @__PURE__ */ isRef(oldValue) && !/* @__PURE__ */ isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
// @__NO_SIDE_EFFECTS__
function toRefs(object) {
  const ret = shared$2.isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
    this._raw = toRaw(_object);
    let shallow = true;
    let obj = _object;
    if (!shared$2.isArray(_object) || !shared$2.isIntegerKey(String(_key))) {
      do {
        shallow = !isProxy(obj) || isShallow(obj);
      } while (shallow && (obj = obj["__v_raw"]));
    }
    this._shallow = shallow;
  }
  get value() {
    let val = this._object[this._key];
    if (this._shallow) {
      val = unref(val);
    }
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    if (this._shallow && /* @__PURE__ */ isRef(this._raw[this._key])) {
      const nestedRef = this._object[this._key];
      if (/* @__PURE__ */ isRef(nestedRef)) {
        nestedRef.value = newVal;
        return;
      }
    }
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(this._raw, this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
// @__NO_SIDE_EFFECTS__
function toRef(source, key, defaultValue) {
  if (/* @__PURE__ */ isRef(source)) {
    return source;
  } else if (shared$2.isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (shared$2.isObject(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return /* @__PURE__ */ ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  return new ObjectRefImpl(source, key, defaultValue);
}

class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    /**
     * @internal
     */
    this._value = void 0;
    /**
     * @internal
     */
    this.dep = new Dep(this);
    /**
     * @internal
     */
    this.__v_isRef = true;
    // TODO isolatedDeclarations "__v_isReadonly"
    // A computed is also a subscriber that tracks other deps
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 16;
    /**
     * @internal
     */
    this.globalVersion = globalVersion - 1;
    /**
     * @internal
     */
    this.next = void 0;
    // for backwards compat
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
// @__NO_SIDE_EFFECTS__
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (shared$2.isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}

const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw",
  "IS_REF": "__v_isRef"
};

const WatchErrorCodes = {
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = shared$2.EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (shared$2.isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (shared$2.isFunction(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (shared$2.isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = shared$2.NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect.stop();
    if (scope && scope.active) {
      shared$2.remove(scope.effects, effect);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => shared$2.hasChanged(v, oldValue[i])) : shared$2.hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect = new ReactiveEffect(getter);
  effect.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);
  cleanup = effect.onStop = () => {
    const cleanups = cleanupMap.get(effect);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect.run();
  }
  watchHandle.pause = effect.pause.bind(effect);
  watchHandle.resume = effect.resume.bind(effect);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !shared$2.isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Map();
  if ((seen.get(value) || 0) >= depth) {
    return value;
  }
  seen.set(value, depth);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (shared$2.isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (shared$2.isSet(value) || shared$2.isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (shared$2.isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

reactivity_cjs_prod.ARRAY_ITERATE_KEY = ARRAY_ITERATE_KEY;
reactivity_cjs_prod.EffectFlags = EffectFlags;
reactivity_cjs_prod.EffectScope = EffectScope;
reactivity_cjs_prod.ITERATE_KEY = ITERATE_KEY;
reactivity_cjs_prod.MAP_KEY_ITERATE_KEY = MAP_KEY_ITERATE_KEY;
reactivity_cjs_prod.ReactiveEffect = ReactiveEffect;
reactivity_cjs_prod.ReactiveFlags = ReactiveFlags;
reactivity_cjs_prod.TrackOpTypes = TrackOpTypes;
reactivity_cjs_prod.TriggerOpTypes = TriggerOpTypes;
reactivity_cjs_prod.WatchErrorCodes = WatchErrorCodes;
reactivity_cjs_prod.computed = computed$1;
reactivity_cjs_prod.customRef = customRef;
reactivity_cjs_prod.effect = effect;
reactivity_cjs_prod.effectScope = effectScope;
reactivity_cjs_prod.enableTracking = enableTracking;
reactivity_cjs_prod.getCurrentScope = getCurrentScope;
reactivity_cjs_prod.getCurrentWatcher = getCurrentWatcher;
reactivity_cjs_prod.isProxy = isProxy;
reactivity_cjs_prod.isReactive = isReactive;
reactivity_cjs_prod.isReadonly = isReadonly;
reactivity_cjs_prod.isRef = isRef;
reactivity_cjs_prod.isShallow = isShallow;
reactivity_cjs_prod.markRaw = markRaw;
reactivity_cjs_prod.onEffectCleanup = onEffectCleanup;
reactivity_cjs_prod.onScopeDispose = onScopeDispose;
reactivity_cjs_prod.onWatcherCleanup = onWatcherCleanup;
reactivity_cjs_prod.pauseTracking = pauseTracking;
reactivity_cjs_prod.proxyRefs = proxyRefs;
reactivity_cjs_prod.reactive = reactive;
reactivity_cjs_prod.reactiveReadArray = reactiveReadArray;
reactivity_cjs_prod.readonly = readonly;
reactivity_cjs_prod.ref = ref;
reactivity_cjs_prod.resetTracking = resetTracking;
reactivity_cjs_prod.shallowReactive = shallowReactive;
reactivity_cjs_prod.shallowReadArray = shallowReadArray;
reactivity_cjs_prod.shallowReadonly = shallowReadonly$1;
reactivity_cjs_prod.shallowRef = shallowRef;
reactivity_cjs_prod.stop = stop;
reactivity_cjs_prod.toRaw = toRaw;
reactivity_cjs_prod.toReactive = toReactive;
reactivity_cjs_prod.toReadonly = toReadonly;
reactivity_cjs_prod.toRef = toRef;
reactivity_cjs_prod.toRefs = toRefs;
reactivity_cjs_prod.toValue = toValue;
reactivity_cjs_prod.track = track;
reactivity_cjs_prod.traverse = traverse;
reactivity_cjs_prod.trigger = trigger;
reactivity_cjs_prod.triggerRef = triggerRef;
reactivity_cjs_prod.unref = unref;
reactivity_cjs_prod.watch = watch$1;

/**
* @vue/runtime-core v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

Object.defineProperty(runtimeCore_cjs_prod, '__esModule', { value: true });

var reactivity = reactivity_cjs_prod;
var shared$1 = shared_cjs_prod;

function pushWarningContext$1(vnode) {
}
function popWarningContext$1() {
}
function assertNumber(val, type) {
  return;
}

const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (shared$1.isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && shared$1.isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (shared$1.isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || shared$1.EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      reactivity.pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      reactivity.resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}

const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex$1(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex$1(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!shared$1.isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}

let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance$1(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance$1(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance$1(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}

function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = shared$1.EMPTY_OBJ] = directives[i];
    if (dir) {
      if (shared$1.isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        reactivity.traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      reactivity.pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      reactivity.resetTracking();
    }
  }
}

function provide(key, value) {
  if (currentInstance) {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = getCurrentInstance();
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && shared$1.isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
function hasInjectionContext() {
  return !!(getCurrentInstance() || currentApp);
}

const ssrContextKey = /* @__PURE__ */ Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};

function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(
    effect,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect, options) {
  return doWatch(
    effect,
    null,
    { flush: "sync" }
  );
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = shared$1.EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = shared$1.extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = shared$1.NOOP;
      watchStopHandle.resume = shared$1.NOOP;
      watchStopHandle.pause = shared$1.NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = reactivity.watch(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = shared$1.isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (shared$1.isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}

const TeleportEndKey = /* @__PURE__ */ Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (shared$1.isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (parentComponent && parentComponent.isCE) {
            (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
    vnode2.anchor = hydrateChildren(
      nextSibling(node2),
      vnode2,
      parentNode(node2),
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    vnode2.targetStart = targetStart;
    vnode2.targetAnchor = targetAnchor;
  }
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  const disabled = isTeleportDisabled(vnode.props);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        hydrateDisabledTeleport(
          node,
          vnode,
          targetNode,
          targetNode && nextSibling(targetNode)
        );
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  } else if (disabled) {
    if (vnode.shapeFlag & 16) {
      hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}

const leaveCbKey = /* @__PURE__ */ Symbol("_leaveCb");
const enterCbKey = /* @__PURE__ */ Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = reactivity.toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if (shared$1.isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && shared$1.isFunction(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}

// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return shared$1.isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => shared$1.extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}

function useId() {
  const i = getCurrentInstance();
  if (i) {
    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}

function useTemplateRef(key) {
  const i = getCurrentInstance();
  const r = reactivity.shallowRef(null);
  if (i) {
    const refs = i.refs === shared$1.EMPTY_OBJ ? i.refs = {} : i.refs;
    {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  }
  const ret = r;
  return ret;
}

const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (shared$1.isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (shared$1.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === shared$1.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = reactivity.toRaw(setupState);
  const canSetSetupRef = setupState === shared$1.EMPTY_OBJ ? shared$1.NO : (key) => {
    return shared$1.hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref) {
    invalidatePendingSetRef(oldRawRef);
    if (shared$1.isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (reactivity.isRef(oldRef)) {
      {
        oldRef.value = null;
      }
      const oldRawRefAtom = oldRawRef;
      if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
    }
  }
  if (shared$1.isFunction(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = shared$1.isString(ref);
    const _isRef = reactivity.isRef(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value ;
          if (isUnmount) {
            shared$1.isArray(existing) && shared$1.remove(existing, refValue);
          } else {
            if (!shared$1.isArray(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (canSetSetupRef(ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                const newVal = [refValue];
                {
                  ref.value = newVal;
                }
                if (rawRef.k) refs[rawRef.k] = newVal;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (canSetSetupRef(ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          {
            ref.value = value;
          }
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        const job = () => {
          doSet();
          pendingSetRefMap.delete(rawRef);
        };
        job.id = -1;
        pendingSetRefMap.set(rawRef, job);
        queuePostRenderEffect(job, parentSuspense);
      } else {
        invalidatePendingSetRef(rawRef);
        doSet();
      }
    }
  }
}
function invalidatePendingSetRef(rawRef) {
  const pendingSetRef = pendingSetRefMap.get(rawRef);
  if (pendingSetRef) {
    pendingSetRef.flags |= 8;
    pendingSetRefMap.delete(rawRef);
  }
}

let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1) return void 0;
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment$1 = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment$1(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment$1(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else ;
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(
          null,
          // no need check parentSuspense in hydration
          transition
        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          const cls = content.getAttribute("class");
          if (cls) content.$cls = cls;
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          if (!isMismatchAllowed(el, 1 /* CHILDREN */)) {
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        const { textContent } = el;
        if (textContent !== clientText && // innerHTML normalize \r\n or \r into a single \n in the DOM
        textContent !== clientText.replace(/\r\n|\r/g, "\n")) {
          if (!isMismatchAllowed(el, 0 /* TEXT */)) {
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (forcePatch || !optimized || patchFlag & (16 | 32)) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || shared$1.isOn(key) && !shared$1.isReservedProp(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement && !shared$1.isReservedProp(key)) {
              patchProp(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            parentComponent
          );
        } else if (patchFlag & 4 && reactivity.isReactive(props.style)) {
          for (const key in props.style) props.style[key];
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode$1(children[i]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i + 1 < l && normalizeVNode$1(children[i + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(container, 1 /* CHILDREN */)) {
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment$1(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */)) {
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    if (parentComponent) {
      parentComponent.vnode.el = vnode.el;
      updateHOCHostEl(parentComponent, vnode.el);
    }
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment$1(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate, hydrateNode];
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [0 /* TEXT */]: "text",
  [1 /* CHILDREN */]: "children",
  [2 /* CLASS */]: "class",
  [3 /* STYLE */]: "style",
  [4 /* ATTRIBUTE */]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 /* TEXT */ || allowedType === 1 /* CHILDREN */) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 /* TEXT */ && list.includes("children")) {
      return true;
    }
    return list.includes(MismatchTypeString[allowedType]);
  }
}

const requestIdleCallback = shared$1.getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
const cancelIdleCallback = shared$1.getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4) => (hydrate) => {
  const id = requestIdleCallback(hydrate, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      ob.disconnect();
      hydrate();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element)) return;
    if (elementIsVisibleInViewport(el)) {
      hydrate();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate();
    } else {
      mql.addEventListener("change", hydrate, { once: true });
      return () => mql.removeEventListener("change", hydrate);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {
  if (shared$1.isString(interactions)) interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i of interactions) {
        el.removeEventListener(i, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i of interactions) {
      el.addEventListener(i, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment$1(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment$1(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (shared$1.isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      let patched = false;
      (instance.bu || (instance.bu = [])).push(() => patched = true);
      const performHydrate = () => {
        if (patched) {
          return;
        }
        hydrate();
      };
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          performHydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : performHydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = reactivity.ref(false);
      const error = reactivity.ref();
      const delayed = reactivity.ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createInnerComp(
            loadingComponent,
            instance
          );
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          shared$1.invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          shared$1.invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(
          isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : vnode.type
        );
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode$2(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        vnode.shapeFlag &= -257;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (shared$1.isArray(pattern)) {
    return pattern.some((p) => matches(p, name));
  } else if (shared$1.isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (shared$1.isRegExp(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    shared$1.remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= -257;
  vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      reactivity.pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      reactivity.resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}

const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = /* @__PURE__ */ Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (shared$1.isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === shared$1.camelize(name) || selfName === shared$1.capitalize(shared$1.camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[shared$1.camelize(name)] || registry[shared$1.capitalize(shared$1.camelize(name))]);
}

function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  const sourceIsArray = shared$1.isArray(source);
  if (sourceIsArray || shared$1.isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && reactivity.isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !reactivity.isShallow(source);
      isReadonlySource = reactivity.isReadonly(source);
      source = reactivity.shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? reactivity.toReadonly(reactivity.toReactive(source[i])) : reactivity.toReactive(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (shared$1.isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}

function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (shared$1.isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}

function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    const hasProps = Object.keys(props).length > 0;
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      hasProps ? -2 : 64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode$1(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !shared$1.isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode$1(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$2(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode$1(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}

function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : shared$1.toHandlerKey(key)] = obj[key];
  }
  return ret;
}

const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ shared$1.extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i) ,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i) 
  })
);
const hasSetupBinding = (state, key) => state !== shared$1.EMPTY_OBJ && !state.__isScriptSetup && shared$1.hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (data !== shared$1.EMPTY_OBJ && shared$1.hasOwn(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if (shared$1.hasOwn(props, key)) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== shared$1.EMPTY_OBJ && shared$1.hasOwn(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        reactivity.track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== shared$1.EMPTY_OBJ && shared$1.hasOwn(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, shared$1.hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== shared$1.EMPTY_OBJ && shared$1.hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (shared$1.hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, props, type }
  }, key) {
    let cssModules;
    return !!(accessCache[key] || data !== shared$1.EMPTY_OBJ && key[0] !== "$" && shared$1.hasOwn(data, key) || hasSetupBinding(setupState, key) || shared$1.hasOwn(props, key) || shared$1.hasOwn(ctx, key) || shared$1.hasOwn(publicPropertiesMap, key) || shared$1.hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (shared$1.hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ shared$1.extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !shared$1.isGloballyAllowed(key);
    return has;
  }
});

function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext(calledFunctionName) {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return shared$1.isArray(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (shared$1.isArray(opt) || shared$1.isFunction(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if (shared$1.isArray(a) && shared$1.isArray(b)) return a.concat(b);
  return shared$1.extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (shared$1.isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}

let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (shared$1.isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!shared$1.isObject(data)) ; else {
      instance.data = reactivity.reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = shared$1.isFunction(opt) ? opt.bind(publicThis, publicThis) : shared$1.isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : shared$1.NOOP;
      const set = !shared$1.isFunction(opt) && shared$1.isFunction(opt.set) ? opt.set.bind(publicThis) : shared$1.NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = shared$1.isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (shared$1.isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (shared$1.isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val,
          enumerable: true
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === shared$1.NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = shared$1.NOOP) {
  if (shared$1.isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (shared$1.isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (reactivity.isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    shared$1.isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (shared$1.isString(raw)) {
    const handler = ctx[raw];
    if (shared$1.isFunction(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (shared$1.isFunction(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (shared$1.isObject(raw)) {
    if (shared$1.isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = shared$1.isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (shared$1.isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (shared$1.isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions$1(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return (shared$1.extend)(
      shared$1.isFunction(to) ? to.call(this, this) : to,
      shared$1.isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (shared$1.isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? shared$1.extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (shared$1.isArray(to) && shared$1.isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return shared$1.extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = shared$1.extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: shared$1.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!shared$1.isFunction(rootComponent)) {
      rootComponent = shared$1.extend({}, rootComponent);
    }
    if (rootProps != null && !shared$1.isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && shared$1.isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (shared$1.isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;

function useModel(props, name, options = shared$1.EMPTY_OBJ) {
  const i = getCurrentInstance();
  const camelizedName = shared$1.camelize(name);
  const hyphenatedName = shared$1.hyphenate(name);
  const modifiers = getModelModifiers(props, camelizedName);
  const res = reactivity.customRef((track, trigger) => {
    let localValue;
    let prevSetValue = shared$1.EMPTY_OBJ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[camelizedName];
      if (shared$1.hasChanged(localValue, propValue)) {
        localValue = propValue;
        trigger();
      }
    });
    return {
      get() {
        track();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const emittedValue = options.set ? options.set(value) : value;
        if (!shared$1.hasChanged(emittedValue, localValue) && !(prevSetValue !== shared$1.EMPTY_OBJ && shared$1.hasChanged(value, prevSetValue))) {
          return;
        }
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value;
          trigger();
        }
        i.emit(`update:${name}`, emittedValue);
        if (shared$1.hasChanged(value, emittedValue) && shared$1.hasChanged(value, prevSetValue) && !shared$1.hasChanged(emittedValue, prevEmittedValue)) {
          trigger();
        }
        prevSetValue = value;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? modifiers || shared$1.EMPTY_OBJ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${shared$1.camelize(modelName)}Modifiers`] || props[`${shared$1.hyphenate(modelName)}Modifiers`];
};

function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || shared$1.EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modifiers = isModelListener && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => shared$1.isString(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(shared$1.looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = shared$1.toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = shared$1.toHandlerKey(shared$1.camelize(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = shared$1.toHandlerKey(shared$1.hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinEmitsCache : appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!shared$1.isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        shared$1.extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (shared$1.isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (shared$1.isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    shared$1.extend(normalized, raw);
  }
  if (shared$1.isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !shared$1.isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return shared$1.hasOwn(options, key[0].toLowerCase() + key.slice(1)) || shared$1.hasOwn(options, shared$1.hyphenate(key)) || shared$1.hasOwn(options, key);
}

function markAttrsAccessed() {
}
function renderComponentRoot$1(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance$1(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode$1(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode$1(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit
          } : { attrs, slots, emit }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(shared$1.isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance$1(prev);
  return result;
}
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode$2(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || shared$1.isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!shared$1.isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}

const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;

function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : reactivity.shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = reactivity.toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (shared$1.hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = shared$1.camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !shared$1.hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = shared$1.hyphenate(key)) === key || !shared$1.hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !shared$1.hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    reactivity.trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (shared$1.isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && shared$1.hasOwn(options, camelKey = shared$1.camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = reactivity.toRaw(props);
    const castValues = rawCastValues || shared$1.EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !shared$1.hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = shared$1.hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && shared$1.isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === shared$1.hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!shared$1.isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      shared$1.extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (shared$1.isObject(comp)) {
      cache.set(comp, shared$1.EMPTY_ARR);
    }
    return shared$1.EMPTY_ARR;
  }
  if (shared$1.isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = shared$1.camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = shared$1.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = shared$1.camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = shared$1.isArray(opt) || shared$1.isFunction(opt) ? { type: opt } : shared$1.extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (shared$1.isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = shared$1.isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = shared$1.isFunction(propType) && propType.name === "Boolean";
        }
        prop[0 /* shouldCast */] = shouldCast;
        prop[1 /* shouldCastTrue */] = shouldCastTrue;
        if (shouldCast || shared$1.hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (shared$1.isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !shared$1.isReservedProp(key)) {
    return true;
  }
  return false;
}

const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
const normalizeSlotValue = (value) => shared$1.isArray(value) ? value.map(normalizeVNode$1) : [normalizeVNode$1(value)];
const normalizeSlot$2 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (shared$1.isFunction(value)) {
      slots[key] = normalizeSlot$2(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        shared$1.def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = shared$1.EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};

const queuePostRenderEffect = queueEffectWithSuspense ;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = shared$1.getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = shared$1.NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        {
          hostSetText(el, n2.children);
        }
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      const customElement = !!(n1.el && n1.el._isVueCE) ? n1.el : null;
      try {
        if (customElement) {
          customElement._beginPatch();
        }
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } finally {
        if (customElement) {
          customElement._endPatch();
        }
      }
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !shared$1.isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode$1(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || shared$1.EMPTY_OBJ;
    const newProps = n2.props || shared$1.EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== shared$1.EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!shared$1.isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (shared$1.isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren && n1.dynamicChildren.length === dynamicChildren.length) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = (initialVNode.component = createComponentInstance$1(
      initialVNode,
      parentComponent,
      parentSuspense
    ));
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent$1(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
        initialVNode.placeholder = placeholder.el;
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          shared$1.invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot$1(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot$1(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          shared$1.invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot$1(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect = instance.effect = new reactivity.ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect.run.bind(effect);
    const job = instance.job = effect.runIfDirty.bind(effect);
    job.i = instance;
    job.id = instance.uid;
    effect.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    reactivity.pauseTracking();
    flushPreFlushCbs(instance);
    reactivity.resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || shared$1.EMPTY_ARR;
    c2 = c2 || shared$1.EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode$1(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode$1(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode$1(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode$1(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode$1(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared$1.EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchorVNode = c2[nextIndex + 1];
        const anchor = nextIndex + 1 < l2 ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          anchorVNode.el || resolveAsyncComponentPlaceholder(anchorVNode)
        ) : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove2 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          if (el._isLeaving) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref != null) {
      reactivity.pauseTracking();
      setRef(ref, null, parentSuspense, vnode, true);
      reactivity.resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      shared$1.invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    let instance;
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
        instance = container._vnode.component;
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs(instance);
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect, job }, allowed) {
  if (allowed) {
    effect.flags |= 32;
    job.flags |= 4;
  } else {
    effect.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (shared$1.isArray(ch1) && shared$1.isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        if (c2.patchFlag !== -1) {
          c2.el = c1.el;
        } else {
          c2.__elIndex = i + // take fragment start anchor into account
          (n1.type === Fragment ? 1 : 0);
        }
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
function resolveAsyncComponentPlaceholder(anchorVnode) {
  if (anchorVnode.placeholder) {
    return anchorVnode.placeholder;
  }
  const instance = anchorVnode.component;
  if (instance) {
    return resolveAsyncComponentPlaceholder(instance.subTree);
  }
  return null;
}

const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl ;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (shared$1.isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(pendingBranch, newBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? shared$1.toNumber(vnode.props.timeout) : void 0;
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2,
        isInFallback
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
              if (isInFallback && vnode2.ssFallback) {
                vnode2.ssFallback.el = null;
              }
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
          if (!delayEnter && isInFallback && vnode2.ssFallback) {
            queuePostRenderEffect(() => vnode2.ssFallback.el = null, suspense);
          }
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          vnode2.placeholder = null;
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (shared$1.isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (shared$1.isArray(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode$1(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (shared$1.isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}

const Fragment = /* @__PURE__ */ Symbol.for("v-fgt");
const Text = /* @__PURE__ */ Symbol.for("v-txt");
const Comment = /* @__PURE__ */ Symbol.for("v-cmt");
const Static = /* @__PURE__ */ Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared$1.EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode$2(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? shared$1.isString(ref) || reactivity.isRef(ref) || shared$1.isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= shared$1.isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$2(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !shared$1.isString(klass)) {
      props.class = shared$1.normalizeClass(klass);
    }
    if (shared$1.isObject(style)) {
      if (reactivity.isProxy(style) && !shared$1.isArray(style)) {
        style = shared$1.extend({}, style);
      }
      props.style = shared$1.normalizeStyle(style);
    }
  }
  const shapeFlag = shared$1.isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared$1.isObject(type) ? 4 : shared$1.isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return reactivity.isProxy(props) || isInternalObject(props) ? shared$1.extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? shared$1.isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode$1(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (shared$1.isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode$2(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (shared$1.isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (shared$1.isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = shared$1.normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = shared$1.normalizeStyle([ret.style, toMerge.style]);
      } else if (shared$1.isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(shared$1.isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}

const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance$1(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new reactivity.EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: shared$1.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: shared$1.EMPTY_OBJ,
    data: shared$1.EMPTY_OBJ,
    props: shared$1.EMPTY_OBJ,
    attrs: shared$1.EMPTY_OBJ,
    slots: shared$1.EMPTY_OBJ,
    refs: shared$1.EMPTY_OBJ,
    setupState: shared$1.EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = shared$1.getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent$1(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    reactivity.pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = shared$1.isPromise(setupResult);
    reactivity.resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (shared$1.isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (shared$1.isObject(setupResult)) {
    instance.setupState = reactivity.proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = shared$1.extend(
          shared$1.extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || shared$1.NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    const reset = setCurrentInstance(instance);
    reactivity.pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      reactivity.resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    reactivity.track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
function getComponentName(Component, includeInferred = true) {
  return shared$1.isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return shared$1.isFunction(value) && "__vccOpts" in value;
}

const computed = (getterOrOptions, debugOptions) => {
  const c = reactivity.computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};

function h(type, propsOrChildren, children) {
  try {
    setBlockTracking(-1);
    const l = arguments.length;
    if (l === 2) {
      if (shared$1.isObject(propsOrChildren) && !shared$1.isArray(propsOrChildren)) {
        if (isVNode$2(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode$2(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  } finally {
    setBlockTracking(1);
  }
}

function initCustomFormatter() {
  {
    return;
  }
}

function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  ret.cacheIndex = index;
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (shared$1.hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}

const version = "3.5.27";
const warn$1 = shared$1.NOOP;
const ErrorTypeStrings = ErrorTypeStrings$1 ;
const devtools = void 0;
const setDevtoolsHook = shared$1.NOOP;
const _ssrUtils = {
  createComponentInstance: createComponentInstance$1,
  setupComponent: setupComponent$1,
  renderComponentRoot: renderComponentRoot$1,
  setCurrentRenderingInstance: setCurrentRenderingInstance$1,
  isVNode: isVNode$2,
  normalizeVNode: normalizeVNode$1,
  getComponentPublicInstance,
  ensureValidVNode: ensureValidVNode$1,
  pushWarningContext: pushWarningContext$1,
  popWarningContext: popWarningContext$1
};
const ssrUtils = _ssrUtils ;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;

runtimeCore_cjs_prod.EffectScope = reactivity.EffectScope;
runtimeCore_cjs_prod.ReactiveEffect = reactivity.ReactiveEffect;
runtimeCore_cjs_prod.TrackOpTypes = reactivity.TrackOpTypes;
runtimeCore_cjs_prod.TriggerOpTypes = reactivity.TriggerOpTypes;
runtimeCore_cjs_prod.customRef = reactivity.customRef;
runtimeCore_cjs_prod.effect = reactivity.effect;
runtimeCore_cjs_prod.effectScope = reactivity.effectScope;
runtimeCore_cjs_prod.getCurrentScope = reactivity.getCurrentScope;
runtimeCore_cjs_prod.getCurrentWatcher = reactivity.getCurrentWatcher;
runtimeCore_cjs_prod.isProxy = reactivity.isProxy;
runtimeCore_cjs_prod.isReactive = reactivity.isReactive;
runtimeCore_cjs_prod.isReadonly = reactivity.isReadonly;
runtimeCore_cjs_prod.isRef = reactivity.isRef;
runtimeCore_cjs_prod.isShallow = reactivity.isShallow;
runtimeCore_cjs_prod.markRaw = reactivity.markRaw;
runtimeCore_cjs_prod.onScopeDispose = reactivity.onScopeDispose;
runtimeCore_cjs_prod.onWatcherCleanup = reactivity.onWatcherCleanup;
runtimeCore_cjs_prod.proxyRefs = reactivity.proxyRefs;
runtimeCore_cjs_prod.reactive = reactivity.reactive;
runtimeCore_cjs_prod.readonly = reactivity.readonly;
runtimeCore_cjs_prod.ref = reactivity.ref;
runtimeCore_cjs_prod.shallowReactive = reactivity.shallowReactive;
var shallowReadonly = runtimeCore_cjs_prod.shallowReadonly = reactivity.shallowReadonly;
runtimeCore_cjs_prod.shallowRef = reactivity.shallowRef;
runtimeCore_cjs_prod.stop = reactivity.stop;
runtimeCore_cjs_prod.toRaw = reactivity.toRaw;
runtimeCore_cjs_prod.toRef = reactivity.toRef;
runtimeCore_cjs_prod.toRefs = reactivity.toRefs;
runtimeCore_cjs_prod.toValue = reactivity.toValue;
runtimeCore_cjs_prod.triggerRef = reactivity.triggerRef;
runtimeCore_cjs_prod.unref = reactivity.unref;
runtimeCore_cjs_prod.camelize = shared$1.camelize;
runtimeCore_cjs_prod.capitalize = shared$1.capitalize;
runtimeCore_cjs_prod.normalizeClass = shared$1.normalizeClass;
runtimeCore_cjs_prod.normalizeProps = shared$1.normalizeProps;
runtimeCore_cjs_prod.normalizeStyle = shared$1.normalizeStyle;
runtimeCore_cjs_prod.toDisplayString = shared$1.toDisplayString;
runtimeCore_cjs_prod.toHandlerKey = shared$1.toHandlerKey;
runtimeCore_cjs_prod.BaseTransition = BaseTransition;
runtimeCore_cjs_prod.BaseTransitionPropsValidators = BaseTransitionPropsValidators;
runtimeCore_cjs_prod.Comment = Comment;
runtimeCore_cjs_prod.DeprecationTypes = DeprecationTypes;
runtimeCore_cjs_prod.ErrorCodes = ErrorCodes;
runtimeCore_cjs_prod.ErrorTypeStrings = ErrorTypeStrings;
runtimeCore_cjs_prod.Fragment = Fragment;
runtimeCore_cjs_prod.KeepAlive = KeepAlive;
runtimeCore_cjs_prod.Static = Static;
runtimeCore_cjs_prod.Suspense = Suspense;
runtimeCore_cjs_prod.Teleport = Teleport;
runtimeCore_cjs_prod.Text = Text;
runtimeCore_cjs_prod.assertNumber = assertNumber;
runtimeCore_cjs_prod.callWithAsyncErrorHandling = callWithAsyncErrorHandling;
runtimeCore_cjs_prod.callWithErrorHandling = callWithErrorHandling;
runtimeCore_cjs_prod.cloneVNode = cloneVNode;
runtimeCore_cjs_prod.compatUtils = compatUtils;
runtimeCore_cjs_prod.computed = computed;
runtimeCore_cjs_prod.createBlock = createBlock;
runtimeCore_cjs_prod.createCommentVNode = createCommentVNode;
runtimeCore_cjs_prod.createElementBlock = createElementBlock;
runtimeCore_cjs_prod.createElementVNode = createBaseVNode;
runtimeCore_cjs_prod.createHydrationRenderer = createHydrationRenderer;
runtimeCore_cjs_prod.createPropsRestProxy = createPropsRestProxy;
runtimeCore_cjs_prod.createRenderer = createRenderer;
runtimeCore_cjs_prod.createSlots = createSlots;
runtimeCore_cjs_prod.createStaticVNode = createStaticVNode;
runtimeCore_cjs_prod.createTextVNode = createTextVNode;
runtimeCore_cjs_prod.createVNode = createVNode;
runtimeCore_cjs_prod.defineAsyncComponent = defineAsyncComponent;
runtimeCore_cjs_prod.defineComponent = defineComponent;
runtimeCore_cjs_prod.defineEmits = defineEmits;
runtimeCore_cjs_prod.defineExpose = defineExpose;
runtimeCore_cjs_prod.defineModel = defineModel;
runtimeCore_cjs_prod.defineOptions = defineOptions;
runtimeCore_cjs_prod.defineProps = defineProps;
runtimeCore_cjs_prod.defineSlots = defineSlots;
runtimeCore_cjs_prod.devtools = devtools;
runtimeCore_cjs_prod.getCurrentInstance = getCurrentInstance;
runtimeCore_cjs_prod.getTransitionRawChildren = getTransitionRawChildren;
runtimeCore_cjs_prod.guardReactiveProps = guardReactiveProps;
runtimeCore_cjs_prod.h = h;
runtimeCore_cjs_prod.handleError = handleError;
runtimeCore_cjs_prod.hasInjectionContext = hasInjectionContext;
runtimeCore_cjs_prod.hydrateOnIdle = hydrateOnIdle;
runtimeCore_cjs_prod.hydrateOnInteraction = hydrateOnInteraction;
runtimeCore_cjs_prod.hydrateOnMediaQuery = hydrateOnMediaQuery;
runtimeCore_cjs_prod.hydrateOnVisible = hydrateOnVisible;
runtimeCore_cjs_prod.initCustomFormatter = initCustomFormatter;
runtimeCore_cjs_prod.inject = inject;
runtimeCore_cjs_prod.isMemoSame = isMemoSame;
runtimeCore_cjs_prod.isRuntimeOnly = isRuntimeOnly;
runtimeCore_cjs_prod.isVNode = isVNode$2;
runtimeCore_cjs_prod.mergeDefaults = mergeDefaults;
runtimeCore_cjs_prod.mergeModels = mergeModels;
runtimeCore_cjs_prod.mergeProps = mergeProps;
runtimeCore_cjs_prod.nextTick = nextTick;
runtimeCore_cjs_prod.onActivated = onActivated;
runtimeCore_cjs_prod.onBeforeMount = onBeforeMount;
runtimeCore_cjs_prod.onBeforeUnmount = onBeforeUnmount;
runtimeCore_cjs_prod.onBeforeUpdate = onBeforeUpdate;
runtimeCore_cjs_prod.onDeactivated = onDeactivated;
runtimeCore_cjs_prod.onErrorCaptured = onErrorCaptured;
runtimeCore_cjs_prod.onMounted = onMounted;
runtimeCore_cjs_prod.onRenderTracked = onRenderTracked;
runtimeCore_cjs_prod.onRenderTriggered = onRenderTriggered;
runtimeCore_cjs_prod.onServerPrefetch = onServerPrefetch;
runtimeCore_cjs_prod.onUnmounted = onUnmounted;
runtimeCore_cjs_prod.onUpdated = onUpdated;
runtimeCore_cjs_prod.openBlock = openBlock;
runtimeCore_cjs_prod.popScopeId = popScopeId;
runtimeCore_cjs_prod.provide = provide;
runtimeCore_cjs_prod.pushScopeId = pushScopeId;
runtimeCore_cjs_prod.queuePostFlushCb = queuePostFlushCb;
runtimeCore_cjs_prod.registerRuntimeCompiler = registerRuntimeCompiler;
runtimeCore_cjs_prod.renderList = renderList;
runtimeCore_cjs_prod.renderSlot = renderSlot;
runtimeCore_cjs_prod.resolveComponent = resolveComponent;
runtimeCore_cjs_prod.resolveDirective = resolveDirective;
runtimeCore_cjs_prod.resolveDynamicComponent = resolveDynamicComponent;
runtimeCore_cjs_prod.resolveFilter = resolveFilter;
runtimeCore_cjs_prod.resolveTransitionHooks = resolveTransitionHooks;
runtimeCore_cjs_prod.setBlockTracking = setBlockTracking;
runtimeCore_cjs_prod.setDevtoolsHook = setDevtoolsHook;
runtimeCore_cjs_prod.setTransitionHooks = setTransitionHooks;
runtimeCore_cjs_prod.ssrContextKey = ssrContextKey;
runtimeCore_cjs_prod.ssrUtils = ssrUtils;
runtimeCore_cjs_prod.toHandlers = toHandlers;
runtimeCore_cjs_prod.transformVNodeArgs = transformVNodeArgs;
runtimeCore_cjs_prod.useAttrs = useAttrs;
runtimeCore_cjs_prod.useId = useId;
runtimeCore_cjs_prod.useModel = useModel;
runtimeCore_cjs_prod.useSSRContext = useSSRContext;
runtimeCore_cjs_prod.useSlots = useSlots;
runtimeCore_cjs_prod.useTemplateRef = useTemplateRef;
runtimeCore_cjs_prod.useTransitionState = useTransitionState;
runtimeCore_cjs_prod.version = version;
var warn = runtimeCore_cjs_prod.warn = warn$1;
runtimeCore_cjs_prod.watch = watch;
runtimeCore_cjs_prod.watchEffect = watchEffect;
runtimeCore_cjs_prod.watchPostEffect = watchPostEffect;
runtimeCore_cjs_prod.watchSyncEffect = watchSyncEffect;
runtimeCore_cjs_prod.withAsyncContext = withAsyncContext;
runtimeCore_cjs_prod.withCtx = withCtx;
runtimeCore_cjs_prod.withDefaults = withDefaults;
runtimeCore_cjs_prod.withDirectives = withDirectives;
runtimeCore_cjs_prod.withMemo = withMemo;
runtimeCore_cjs_prod.withScopeId = withScopeId;

/**
* @vue/runtime-dom v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

(function (exports$1) {

	Object.defineProperty(exports$1, '__esModule', { value: true });

	var runtimeCore = runtimeCore_cjs_prod;
	var shared = shared_cjs_prod;
	const unsafeToTrustedHTML = (val) => val;
	const svgNS = "http://www.w3.org/2000/svg";
	const mathmlNS = "http://www.w3.org/1998/Math/MathML";
	const doc = typeof document !== "undefined" ? document : null;
	const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
	const nodeOps = {
	  insert: (child, parent, anchor) => {
	    parent.insertBefore(child, anchor || null);
	  },
	  remove: (child) => {
	    const parent = child.parentNode;
	    if (parent) {
	      parent.removeChild(child);
	    }
	  },
	  createElement: (tag, namespace, is, props) => {
	    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
	    if (tag === "select" && props && props.multiple != null) {
	      el.setAttribute("multiple", props.multiple);
	    }
	    return el;
	  },
	  createText: (text) => doc.createTextNode(text),
	  createComment: (text) => doc.createComment(text),
	  setText: (node, text) => {
	    node.nodeValue = text;
	  },
	  setElementText: (el, text) => {
	    el.textContent = text;
	  },
	  parentNode: (node) => node.parentNode,
	  nextSibling: (node) => node.nextSibling,
	  querySelector: (selector) => doc.querySelector(selector),
	  setScopeId(el, id) {
	    el.setAttribute(id, "");
	  },
	  // __UNSAFE__
	  // Reason: innerHTML.
	  // Static content here can only come from compiled templates.
	  // As long as the user only uses trusted templates, this is safe.
	  insertStaticContent(content, parent, anchor, namespace, start, end) {
	    const before = anchor ? anchor.previousSibling : parent.lastChild;
	    if (start && (start === end || start.nextSibling)) {
	      while (true) {
	        parent.insertBefore(start.cloneNode(true), anchor);
	        if (start === end || !(start = start.nextSibling)) break;
	      }
	    } else {
	      templateContainer.innerHTML = unsafeToTrustedHTML(
	        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
	      );
	      const template = templateContainer.content;
	      if (namespace === "svg" || namespace === "mathml") {
	        const wrapper = template.firstChild;
	        while (wrapper.firstChild) {
	          template.appendChild(wrapper.firstChild);
	        }
	        template.removeChild(wrapper);
	      }
	      parent.insertBefore(template, anchor);
	    }
	    return [
	      // first
	      before ? before.nextSibling : parent.firstChild,
	      // last
	      anchor ? anchor.previousSibling : parent.lastChild
	    ];
	  }
	};

	const TRANSITION = "transition";
	const ANIMATION = "animation";
	const vtcKey = /* @__PURE__ */ Symbol("_vtc");
	const DOMTransitionPropsValidators = {
	  name: String,
	  type: String,
	  css: {
	    type: Boolean,
	    default: true
	  },
	  duration: [String, Number, Object],
	  enterFromClass: String,
	  enterActiveClass: String,
	  enterToClass: String,
	  appearFromClass: String,
	  appearActiveClass: String,
	  appearToClass: String,
	  leaveFromClass: String,
	  leaveActiveClass: String,
	  leaveToClass: String
	};
	const TransitionPropsValidators = /* @__PURE__ */ shared.extend(
	  {},
	  runtimeCore.BaseTransitionPropsValidators,
	  DOMTransitionPropsValidators
	);
	const decorate$1 = (t) => {
	  t.displayName = "Transition";
	  t.props = TransitionPropsValidators;
	  return t;
	};
	const Transition = /* @__PURE__ */ decorate$1(
	  (props, { slots }) => runtimeCore.h(runtimeCore.BaseTransition, resolveTransitionProps(props), slots)
	);
	const callHook = (hook, args = []) => {
	  if (shared.isArray(hook)) {
	    hook.forEach((h2) => h2(...args));
	  } else if (hook) {
	    hook(...args);
	  }
	};
	const hasExplicitCallback = (hook) => {
	  return hook ? shared.isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
	};
	function resolveTransitionProps(rawProps) {
	  const baseProps = {};
	  for (const key in rawProps) {
	    if (!(key in DOMTransitionPropsValidators)) {
	      baseProps[key] = rawProps[key];
	    }
	  }
	  if (rawProps.css === false) {
	    return baseProps;
	  }
	  const {
	    name = "v",
	    type,
	    duration,
	    enterFromClass = `${name}-enter-from`,
	    enterActiveClass = `${name}-enter-active`,
	    enterToClass = `${name}-enter-to`,
	    appearFromClass = enterFromClass,
	    appearActiveClass = enterActiveClass,
	    appearToClass = enterToClass,
	    leaveFromClass = `${name}-leave-from`,
	    leaveActiveClass = `${name}-leave-active`,
	    leaveToClass = `${name}-leave-to`
	  } = rawProps;
	  const durations = normalizeDuration(duration);
	  const enterDuration = durations && durations[0];
	  const leaveDuration = durations && durations[1];
	  const {
	    onBeforeEnter,
	    onEnter,
	    onEnterCancelled,
	    onLeave,
	    onLeaveCancelled,
	    onBeforeAppear = onBeforeEnter,
	    onAppear = onEnter,
	    onAppearCancelled = onEnterCancelled
	  } = baseProps;
	  const finishEnter = (el, isAppear, done, isCancelled) => {
	    el._enterCancelled = isCancelled;
	    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
	    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
	    done && done();
	  };
	  const finishLeave = (el, done) => {
	    el._isLeaving = false;
	    removeTransitionClass(el, leaveFromClass);
	    removeTransitionClass(el, leaveToClass);
	    removeTransitionClass(el, leaveActiveClass);
	    done && done();
	  };
	  const makeEnterHook = (isAppear) => {
	    return (el, done) => {
	      const hook = isAppear ? onAppear : onEnter;
	      const resolve = () => finishEnter(el, isAppear, done);
	      callHook(hook, [el, resolve]);
	      nextFrame(() => {
	        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
	        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
	        if (!hasExplicitCallback(hook)) {
	          whenTransitionEnds(el, type, enterDuration, resolve);
	        }
	      });
	    };
	  };
	  return shared.extend(baseProps, {
	    onBeforeEnter(el) {
	      callHook(onBeforeEnter, [el]);
	      addTransitionClass(el, enterFromClass);
	      addTransitionClass(el, enterActiveClass);
	    },
	    onBeforeAppear(el) {
	      callHook(onBeforeAppear, [el]);
	      addTransitionClass(el, appearFromClass);
	      addTransitionClass(el, appearActiveClass);
	    },
	    onEnter: makeEnterHook(false),
	    onAppear: makeEnterHook(true),
	    onLeave(el, done) {
	      el._isLeaving = true;
	      const resolve = () => finishLeave(el, done);
	      addTransitionClass(el, leaveFromClass);
	      if (!el._enterCancelled) {
	        forceReflow(el);
	        addTransitionClass(el, leaveActiveClass);
	      } else {
	        addTransitionClass(el, leaveActiveClass);
	        forceReflow(el);
	      }
	      nextFrame(() => {
	        if (!el._isLeaving) {
	          return;
	        }
	        removeTransitionClass(el, leaveFromClass);
	        addTransitionClass(el, leaveToClass);
	        if (!hasExplicitCallback(onLeave)) {
	          whenTransitionEnds(el, type, leaveDuration, resolve);
	        }
	      });
	      callHook(onLeave, [el, resolve]);
	    },
	    onEnterCancelled(el) {
	      finishEnter(el, false, void 0, true);
	      callHook(onEnterCancelled, [el]);
	    },
	    onAppearCancelled(el) {
	      finishEnter(el, true, void 0, true);
	      callHook(onAppearCancelled, [el]);
	    },
	    onLeaveCancelled(el) {
	      finishLeave(el);
	      callHook(onLeaveCancelled, [el]);
	    }
	  });
	}
	function normalizeDuration(duration) {
	  if (duration == null) {
	    return null;
	  } else if (shared.isObject(duration)) {
	    return [NumberOf(duration.enter), NumberOf(duration.leave)];
	  } else {
	    const n = NumberOf(duration);
	    return [n, n];
	  }
	}
	function NumberOf(val) {
	  const res = shared.toNumber(val);
	  return res;
	}
	function addTransitionClass(el, cls) {
	  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
	  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
	}
	function removeTransitionClass(el, cls) {
	  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
	  const _vtc = el[vtcKey];
	  if (_vtc) {
	    _vtc.delete(cls);
	    if (!_vtc.size) {
	      el[vtcKey] = void 0;
	    }
	  }
	}
	function nextFrame(cb) {
	  requestAnimationFrame(() => {
	    requestAnimationFrame(cb);
	  });
	}
	let endId = 0;
	function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
	  const id = el._endId = ++endId;
	  const resolveIfNotStale = () => {
	    if (id === el._endId) {
	      resolve();
	    }
	  };
	  if (explicitTimeout != null) {
	    return setTimeout(resolveIfNotStale, explicitTimeout);
	  }
	  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
	  if (!type) {
	    return resolve();
	  }
	  const endEvent = type + "end";
	  let ended = 0;
	  const end = () => {
	    el.removeEventListener(endEvent, onEnd);
	    resolveIfNotStale();
	  };
	  const onEnd = (e) => {
	    if (e.target === el && ++ended >= propCount) {
	      end();
	    }
	  };
	  setTimeout(() => {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(endEvent, onEnd);
	}
	function getTransitionInfo(el, expectedType) {
	  const styles = window.getComputedStyle(el);
	  const getStyleProperties = (key) => (styles[key] || "").split(", ");
	  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
	  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
	  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
	  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
	  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
	  const animationTimeout = getTimeout(animationDelays, animationDurations);
	  let type = null;
	  let timeout = 0;
	  let propCount = 0;
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
	    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
	  }
	  const hasTransform = type === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(
	    getStyleProperties(`${TRANSITION}Property`).toString()
	  );
	  return {
	    type,
	    timeout,
	    propCount,
	    hasTransform
	  };
	}
	function getTimeout(delays, durations) {
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }
	  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
	}
	function toMs(s) {
	  if (s === "auto") return 0;
	  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
	}
	function forceReflow(el) {
	  const targetDocument = el ? el.ownerDocument : document;
	  return targetDocument.body.offsetHeight;
	}

	function patchClass(el, value, isSVG) {
	  const transitionClasses = el[vtcKey];
	  if (transitionClasses) {
	    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
	  }
	  if (value == null) {
	    el.removeAttribute("class");
	  } else if (isSVG) {
	    el.setAttribute("class", value);
	  } else {
	    el.className = value;
	  }
	}

	const vShowOriginalDisplay = /* @__PURE__ */ Symbol("_vod");
	const vShowHidden = /* @__PURE__ */ Symbol("_vsh");
	const vShow = {
	  // used for prop mismatch check during hydration
	  name: "show",
	  beforeMount(el, { value }, { transition }) {
	    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
	    if (transition && value) {
	      transition.beforeEnter(el);
	    } else {
	      setDisplay(el, value);
	    }
	  },
	  mounted(el, { value }, { transition }) {
	    if (transition && value) {
	      transition.enter(el);
	    }
	  },
	  updated(el, { value, oldValue }, { transition }) {
	    if (!value === !oldValue) return;
	    if (transition) {
	      if (value) {
	        transition.beforeEnter(el);
	        setDisplay(el, true);
	        transition.enter(el);
	      } else {
	        transition.leave(el, () => {
	          setDisplay(el, false);
	        });
	      }
	    } else {
	      setDisplay(el, value);
	    }
	  },
	  beforeUnmount(el, { value }) {
	    setDisplay(el, value);
	  }
	};
	function setDisplay(el, value) {
	  el.style.display = value ? el[vShowOriginalDisplay] : "none";
	  el[vShowHidden] = !value;
	}
	function initVShowForSSR() {
	  vShow.getSSRProps = ({ value }) => {
	    if (!value) {
	      return { style: { display: "none" } };
	    }
	  };
	}

	const CSS_VAR_TEXT = /* @__PURE__ */ Symbol("");
	function useCssVars(getter) {
	  return;
	}

	const displayRE = /(?:^|;)\s*display\s*:/;
	function patchStyle(el, prev, next) {
	  const style = el.style;
	  const isCssString = shared.isString(next);
	  let hasControlledDisplay = false;
	  if (next && !isCssString) {
	    if (prev) {
	      if (!shared.isString(prev)) {
	        for (const key in prev) {
	          if (next[key] == null) {
	            setStyle(style, key, "");
	          }
	        }
	      } else {
	        for (const prevStyle of prev.split(";")) {
	          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
	          if (next[key] == null) {
	            setStyle(style, key, "");
	          }
	        }
	      }
	    }
	    for (const key in next) {
	      if (key === "display") {
	        hasControlledDisplay = true;
	      }
	      setStyle(style, key, next[key]);
	    }
	  } else {
	    if (isCssString) {
	      if (prev !== next) {
	        const cssVarText = style[CSS_VAR_TEXT];
	        if (cssVarText) {
	          next += ";" + cssVarText;
	        }
	        style.cssText = next;
	        hasControlledDisplay = displayRE.test(next);
	      }
	    } else if (prev) {
	      el.removeAttribute("style");
	    }
	  }
	  if (vShowOriginalDisplay in el) {
	    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
	    if (el[vShowHidden]) {
	      style.display = "none";
	    }
	  }
	}
	const importantRE = /\s*!important$/;
	function setStyle(style, name, val) {
	  if (shared.isArray(val)) {
	    val.forEach((v) => setStyle(style, name, v));
	  } else {
	    if (val == null) val = "";
	    if (name.startsWith("--")) {
	      style.setProperty(name, val);
	    } else {
	      const prefixed = autoPrefix(style, name);
	      if (importantRE.test(val)) {
	        style.setProperty(
	          shared.hyphenate(prefixed),
	          val.replace(importantRE, ""),
	          "important"
	        );
	      } else {
	        style[prefixed] = val;
	      }
	    }
	  }
	}
	const prefixes = ["Webkit", "Moz", "ms"];
	const prefixCache = {};
	function autoPrefix(style, rawName) {
	  const cached = prefixCache[rawName];
	  if (cached) {
	    return cached;
	  }
	  let name = runtimeCore.camelize(rawName);
	  if (name !== "filter" && name in style) {
	    return prefixCache[rawName] = name;
	  }
	  name = shared.capitalize(name);
	  for (let i = 0; i < prefixes.length; i++) {
	    const prefixed = prefixes[i] + name;
	    if (prefixed in style) {
	      return prefixCache[rawName] = prefixed;
	    }
	  }
	  return rawName;
	}

	const xlinkNS = "http://www.w3.org/1999/xlink";
	function patchAttr(el, key, value, isSVG, instance, isBoolean = shared.isSpecialBooleanAttr(key)) {
	  if (isSVG && key.startsWith("xlink:")) {
	    if (value == null) {
	      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (value == null || isBoolean && !shared.includeBooleanAttr(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(
	        key,
	        isBoolean ? "" : shared.isSymbol(value) ? String(value) : value
	      );
	    }
	  }
	}

	function patchDOMProp(el, key, value, parentComponent, attrName) {
	  if (key === "innerHTML" || key === "textContent") {
	    if (value != null) {
	      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
	    }
	    return;
	  }
	  const tag = el.tagName;
	  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
	  !tag.includes("-")) {
	    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
	    const newValue = value == null ? (
	      // #11647: value should be set as empty string for null and undefined,
	      // but <input type="checkbox"> should be set as 'on'.
	      el.type === "checkbox" ? "on" : ""
	    ) : String(value);
	    if (oldValue !== newValue || !("_value" in el)) {
	      el.value = newValue;
	    }
	    if (value == null) {
	      el.removeAttribute(key);
	    }
	    el._value = value;
	    return;
	  }
	  let needRemove = false;
	  if (value === "" || value == null) {
	    const type = typeof el[key];
	    if (type === "boolean") {
	      value = shared.includeBooleanAttr(value);
	    } else if (value == null && type === "string") {
	      value = "";
	      needRemove = true;
	    } else if (type === "number") {
	      value = 0;
	      needRemove = true;
	    }
	  }
	  try {
	    el[key] = value;
	  } catch (e) {
	  }
	  needRemove && el.removeAttribute(attrName || key);
	}

	function addEventListener(el, event, handler, options) {
	  el.addEventListener(event, handler, options);
	}
	function removeEventListener(el, event, handler, options) {
	  el.removeEventListener(event, handler, options);
	}
	const veiKey = /* @__PURE__ */ Symbol("_vei");
	function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
	  const invokers = el[veiKey] || (el[veiKey] = {});
	  const existingInvoker = invokers[rawName];
	  if (nextValue && existingInvoker) {
	    existingInvoker.value = nextValue;
	  } else {
	    const [name, options] = parseName(rawName);
	    if (nextValue) {
	      const invoker = invokers[rawName] = createInvoker(
	        nextValue,
	        instance
	      );
	      addEventListener(el, name, invoker, options);
	    } else if (existingInvoker) {
	      removeEventListener(el, name, existingInvoker, options);
	      invokers[rawName] = void 0;
	    }
	  }
	}
	const optionsModifierRE = /(?:Once|Passive|Capture)$/;
	function parseName(name) {
	  let options;
	  if (optionsModifierRE.test(name)) {
	    options = {};
	    let m;
	    while (m = name.match(optionsModifierRE)) {
	      name = name.slice(0, name.length - m[0].length);
	      options[m[0].toLowerCase()] = true;
	    }
	  }
	  const event = name[2] === ":" ? name.slice(3) : shared.hyphenate(name.slice(2));
	  return [event, options];
	}
	let cachedNow = 0;
	const p = /* @__PURE__ */ Promise.resolve();
	const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
	function createInvoker(initialValue, instance) {
	  const invoker = (e) => {
	    if (!e._vts) {
	      e._vts = Date.now();
	    } else if (e._vts <= invoker.attached) {
	      return;
	    }
	    runtimeCore.callWithAsyncErrorHandling(
	      patchStopImmediatePropagation(e, invoker.value),
	      instance,
	      5,
	      [e]
	    );
	  };
	  invoker.value = initialValue;
	  invoker.attached = getNow();
	  return invoker;
	}
	function patchStopImmediatePropagation(e, value) {
	  if (shared.isArray(value)) {
	    const originalStop = e.stopImmediatePropagation;
	    e.stopImmediatePropagation = () => {
	      originalStop.call(e);
	      e._stopped = true;
	    };
	    return value.map(
	      (fn) => (e2) => !e2._stopped && fn && fn(e2)
	    );
	  } else {
	    return value;
	  }
	}

	const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
	key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
	const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
	  const isSVG = namespace === "svg";
	  if (key === "class") {
	    patchClass(el, nextValue, isSVG);
	  } else if (key === "style") {
	    patchStyle(el, prevValue, nextValue);
	  } else if (shared.isOn(key)) {
	    if (!shared.isModelListener(key)) {
	      patchEvent(el, key, prevValue, nextValue, parentComponent);
	    }
	  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
	    patchDOMProp(el, key, nextValue);
	    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
	      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
	    }
	  } else if (
	    // #11081 force set props for possible async custom element
	    el._isVueCE && (/[A-Z]/.test(key) || !shared.isString(nextValue))
	  ) {
	    patchDOMProp(el, shared.camelize(key), nextValue, parentComponent, key);
	  } else {
	    if (key === "true-value") {
	      el._trueValue = nextValue;
	    } else if (key === "false-value") {
	      el._falseValue = nextValue;
	    }
	    patchAttr(el, key, nextValue, isSVG);
	  }
	};
	function shouldSetAsProp(el, key, value, isSVG) {
	  if (isSVG) {
	    if (key === "innerHTML" || key === "textContent") {
	      return true;
	    }
	    if (key in el && isNativeOn(key) && shared.isFunction(value)) {
	      return true;
	    }
	    return false;
	  }
	  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
	    return false;
	  }
	  if (key === "sandbox" && el.tagName === "IFRAME") {
	    return false;
	  }
	  if (key === "form") {
	    return false;
	  }
	  if (key === "list" && el.tagName === "INPUT") {
	    return false;
	  }
	  if (key === "type" && el.tagName === "TEXTAREA") {
	    return false;
	  }
	  if (key === "width" || key === "height") {
	    const tag = el.tagName;
	    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
	      return false;
	    }
	  }
	  if (isNativeOn(key) && shared.isString(value)) {
	    return false;
	  }
	  return key in el;
	}

	const REMOVAL = {};
	// @__NO_SIDE_EFFECTS__
	function defineCustomElement(options, extraOptions, _createApp) {
	  let Comp = runtimeCore.defineComponent(options, extraOptions);
	  if (shared.isPlainObject(Comp)) Comp = shared.extend({}, Comp, extraOptions);
	  class VueCustomElement extends VueElement {
	    constructor(initialProps) {
	      super(Comp, initialProps, _createApp);
	    }
	  }
	  VueCustomElement.def = Comp;
	  return VueCustomElement;
	}
	const defineSSRCustomElement = (/* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
	  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
	});
	const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
	};
	class VueElement extends BaseClass {
	  constructor(_def, _props = {}, _createApp = createApp) {
	    super();
	    this._def = _def;
	    this._props = _props;
	    this._createApp = _createApp;
	    this._isVueCE = true;
	    /**
	     * @internal
	     */
	    this._instance = null;
	    /**
	     * @internal
	     */
	    this._app = null;
	    /**
	     * @internal
	     */
	    this._nonce = this._def.nonce;
	    this._connected = false;
	    this._resolved = false;
	    this._patching = false;
	    this._dirty = false;
	    this._numberProps = null;
	    this._styleChildren = /* @__PURE__ */ new WeakSet();
	    this._ob = null;
	    if (this.shadowRoot && _createApp !== createApp) {
	      this._root = this.shadowRoot;
	    } else {
	      if (_def.shadowRoot !== false) {
	        this.attachShadow(
	          shared.extend({}, _def.shadowRootOptions, {
	            mode: "open"
	          })
	        );
	        this._root = this.shadowRoot;
	      } else {
	        this._root = this;
	      }
	    }
	  }
	  connectedCallback() {
	    if (!this.isConnected) return;
	    if (!this.shadowRoot && !this._resolved) {
	      this._parseSlots();
	    }
	    this._connected = true;
	    let parent = this;
	    while (parent = parent && (parent.parentNode || parent.host)) {
	      if (parent instanceof VueElement) {
	        this._parent = parent;
	        break;
	      }
	    }
	    if (!this._instance) {
	      if (this._resolved) {
	        this._mount(this._def);
	      } else {
	        if (parent && parent._pendingResolve) {
	          this._pendingResolve = parent._pendingResolve.then(() => {
	            this._pendingResolve = void 0;
	            this._resolveDef();
	          });
	        } else {
	          this._resolveDef();
	        }
	      }
	    }
	  }
	  _setParent(parent = this._parent) {
	    if (parent) {
	      this._instance.parent = parent._instance;
	      this._inheritParentContext(parent);
	    }
	  }
	  _inheritParentContext(parent = this._parent) {
	    if (parent && this._app) {
	      Object.setPrototypeOf(
	        this._app._context.provides,
	        parent._instance.provides
	      );
	    }
	  }
	  disconnectedCallback() {
	    this._connected = false;
	    runtimeCore.nextTick(() => {
	      if (!this._connected) {
	        if (this._ob) {
	          this._ob.disconnect();
	          this._ob = null;
	        }
	        this._app && this._app.unmount();
	        if (this._instance) this._instance.ce = void 0;
	        this._app = this._instance = null;
	        if (this._teleportTargets) {
	          this._teleportTargets.clear();
	          this._teleportTargets = void 0;
	        }
	      }
	    });
	  }
	  _processMutations(mutations) {
	    for (const m of mutations) {
	      this._setAttr(m.attributeName);
	    }
	  }
	  /**
	   * resolve inner component definition (handle possible async component)
	   */
	  _resolveDef() {
	    if (this._pendingResolve) {
	      return;
	    }
	    for (let i = 0; i < this.attributes.length; i++) {
	      this._setAttr(this.attributes[i].name);
	    }
	    this._ob = new MutationObserver(this._processMutations.bind(this));
	    this._ob.observe(this, { attributes: true });
	    const resolve = (def, isAsync = false) => {
	      this._resolved = true;
	      this._pendingResolve = void 0;
	      const { props, styles } = def;
	      let numberProps;
	      if (props && !shared.isArray(props)) {
	        for (const key in props) {
	          const opt = props[key];
	          if (opt === Number || opt && opt.type === Number) {
	            if (key in this._props) {
	              this._props[key] = shared.toNumber(this._props[key]);
	            }
	            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[shared.camelize(key)] = true;
	          }
	        }
	      }
	      this._numberProps = numberProps;
	      this._resolveProps(def);
	      if (this.shadowRoot) {
	        this._applyStyles(styles);
	      }
	      this._mount(def);
	    };
	    const asyncDef = this._def.__asyncLoader;
	    if (asyncDef) {
	      this._pendingResolve = asyncDef().then((def) => {
	        def.configureApp = this._def.configureApp;
	        resolve(this._def = def, true);
	      });
	    } else {
	      resolve(this._def);
	    }
	  }
	  _mount(def) {
	    this._app = this._createApp(def);
	    this._inheritParentContext();
	    if (def.configureApp) {
	      def.configureApp(this._app);
	    }
	    this._app._ceVNode = this._createVNode();
	    this._app.mount(this._root);
	    const exposed = this._instance && this._instance.exposed;
	    if (!exposed) return;
	    for (const key in exposed) {
	      if (!shared.hasOwn(this, key)) {
	        Object.defineProperty(this, key, {
	          // unwrap ref to be consistent with public instance behavior
	          get: () => runtimeCore.unref(exposed[key])
	        });
	      }
	    }
	  }
	  _resolveProps(def) {
	    const { props } = def;
	    const declaredPropKeys = shared.isArray(props) ? props : Object.keys(props || {});
	    for (const key of Object.keys(this)) {
	      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
	        this._setProp(key, this[key]);
	      }
	    }
	    for (const key of declaredPropKeys.map(shared.camelize)) {
	      Object.defineProperty(this, key, {
	        get() {
	          return this._getProp(key);
	        },
	        set(val) {
	          this._setProp(key, val, true, !this._patching);
	        }
	      });
	    }
	  }
	  _setAttr(key) {
	    if (key.startsWith("data-v-")) return;
	    const has = this.hasAttribute(key);
	    let value = has ? this.getAttribute(key) : REMOVAL;
	    const camelKey = shared.camelize(key);
	    if (has && this._numberProps && this._numberProps[camelKey]) {
	      value = shared.toNumber(value);
	    }
	    this._setProp(camelKey, value, false, true);
	  }
	  /**
	   * @internal
	   */
	  _getProp(key) {
	    return this._props[key];
	  }
	  /**
	   * @internal
	   */
	  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
	    if (val !== this._props[key]) {
	      this._dirty = true;
	      if (val === REMOVAL) {
	        delete this._props[key];
	      } else {
	        this._props[key] = val;
	        if (key === "key" && this._app) {
	          this._app._ceVNode.key = val;
	        }
	      }
	      if (shouldUpdate && this._instance) {
	        this._update();
	      }
	      if (shouldReflect) {
	        const ob = this._ob;
	        if (ob) {
	          this._processMutations(ob.takeRecords());
	          ob.disconnect();
	        }
	        if (val === true) {
	          this.setAttribute(shared.hyphenate(key), "");
	        } else if (typeof val === "string" || typeof val === "number") {
	          this.setAttribute(shared.hyphenate(key), val + "");
	        } else if (!val) {
	          this.removeAttribute(shared.hyphenate(key));
	        }
	        ob && ob.observe(this, { attributes: true });
	      }
	    }
	  }
	  _update() {
	    const vnode = this._createVNode();
	    if (this._app) vnode.appContext = this._app._context;
	    render(vnode, this._root);
	  }
	  _createVNode() {
	    const baseProps = {};
	    if (!this.shadowRoot) {
	      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
	    }
	    const vnode = runtimeCore.createVNode(this._def, shared.extend(baseProps, this._props));
	    if (!this._instance) {
	      vnode.ce = (instance) => {
	        this._instance = instance;
	        instance.ce = this;
	        instance.isCE = true;
	        const dispatch = (event, args) => {
	          this.dispatchEvent(
	            new CustomEvent(
	              event,
	              shared.isPlainObject(args[0]) ? shared.extend({ detail: args }, args[0]) : { detail: args }
	            )
	          );
	        };
	        instance.emit = (event, ...args) => {
	          dispatch(event, args);
	          if (shared.hyphenate(event) !== event) {
	            dispatch(shared.hyphenate(event), args);
	          }
	        };
	        this._setParent();
	      };
	    }
	    return vnode;
	  }
	  _applyStyles(styles, owner) {
	    if (!styles) return;
	    if (owner) {
	      if (owner === this._def || this._styleChildren.has(owner)) {
	        return;
	      }
	      this._styleChildren.add(owner);
	    }
	    const nonce = this._nonce;
	    for (let i = styles.length - 1; i >= 0; i--) {
	      const s = document.createElement("style");
	      if (nonce) s.setAttribute("nonce", nonce);
	      s.textContent = styles[i];
	      this.shadowRoot.prepend(s);
	    }
	  }
	  /**
	   * Only called when shadowRoot is false
	   */
	  _parseSlots() {
	    const slots = this._slots = {};
	    let n;
	    while (n = this.firstChild) {
	      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
	      (slots[slotName] || (slots[slotName] = [])).push(n);
	      this.removeChild(n);
	    }
	  }
	  /**
	   * Only called when shadowRoot is false
	   */
	  _renderSlots() {
	    const outlets = this._getSlots();
	    const scopeId = this._instance.type.__scopeId;
	    for (let i = 0; i < outlets.length; i++) {
	      const o = outlets[i];
	      const slotName = o.getAttribute("name") || "default";
	      const content = this._slots[slotName];
	      const parent = o.parentNode;
	      if (content) {
	        for (const n of content) {
	          if (scopeId && n.nodeType === 1) {
	            const id = scopeId + "-s";
	            const walker = document.createTreeWalker(n, 1);
	            n.setAttribute(id, "");
	            let child;
	            while (child = walker.nextNode()) {
	              child.setAttribute(id, "");
	            }
	          }
	          parent.insertBefore(n, o);
	        }
	      } else {
	        while (o.firstChild) parent.insertBefore(o.firstChild, o);
	      }
	      parent.removeChild(o);
	    }
	  }
	  /**
	   * @internal
	   */
	  _getSlots() {
	    const roots = [this];
	    if (this._teleportTargets) {
	      roots.push(...this._teleportTargets);
	    }
	    const slots = /* @__PURE__ */ new Set();
	    for (const root of roots) {
	      const found = root.querySelectorAll("slot");
	      for (let i = 0; i < found.length; i++) {
	        slots.add(found[i]);
	      }
	    }
	    return Array.from(slots);
	  }
	  /**
	   * @internal
	   */
	  _injectChildStyle(comp) {
	    this._applyStyles(comp.styles, comp);
	  }
	  /**
	   * @internal
	   */
	  _beginPatch() {
	    this._patching = true;
	    this._dirty = false;
	  }
	  /**
	   * @internal
	   */
	  _endPatch() {
	    this._patching = false;
	    if (this._dirty && this._instance) {
	      this._update();
	    }
	  }
	  /**
	   * @internal
	   */
	  _removeChildStyle(comp) {
	  }
	}
	function useHost(caller) {
	  const instance = runtimeCore.getCurrentInstance();
	  const el = instance && instance.ce;
	  if (el) {
	    return el;
	  }
	  return null;
	}
	function useShadowRoot() {
	  const el = useHost();
	  return el && el.shadowRoot;
	}

	function useCssModule(name = "$style") {
	  {
	    const instance = runtimeCore.getCurrentInstance();
	    if (!instance) {
	      return shared.EMPTY_OBJ;
	    }
	    const modules = instance.type.__cssModules;
	    if (!modules) {
	      return shared.EMPTY_OBJ;
	    }
	    const mod = modules[name];
	    if (!mod) {
	      return shared.EMPTY_OBJ;
	    }
	    return mod;
	  }
	}

	const positionMap = /* @__PURE__ */ new WeakMap();
	const newPositionMap = /* @__PURE__ */ new WeakMap();
	const moveCbKey = /* @__PURE__ */ Symbol("_moveCb");
	const enterCbKey = /* @__PURE__ */ Symbol("_enterCb");
	const decorate = (t) => {
	  delete t.props.mode;
	  return t;
	};
	const TransitionGroupImpl = /* @__PURE__ */ decorate({
	  name: "TransitionGroup",
	  props: /* @__PURE__ */ shared.extend({}, TransitionPropsValidators, {
	    tag: String,
	    moveClass: String
	  }),
	  setup(props, { slots }) {
	    const instance = runtimeCore.getCurrentInstance();
	    const state = runtimeCore.useTransitionState();
	    let prevChildren;
	    let children;
	    runtimeCore.onUpdated(() => {
	      if (!prevChildren.length) {
	        return;
	      }
	      const moveClass = props.moveClass || `${props.name || "v"}-move`;
	      if (!hasCSSTransform(
	        prevChildren[0].el,
	        instance.vnode.el,
	        moveClass
	      )) {
	        prevChildren = [];
	        return;
	      }
	      prevChildren.forEach(callPendingCbs);
	      prevChildren.forEach(recordPosition);
	      const movedChildren = prevChildren.filter(applyTranslation);
	      forceReflow(instance.vnode.el);
	      movedChildren.forEach((c) => {
	        const el = c.el;
	        const style = el.style;
	        addTransitionClass(el, moveClass);
	        style.transform = style.webkitTransform = style.transitionDuration = "";
	        const cb = el[moveCbKey] = (e) => {
	          if (e && e.target !== el) {
	            return;
	          }
	          if (!e || e.propertyName.endsWith("transform")) {
	            el.removeEventListener("transitionend", cb);
	            el[moveCbKey] = null;
	            removeTransitionClass(el, moveClass);
	          }
	        };
	        el.addEventListener("transitionend", cb);
	      });
	      prevChildren = [];
	    });
	    return () => {
	      const rawProps = runtimeCore.toRaw(props);
	      const cssTransitionProps = resolveTransitionProps(rawProps);
	      let tag = rawProps.tag || runtimeCore.Fragment;
	      prevChildren = [];
	      if (children) {
	        for (let i = 0; i < children.length; i++) {
	          const child = children[i];
	          if (child.el && child.el instanceof Element) {
	            prevChildren.push(child);
	            runtimeCore.setTransitionHooks(
	              child,
	              runtimeCore.resolveTransitionHooks(
	                child,
	                cssTransitionProps,
	                state,
	                instance
	              )
	            );
	            positionMap.set(child, {
	              left: child.el.offsetLeft,
	              top: child.el.offsetTop
	            });
	          }
	        }
	      }
	      children = slots.default ? runtimeCore.getTransitionRawChildren(slots.default()) : [];
	      for (let i = 0; i < children.length; i++) {
	        const child = children[i];
	        if (child.key != null) {
	          runtimeCore.setTransitionHooks(
	            child,
	            runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance)
	          );
	        }
	      }
	      return runtimeCore.createVNode(tag, null, children);
	    };
	  }
	});
	const TransitionGroup = TransitionGroupImpl;
	function callPendingCbs(c) {
	  const el = c.el;
	  if (el[moveCbKey]) {
	    el[moveCbKey]();
	  }
	  if (el[enterCbKey]) {
	    el[enterCbKey]();
	  }
	}
	function recordPosition(c) {
	  newPositionMap.set(c, {
	    left: c.el.offsetLeft,
	    top: c.el.offsetTop
	  });
	}
	function applyTranslation(c) {
	  const oldPos = positionMap.get(c);
	  const newPos = newPositionMap.get(c);
	  const dx = oldPos.left - newPos.left;
	  const dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    const s = c.el.style;
	    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
	    s.transitionDuration = "0s";
	    return c;
	  }
	}
	function hasCSSTransform(el, root, moveClass) {
	  const clone = el.cloneNode();
	  const _vtc = el[vtcKey];
	  if (_vtc) {
	    _vtc.forEach((cls) => {
	      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
	    });
	  }
	  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
	  clone.style.display = "none";
	  const container = root.nodeType === 1 ? root : root.parentNode;
	  container.appendChild(clone);
	  const { hasTransform } = getTransitionInfo(clone);
	  container.removeChild(clone);
	  return hasTransform;
	}

	const getModelAssigner = (vnode) => {
	  const fn = vnode.props["onUpdate:modelValue"] || false;
	  return shared.isArray(fn) ? (value) => shared.invokeArrayFns(fn, value) : fn;
	};
	function onCompositionStart(e) {
	  e.target.composing = true;
	}
	function onCompositionEnd(e) {
	  const target = e.target;
	  if (target.composing) {
	    target.composing = false;
	    target.dispatchEvent(new Event("input"));
	  }
	}
	const assignKey = /* @__PURE__ */ Symbol("_assign");
	function castValue(value, trim, number) {
	  if (trim) value = value.trim();
	  if (number) value = shared.looseToNumber(value);
	  return value;
	}
	const vModelText = {
	  created(el, { modifiers: { lazy, trim, number } }, vnode) {
	    el[assignKey] = getModelAssigner(vnode);
	    const castToNumber = number || vnode.props && vnode.props.type === "number";
	    addEventListener(el, lazy ? "change" : "input", (e) => {
	      if (e.target.composing) return;
	      el[assignKey](castValue(el.value, trim, castToNumber));
	    });
	    if (trim || castToNumber) {
	      addEventListener(el, "change", () => {
	        el.value = castValue(el.value, trim, castToNumber);
	      });
	    }
	    if (!lazy) {
	      addEventListener(el, "compositionstart", onCompositionStart);
	      addEventListener(el, "compositionend", onCompositionEnd);
	      addEventListener(el, "change", onCompositionEnd);
	    }
	  },
	  // set value on mounted so it's after min/max for type="range"
	  mounted(el, { value }) {
	    el.value = value == null ? "" : value;
	  },
	  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
	    el[assignKey] = getModelAssigner(vnode);
	    if (el.composing) return;
	    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? shared.looseToNumber(el.value) : el.value;
	    const newValue = value == null ? "" : value;
	    if (elValue === newValue) {
	      return;
	    }
	    if (document.activeElement === el && el.type !== "range") {
	      if (lazy && value === oldValue) {
	        return;
	      }
	      if (trim && el.value.trim() === newValue) {
	        return;
	      }
	    }
	    el.value = newValue;
	  }
	};
	const vModelCheckbox = {
	  // #4096 array checkboxes need to be deep traversed
	  deep: true,
	  created(el, _, vnode) {
	    el[assignKey] = getModelAssigner(vnode);
	    addEventListener(el, "change", () => {
	      const modelValue = el._modelValue;
	      const elementValue = getValue(el);
	      const checked = el.checked;
	      const assign = el[assignKey];
	      if (shared.isArray(modelValue)) {
	        const index = shared.looseIndexOf(modelValue, elementValue);
	        const found = index !== -1;
	        if (checked && !found) {
	          assign(modelValue.concat(elementValue));
	        } else if (!checked && found) {
	          const filtered = [...modelValue];
	          filtered.splice(index, 1);
	          assign(filtered);
	        }
	      } else if (shared.isSet(modelValue)) {
	        const cloned = new Set(modelValue);
	        if (checked) {
	          cloned.add(elementValue);
	        } else {
	          cloned.delete(elementValue);
	        }
	        assign(cloned);
	      } else {
	        assign(getCheckboxValue(el, checked));
	      }
	    });
	  },
	  // set initial checked on mount to wait for true-value/false-value
	  mounted: setChecked,
	  beforeUpdate(el, binding, vnode) {
	    el[assignKey] = getModelAssigner(vnode);
	    setChecked(el, binding, vnode);
	  }
	};
	function setChecked(el, { value, oldValue }, vnode) {
	  el._modelValue = value;
	  let checked;
	  if (shared.isArray(value)) {
	    checked = shared.looseIndexOf(value, vnode.props.value) > -1;
	  } else if (shared.isSet(value)) {
	    checked = value.has(vnode.props.value);
	  } else {
	    if (value === oldValue) return;
	    checked = shared.looseEqual(value, getCheckboxValue(el, true));
	  }
	  if (el.checked !== checked) {
	    el.checked = checked;
	  }
	}
	const vModelRadio = {
	  created(el, { value }, vnode) {
	    el.checked = shared.looseEqual(value, vnode.props.value);
	    el[assignKey] = getModelAssigner(vnode);
	    addEventListener(el, "change", () => {
	      el[assignKey](getValue(el));
	    });
	  },
	  beforeUpdate(el, { value, oldValue }, vnode) {
	    el[assignKey] = getModelAssigner(vnode);
	    if (value !== oldValue) {
	      el.checked = shared.looseEqual(value, vnode.props.value);
	    }
	  }
	};
	const vModelSelect = {
	  // <select multiple> value need to be deep traversed
	  deep: true,
	  created(el, { value, modifiers: { number } }, vnode) {
	    const isSetModel = shared.isSet(value);
	    addEventListener(el, "change", () => {
	      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
	        (o) => number ? shared.looseToNumber(getValue(o)) : getValue(o)
	      );
	      el[assignKey](
	        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
	      );
	      el._assigning = true;
	      runtimeCore.nextTick(() => {
	        el._assigning = false;
	      });
	    });
	    el[assignKey] = getModelAssigner(vnode);
	  },
	  // set value in mounted & updated because <select> relies on its children
	  // <option>s.
	  mounted(el, { value }) {
	    setSelected(el, value);
	  },
	  beforeUpdate(el, _binding, vnode) {
	    el[assignKey] = getModelAssigner(vnode);
	  },
	  updated(el, { value }) {
	    if (!el._assigning) {
	      setSelected(el, value);
	    }
	  }
	};
	function setSelected(el, value) {
	  const isMultiple = el.multiple;
	  const isArrayValue = shared.isArray(value);
	  if (isMultiple && !isArrayValue && !shared.isSet(value)) {
	    return;
	  }
	  for (let i = 0, l = el.options.length; i < l; i++) {
	    const option = el.options[i];
	    const optionValue = getValue(option);
	    if (isMultiple) {
	      if (isArrayValue) {
	        const optionType = typeof optionValue;
	        if (optionType === "string" || optionType === "number") {
	          option.selected = value.some((v) => String(v) === String(optionValue));
	        } else {
	          option.selected = shared.looseIndexOf(value, optionValue) > -1;
	        }
	      } else {
	        option.selected = value.has(optionValue);
	      }
	    } else if (shared.looseEqual(getValue(option), value)) {
	      if (el.selectedIndex !== i) el.selectedIndex = i;
	      return;
	    }
	  }
	  if (!isMultiple && el.selectedIndex !== -1) {
	    el.selectedIndex = -1;
	  }
	}
	function getValue(el) {
	  return "_value" in el ? el._value : el.value;
	}
	function getCheckboxValue(el, checked) {
	  const key = checked ? "_trueValue" : "_falseValue";
	  return key in el ? el[key] : checked;
	}
	const vModelDynamic = {
	  created(el, binding, vnode) {
	    callModelHook(el, binding, vnode, null, "created");
	  },
	  mounted(el, binding, vnode) {
	    callModelHook(el, binding, vnode, null, "mounted");
	  },
	  beforeUpdate(el, binding, vnode, prevVNode) {
	    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
	  },
	  updated(el, binding, vnode, prevVNode) {
	    callModelHook(el, binding, vnode, prevVNode, "updated");
	  }
	};
	function resolveDynamicModel(tagName, type) {
	  switch (tagName) {
	    case "SELECT":
	      return vModelSelect;
	    case "TEXTAREA":
	      return vModelText;
	    default:
	      switch (type) {
	        case "checkbox":
	          return vModelCheckbox;
	        case "radio":
	          return vModelRadio;
	        default:
	          return vModelText;
	      }
	  }
	}
	function callModelHook(el, binding, vnode, prevVNode, hook) {
	  const modelToUse = resolveDynamicModel(
	    el.tagName,
	    vnode.props && vnode.props.type
	  );
	  const fn = modelToUse[hook];
	  fn && fn(el, binding, vnode, prevVNode);
	}
	function initVModelForSSR() {
	  vModelText.getSSRProps = ({ value }) => ({ value });
	  vModelRadio.getSSRProps = ({ value }, vnode) => {
	    if (vnode.props && shared.looseEqual(vnode.props.value, value)) {
	      return { checked: true };
	    }
	  };
	  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
	    if (shared.isArray(value)) {
	      if (vnode.props && shared.looseIndexOf(value, vnode.props.value) > -1) {
	        return { checked: true };
	      }
	    } else if (shared.isSet(value)) {
	      if (vnode.props && value.has(vnode.props.value)) {
	        return { checked: true };
	      }
	    } else if (value) {
	      return { checked: true };
	    }
	  };
	  vModelDynamic.getSSRProps = (binding, vnode) => {
	    if (typeof vnode.type !== "string") {
	      return;
	    }
	    const modelToUse = resolveDynamicModel(
	      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
	      vnode.type.toUpperCase(),
	      vnode.props && vnode.props.type
	    );
	    if (modelToUse.getSSRProps) {
	      return modelToUse.getSSRProps(binding, vnode);
	    }
	  };
	}

	const systemModifiers = ["ctrl", "shift", "alt", "meta"];
	const modifierGuards = {
	  stop: (e) => e.stopPropagation(),
	  prevent: (e) => e.preventDefault(),
	  self: (e) => e.target !== e.currentTarget,
	  ctrl: (e) => !e.ctrlKey,
	  shift: (e) => !e.shiftKey,
	  alt: (e) => !e.altKey,
	  meta: (e) => !e.metaKey,
	  left: (e) => "button" in e && e.button !== 0,
	  middle: (e) => "button" in e && e.button !== 1,
	  right: (e) => "button" in e && e.button !== 2,
	  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
	};
	const withModifiers = (fn, modifiers) => {
	  const cache = fn._withMods || (fn._withMods = {});
	  const cacheKey = modifiers.join(".");
	  return cache[cacheKey] || (cache[cacheKey] = ((event, ...args) => {
	    for (let i = 0; i < modifiers.length; i++) {
	      const guard = modifierGuards[modifiers[i]];
	      if (guard && guard(event, modifiers)) return;
	    }
	    return fn(event, ...args);
	  }));
	};
	const keyNames = {
	  esc: "escape",
	  space: " ",
	  up: "arrow-up",
	  left: "arrow-left",
	  right: "arrow-right",
	  down: "arrow-down",
	  delete: "backspace"
	};
	const withKeys = (fn, modifiers) => {
	  const cache = fn._withKeys || (fn._withKeys = {});
	  const cacheKey = modifiers.join(".");
	  return cache[cacheKey] || (cache[cacheKey] = ((event) => {
	    if (!("key" in event)) {
	      return;
	    }
	    const eventKey = shared.hyphenate(event.key);
	    if (modifiers.some(
	      (k) => k === eventKey || keyNames[k] === eventKey
	    )) {
	      return fn(event);
	    }
	  }));
	};

	const rendererOptions = /* @__PURE__ */ shared.extend({ patchProp }, nodeOps);
	let renderer;
	let enabledHydration = false;
	function ensureRenderer() {
	  return renderer || (renderer = runtimeCore.createRenderer(rendererOptions));
	}
	function ensureHydrationRenderer() {
	  renderer = enabledHydration ? renderer : runtimeCore.createHydrationRenderer(rendererOptions);
	  enabledHydration = true;
	  return renderer;
	}
	const render = ((...args) => {
	  ensureRenderer().render(...args);
	});
	const hydrate = ((...args) => {
	  ensureHydrationRenderer().hydrate(...args);
	});
	const createApp = ((...args) => {
	  const app = ensureRenderer().createApp(...args);
	  const { mount } = app;
	  app.mount = (containerOrSelector) => {
	    const container = normalizeContainer(containerOrSelector);
	    if (!container) return;
	    const component = app._component;
	    if (!shared.isFunction(component) && !component.render && !component.template) {
	      component.template = container.innerHTML;
	    }
	    if (container.nodeType === 1) {
	      container.textContent = "";
	    }
	    const proxy = mount(container, false, resolveRootNamespace(container));
	    if (container instanceof Element) {
	      container.removeAttribute("v-cloak");
	      container.setAttribute("data-v-app", "");
	    }
	    return proxy;
	  };
	  return app;
	});
	const createSSRApp = ((...args) => {
	  const app = ensureHydrationRenderer().createApp(...args);
	  const { mount } = app;
	  app.mount = (containerOrSelector) => {
	    const container = normalizeContainer(containerOrSelector);
	    if (container) {
	      return mount(container, true, resolveRootNamespace(container));
	    }
	  };
	  return app;
	});
	function resolveRootNamespace(container) {
	  if (container instanceof SVGElement) {
	    return "svg";
	  }
	  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
	    return "mathml";
	  }
	}
	function normalizeContainer(container) {
	  if (shared.isString(container)) {
	    const res = document.querySelector(container);
	    return res;
	  }
	  return container;
	}
	let ssrDirectiveInitialized = false;
	const initDirectivesForSSR = () => {
	  if (!ssrDirectiveInitialized) {
	    ssrDirectiveInitialized = true;
	    initVModelForSSR();
	    initVShowForSSR();
	  }
	} ;

	exports$1.Transition = Transition;
	exports$1.TransitionGroup = TransitionGroup;
	exports$1.VueElement = VueElement;
	exports$1.createApp = createApp;
	exports$1.createSSRApp = createSSRApp;
	exports$1.defineCustomElement = defineCustomElement;
	exports$1.defineSSRCustomElement = defineSSRCustomElement;
	exports$1.hydrate = hydrate;
	exports$1.initDirectivesForSSR = initDirectivesForSSR;
	exports$1.nodeOps = nodeOps;
	exports$1.patchProp = patchProp;
	exports$1.render = render;
	exports$1.useCssModule = useCssModule;
	exports$1.useCssVars = useCssVars;
	exports$1.useHost = useHost;
	exports$1.useShadowRoot = useShadowRoot;
	exports$1.vModelCheckbox = vModelCheckbox;
	exports$1.vModelDynamic = vModelDynamic;
	exports$1.vModelRadio = vModelRadio;
	exports$1.vModelSelect = vModelSelect;
	exports$1.vModelText = vModelText;
	exports$1.vShow = vShow;
	exports$1.withKeys = withKeys;
	exports$1.withModifiers = withModifiers;
	Object.keys(runtimeCore).forEach(function (k) {
	  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports$1, k)) exports$1[k] = runtimeCore[k];
	}); 
} (runtimeDom_cjs_prod));

/**
* vue v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

(function (exports$1) {

	Object.defineProperty(exports$1, '__esModule', { value: true });

	var compilerDom = require$$2;
	var runtimeDom = runtimeDom_cjs_prod;
	var shared = shared_cjs_prod;

	function _interopNamespaceDefault(e) {
	  var n = Object.create(null);
	  if (e) {
	    for (var k in e) {
	      n[k] = e[k];
	    }
	  }
	  n.default = e;
	  return Object.freeze(n);
	}

	var runtimeDom__namespace = /*#__PURE__*/_interopNamespaceDefault(runtimeDom);

	const compileCache = /* @__PURE__ */ Object.create(null);
	function compileToFunction(template, options) {
	  if (!shared.isString(template)) {
	    if (template.nodeType) {
	      template = template.innerHTML;
	    } else {
	      return shared.NOOP;
	    }
	  }
	  const key = shared.genCacheKey(template, options);
	  const cached = compileCache[key];
	  if (cached) {
	    return cached;
	  }
	  if (template[0] === "#") {
	    const el = document.querySelector(template);
	    template = el ? el.innerHTML : ``;
	  }
	  const opts = shared.extend(
	    {
	      hoistStatic: true,
	      onError: void 0,
	      onWarn: shared.NOOP
	    },
	    options
	  );
	  if (!opts.isCustomElement && typeof customElements !== "undefined") {
	    opts.isCustomElement = (tag) => !!customElements.get(tag);
	  }
	  const { code } = compilerDom.compile(template, opts);
	  const render = new Function("Vue", code)(runtimeDom__namespace);
	  render._rc = true;
	  return compileCache[key] = render;
	}
	runtimeDom.registerRuntimeCompiler(compileToFunction);

	exports$1.compile = compileToFunction;
	Object.keys(runtimeDom).forEach(function (k) {
	  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports$1, k)) exports$1[k] = runtimeDom[k];
	}); 
} (vue_cjs_prod));

{
  vue$1.exports = vue_cjs_prod;
}

var vueExports = vue$1.exports;

const vue = /*#__PURE__*/_mergeNamespaces({
  __proto__: null
}, [vueExports]);

const VueResolver = (_, value) => {
  return vueExports.isRef(value) ? vueExports.toValue(value) : value;
};

const headSymbol = "usehead";
// @__NO_SIDE_EFFECTS__
function vueInstall(head) {
  const plugin = {
    install(app) {
      app.config.globalProperties.$unhead = head;
      app.config.globalProperties.$head = head;
      app.provide(headSymbol, head);
    }
  };
  return plugin.install;
}

// @__NO_SIDE_EFFECTS__
function injectHead$1() {
  if (vueExports.hasInjectionContext()) {
    const instance = vueExports.inject(headSymbol);
    if (!instance) {
      throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
    }
    return instance;
  }
  throw new Error("useHead() was called without provide context, ensure you call it through the setup() function.");
}
function useHead$1(input, options = {}) {
  const head = options.head || /* @__PURE__ */ injectHead$1();
  return head.ssr ? head.push(input || {}, options) : clientUseHead(head, input, options);
}
function clientUseHead(head, input, options = {}) {
  const deactivated = vueExports.ref(false);
  let entry;
  vueExports.watchEffect(() => {
    const i = deactivated.value ? {} : walkResolver(input, VueResolver);
    if (entry) {
      entry.patch(i);
    } else {
      entry = head.push(i, options);
    }
  });
  const vm = vueExports.getCurrentInstance();
  if (vm) {
    vueExports.onBeforeUnmount(() => {
      entry.dispose();
    });
    vueExports.onDeactivated(() => {
      deactivated.value = true;
    });
    vueExports.onActivated(() => {
      deactivated.value = false;
    });
  }
  return entry;
}

// @__NO_SIDE_EFFECTS__
function createHead(options = {}) {
  const head = createHead$1({
    ...options,
    propResolvers: [VueResolver]
  });
  head.install = vueInstall(head);
  return head;
}

var serverRenderer_cjs_prod = {};

const require$$0 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(vue);

const require$$3 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(node_stream);

/**
* @vue/server-renderer v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

Object.defineProperty(serverRenderer_cjs_prod, '__esModule', { value: true });

var Vue = require$$0;
var shared = shared_cjs_prod;
var compilerSsr = require$$2;

function _interopNamespaceDefault$1(e) {
  var n = Object.create(null);
  if (e) {
    for (var k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return Object.freeze(n);
}

var Vue__namespace = /*#__PURE__*/_interopNamespaceDefault$1(Vue);

const shouldIgnoreProp = /* @__PURE__ */ shared.makeMap(
  `,key,ref,innerHTML,textContent,ref_key,ref_for`
);
function ssrRenderAttrs(props, tag) {
  let ret = "";
  for (let key in props) {
    if (shouldIgnoreProp(key) || shared.isOn(key) || tag === "textarea" && key === "value" || // force as property (not rendered in SSR)
    key.startsWith(".")) {
      continue;
    }
    const value = props[key];
    if (key.startsWith("^")) key = key.slice(1);
    if (key === "class" || key === "className") {
      ret += ` class="${ssrRenderClass(value)}"`;
    } else if (key === "style") {
      ret += ` style="${ssrRenderStyle(value)}"`;
    } else {
      ret += ssrRenderDynamicAttr(key, value, tag);
    }
  }
  return ret;
}
function ssrRenderDynamicAttr(key, value, tag) {
  if (!shared.isRenderableAttrValue(value)) {
    return ``;
  }
  const attrKey = tag && (tag.indexOf("-") > 0 || shared.isSVGTag(tag)) ? key : shared.propsToAttrMap[key] || key.toLowerCase();
  if (shared.isBooleanAttr(attrKey)) {
    return shared.includeBooleanAttr(value) ? ` ${attrKey}` : ``;
  } else if (shared.isSSRSafeAttrName(attrKey)) {
    return value === "" ? ` ${attrKey}` : ` ${attrKey}="${shared.escapeHtml(value)}"`;
  } else {
    console.warn(
      `[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`
    );
    return ``;
  }
}
function ssrRenderAttr(key, value) {
  if (!shared.isRenderableAttrValue(value)) {
    return ``;
  }
  return ` ${key}="${shared.escapeHtml(value)}"`;
}
function ssrRenderClass(raw) {
  return shared.escapeHtml(shared.normalizeClass(raw));
}
function ssrRenderStyle(raw) {
  if (!raw) {
    return "";
  }
  if (shared.isString(raw)) {
    return shared.escapeHtml(raw);
  }
  const styles = shared.normalizeStyle(ssrResetCssVars(raw));
  return shared.escapeHtml(shared.stringifyStyle(styles));
}
function ssrResetCssVars(raw) {
  if (!shared.isArray(raw) && shared.isObject(raw)) {
    const res = {};
    for (const key in raw) {
      if (key.startsWith(":--")) {
        res[key.slice(1)] = shared.normalizeCssVarValue(raw[key]);
      } else {
        res[key] = raw[key];
      }
    }
    return res;
  }
  return raw;
}

function ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {
  return renderComponentVNode(
    Vue.createVNode(comp, props, children),
    parentComponent,
    slotScopeId
  );
}

const { ensureValidVNode } = Vue.ssrUtils;
function ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {
  push(`<!--[-->`);
  ssrRenderSlotInner(
    slots,
    slotName,
    slotProps,
    fallbackRenderFn,
    push,
    parentComponent,
    slotScopeId
  );
  push(`<!--]-->`);
}
function ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {
  const slotFn = slots[slotName];
  if (slotFn) {
    const slotBuffer = [];
    const bufferedPush = (item) => {
      slotBuffer.push(item);
    };
    const ret = slotFn(
      slotProps,
      bufferedPush,
      parentComponent,
      slotScopeId ? " " + slotScopeId : ""
    );
    if (shared.isArray(ret)) {
      const validSlotContent = ensureValidVNode(ret);
      if (validSlotContent) {
        renderVNodeChildren(
          push,
          validSlotContent,
          parentComponent,
          slotScopeId
        );
      } else if (fallbackRenderFn) {
        fallbackRenderFn();
      } else if (transition) {
        push(`<!---->`);
      }
    } else {
      let isEmptySlot = true;
      if (transition) {
        isEmptySlot = false;
      } else {
        for (let i = 0; i < slotBuffer.length; i++) {
          if (!isComment(slotBuffer[i])) {
            isEmptySlot = false;
            break;
          }
        }
      }
      if (isEmptySlot) {
        if (fallbackRenderFn) {
          fallbackRenderFn();
        }
      } else {
        let start = 0;
        let end = slotBuffer.length;
        if (transition && slotBuffer[0] === "<!--[-->" && slotBuffer[end - 1] === "<!--]-->") {
          start++;
          end--;
        }
        if (start < end) {
          for (let i = start; i < end; i++) {
            push(slotBuffer[i]);
          }
        } else if (transition) {
          push(`<!---->`);
        }
      }
    }
  } else if (fallbackRenderFn) {
    fallbackRenderFn();
  } else if (transition) {
    push(`<!---->`);
  }
}
const commentTestRE = /^<!--[\s\S]*-->$/;
const commentRE = /<!--[^]*?-->/gm;
function isComment(item) {
  if (typeof item !== "string" || !commentTestRE.test(item)) return false;
  if (item.length <= 8) return true;
  return !item.replace(commentRE, "").trim();
}

function ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {
  parentPush("<!--teleport start-->");
  const context = parentComponent.appContext.provides[Vue.ssrContextKey];
  const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});
  const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);
  const bufferIndex = targetBuffer.length;
  let teleportContent;
  if (disabled) {
    contentRenderFn(parentPush);
    teleportContent = `<!--teleport start anchor--><!--teleport anchor-->`;
  } else {
    const { getBuffer, push } = createBuffer();
    push(`<!--teleport start anchor-->`);
    contentRenderFn(push);
    push(`<!--teleport anchor-->`);
    teleportContent = getBuffer();
  }
  targetBuffer.splice(bufferIndex, 0, teleportContent);
  parentPush("<!--teleport end-->");
}

function ssrInterpolate(value) {
  return shared.escapeHtml(shared.toDisplayString(value));
}

function ssrRenderList(source, renderItem) {
  if (shared.isArray(source) || shared.isString(source)) {
    for (let i = 0, l = source.length; i < l; i++) {
      renderItem(source[i], i);
    }
  } else if (typeof source === "number") {
    for (let i = 0; i < source; i++) {
      renderItem(i + 1, i);
    }
  } else if (shared.isObject(source)) {
    if (source[Symbol.iterator]) {
      const arr = Array.from(source);
      for (let i = 0, l = arr.length; i < l; i++) {
        renderItem(arr[i], i);
      }
    } else {
      const keys = Object.keys(source);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        renderItem(source[key], key, i);
      }
    }
  }
}

async function ssrRenderSuspense(push, { default: renderContent }) {
  if (renderContent) {
    renderContent();
  } else {
    push(`<!---->`);
  }
}

function ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {
  if (typeof dir !== "function" && dir.getSSRProps) {
    return dir.getSSRProps(
      {
        dir,
        instance: Vue.ssrUtils.getComponentPublicInstance(instance.$),
        value,
        oldValue: void 0,
        arg,
        modifiers
      },
      null
    ) || {};
  }
  return {};
}

const ssrLooseEqual = shared.looseEqual;
function ssrLooseContain(arr, value) {
  return shared.looseIndexOf(arr, value) > -1;
}
function ssrRenderDynamicModel(type, model, value) {
  switch (type) {
    case "radio":
      return shared.looseEqual(model, value) ? " checked" : "";
    case "checkbox":
      return (shared.isArray(model) ? ssrLooseContain(model, value) : model) ? " checked" : "";
    default:
      return ssrRenderAttr("value", model);
  }
}
function ssrGetDynamicModelProps(existingProps = {}, model) {
  const { type, value } = existingProps;
  switch (type) {
    case "radio":
      return shared.looseEqual(model, value) ? { checked: true } : null;
    case "checkbox":
      return (shared.isArray(model) ? ssrLooseContain(model, value) : model) ? { checked: true } : null;
    default:
      return { value: model };
  }
}

var helpers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ssrGetDirectiveProps: ssrGetDirectiveProps,
  ssrGetDynamicModelProps: ssrGetDynamicModelProps,
  ssrIncludeBooleanAttr: shared.includeBooleanAttr,
  ssrInterpolate: ssrInterpolate,
  ssrLooseContain: ssrLooseContain,
  ssrLooseEqual: ssrLooseEqual,
  ssrRenderAttr: ssrRenderAttr,
  ssrRenderAttrs: ssrRenderAttrs,
  ssrRenderClass: ssrRenderClass,
  ssrRenderComponent: ssrRenderComponent,
  ssrRenderDynamicAttr: ssrRenderDynamicAttr,
  ssrRenderDynamicModel: ssrRenderDynamicModel,
  ssrRenderList: ssrRenderList,
  ssrRenderSlot: ssrRenderSlot,
  ssrRenderSlotInner: ssrRenderSlotInner,
  ssrRenderStyle: ssrRenderStyle,
  ssrRenderSuspense: ssrRenderSuspense,
  ssrRenderTeleport: ssrRenderTeleport,
  ssrRenderVNode: renderVNode
});

const compileCache = /* @__PURE__ */ Object.create(null);
function ssrCompile(template, instance) {
  const Component = instance.type;
  const { isCustomElement, compilerOptions } = instance.appContext.config;
  const { delimiters, compilerOptions: componentCompilerOptions } = Component;
  const finalCompilerOptions = shared.extend(
    shared.extend(
      {
        isCustomElement,
        delimiters
      },
      compilerOptions
    ),
    componentCompilerOptions
  );
  finalCompilerOptions.isCustomElement = finalCompilerOptions.isCustomElement || shared.NO;
  finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || shared.NO;
  const cacheKey = JSON.stringify(
    {
      template,
      compilerOptions: finalCompilerOptions
    },
    (key, value) => {
      return shared.isFunction(value) ? value.toString() : value;
    }
  );
  const cached = compileCache[cacheKey];
  if (cached) {
    return cached;
  }
  finalCompilerOptions.onError = (err) => {
    {
      throw err;
    }
  };
  const { code } = compilerSsr.compile(template, finalCompilerOptions);
  const requireMap = {
    vue: Vue__namespace,
    "vue/server-renderer": helpers
  };
  const fakeRequire = (id) => requireMap[id];
  return compileCache[cacheKey] = Function("require", code)(fakeRequire);
}

const {
  createComponentInstance,
  setCurrentRenderingInstance,
  setupComponent,
  renderComponentRoot,
  normalizeVNode,
  pushWarningContext,
  popWarningContext
} = Vue.ssrUtils;
function createBuffer() {
  let appendable = false;
  const buffer = [];
  return {
    getBuffer() {
      return buffer;
    },
    push(item) {
      const isStringItem = shared.isString(item);
      if (appendable && isStringItem) {
        buffer[buffer.length - 1] += item;
        return;
      }
      buffer.push(item);
      appendable = isStringItem;
      if (shared.isPromise(item) || shared.isArray(item) && item.hasAsync) {
        buffer.hasAsync = true;
      }
    }
  };
}
function renderComponentVNode(vnode, parentComponent = null, slotScopeId) {
  const instance = vnode.component = createComponentInstance(
    vnode,
    parentComponent,
    null
  );
  const res = setupComponent(
    instance,
    true
    /* isSSR */
  );
  const hasAsyncSetup = shared.isPromise(res);
  let prefetches = instance.sp;
  if (hasAsyncSetup || prefetches) {
    const p = Promise.resolve(res).then(() => {
      if (hasAsyncSetup) prefetches = instance.sp;
      if (prefetches) {
        return Promise.all(
          prefetches.map((prefetch) => prefetch.call(instance.proxy))
        );
      }
    }).catch(shared.NOOP);
    return p.then(() => renderComponentSubTree(instance, slotScopeId));
  } else {
    return renderComponentSubTree(instance, slotScopeId);
  }
}
function renderComponentSubTree(instance, slotScopeId) {
  const comp = instance.type;
  const { getBuffer, push } = createBuffer();
  if (shared.isFunction(comp)) {
    let root = renderComponentRoot(instance);
    if (!comp.props) {
      for (const key in instance.attrs) {
        if (key.startsWith(`data-v-`)) {
          (root.props || (root.props = {}))[key] = ``;
        }
      }
    }
    renderVNode(push, instance.subTree = root, instance, slotScopeId);
  } else {
    if ((!instance.render || instance.render === shared.NOOP) && !instance.ssrRender && !comp.ssrRender && shared.isString(comp.template)) {
      comp.ssrRender = ssrCompile(comp.template, instance);
    }
    const ssrRender = instance.ssrRender || comp.ssrRender;
    if (ssrRender) {
      let attrs = instance.inheritAttrs !== false ? instance.attrs : void 0;
      let hasCloned = false;
      let cur = instance;
      while (true) {
        const scopeId = cur.vnode.scopeId;
        if (scopeId) {
          if (!hasCloned) {
            attrs = { ...attrs };
            hasCloned = true;
          }
          attrs[scopeId] = "";
        }
        const parent = cur.parent;
        if (parent && parent.subTree && parent.subTree === cur.vnode) {
          cur = parent;
        } else {
          break;
        }
      }
      if (slotScopeId) {
        if (!hasCloned) attrs = { ...attrs };
        const slotScopeIdList = slotScopeId.trim().split(" ");
        for (let i = 0; i < slotScopeIdList.length; i++) {
          attrs[slotScopeIdList[i]] = "";
        }
      }
      const prev = setCurrentRenderingInstance(instance);
      try {
        ssrRender(
          instance.proxy,
          push,
          instance,
          attrs,
          // compiler-optimized bindings
          instance.props,
          instance.setupState,
          instance.data,
          instance.ctx
        );
      } finally {
        setCurrentRenderingInstance(prev);
      }
    } else if (instance.render && instance.render !== shared.NOOP) {
      renderVNode(
        push,
        instance.subTree = renderComponentRoot(instance),
        instance,
        slotScopeId
      );
    } else {
      const componentName = comp.name || comp.__file || `<Anonymous>`;
      Vue.warn(`Component ${componentName} is missing template or render function.`);
      push(`<!---->`);
    }
  }
  return getBuffer();
}
function renderVNode(push, vnode, parentComponent, slotScopeId) {
  const { type, shapeFlag, children, dirs, props } = vnode;
  if (dirs) {
    vnode.props = applySSRDirectives(vnode, props, dirs);
  }
  switch (type) {
    case Vue.Text:
      push(shared.escapeHtml(children));
      break;
    case Vue.Comment:
      push(
        children ? `<!--${shared.escapeHtmlComment(children)}-->` : `<!---->`
      );
      break;
    case Vue.Static:
      push(children);
      break;
    case Vue.Fragment:
      if (vnode.slotScopeIds) {
        slotScopeId = (slotScopeId ? slotScopeId + " " : "") + vnode.slotScopeIds.join(" ");
      }
      push(`<!--[-->`);
      renderVNodeChildren(
        push,
        children,
        parentComponent,
        slotScopeId
      );
      push(`<!--]-->`);
      break;
    default:
      if (shapeFlag & 1) {
        renderElementVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 6) {
        push(renderComponentVNode(vnode, parentComponent, slotScopeId));
      } else if (shapeFlag & 64) {
        renderTeleportVNode(push, vnode, parentComponent, slotScopeId);
      } else if (shapeFlag & 128) {
        renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);
      } else {
        Vue.warn(
          "[@vue/server-renderer] Invalid VNode type:",
          type,
          `(${typeof type})`
        );
      }
  }
}
function renderVNodeChildren(push, children, parentComponent, slotScopeId) {
  for (let i = 0; i < children.length; i++) {
    renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);
  }
}
function renderElementVNode(push, vnode, parentComponent, slotScopeId) {
  const tag = vnode.type;
  let { props, children, shapeFlag, scopeId } = vnode;
  let openTag = `<${tag}`;
  if (props) {
    openTag += ssrRenderAttrs(props, tag);
  }
  if (scopeId) {
    openTag += ` ${scopeId}`;
  }
  let curParent = parentComponent;
  let curVnode = vnode;
  while (curParent && curVnode === curParent.subTree) {
    curVnode = curParent.vnode;
    if (curVnode.scopeId) {
      openTag += ` ${curVnode.scopeId}`;
    }
    curParent = curParent.parent;
  }
  if (slotScopeId) {
    openTag += ` ${slotScopeId}`;
  }
  push(openTag + `>`);
  if (!shared.isVoidTag(tag)) {
    let hasChildrenOverride = false;
    if (props) {
      if (props.innerHTML) {
        hasChildrenOverride = true;
        push(props.innerHTML);
      } else if (props.textContent) {
        hasChildrenOverride = true;
        push(shared.escapeHtml(props.textContent));
      } else if (tag === "textarea" && props.value) {
        hasChildrenOverride = true;
        push(shared.escapeHtml(props.value));
      }
    }
    if (!hasChildrenOverride) {
      if (shapeFlag & 8) {
        push(shared.escapeHtml(children));
      } else if (shapeFlag & 16) {
        renderVNodeChildren(
          push,
          children,
          parentComponent,
          slotScopeId
        );
      }
    }
    push(`</${tag}>`);
  }
}
function applySSRDirectives(vnode, rawProps, dirs) {
  const toMerge = [];
  for (let i = 0; i < dirs.length; i++) {
    const binding = dirs[i];
    const {
      dir: { getSSRProps }
    } = binding;
    if (getSSRProps) {
      const props = getSSRProps(binding, vnode);
      if (props) toMerge.push(props);
    }
  }
  return Vue.mergeProps(rawProps || {}, ...toMerge);
}
function renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {
  const target = vnode.props && vnode.props.to;
  const disabled = vnode.props && vnode.props.disabled;
  if (!target) {
    if (!disabled) {
      Vue.warn(`[@vue/server-renderer] Teleport is missing target prop.`);
    }
    return [];
  }
  if (!shared.isString(target)) {
    Vue.warn(
      `[@vue/server-renderer] Teleport target must be a query selector string.`
    );
    return [];
  }
  ssrRenderTeleport(
    push,
    (push2) => {
      renderVNodeChildren(
        push2,
        vnode.children,
        parentComponent,
        slotScopeId
      );
    },
    target,
    disabled || disabled === "",
    parentComponent
  );
}

const { isVNode: isVNode$1 } = Vue.ssrUtils;
function nestedUnrollBuffer(buffer, parentRet, startIndex) {
  if (!buffer.hasAsync) {
    return parentRet + unrollBufferSync$1(buffer);
  }
  let ret = parentRet;
  for (let i = startIndex; i < buffer.length; i += 1) {
    const item = buffer[i];
    if (shared.isString(item)) {
      ret += item;
      continue;
    }
    if (shared.isPromise(item)) {
      return item.then((nestedItem) => {
        buffer[i] = nestedItem;
        return nestedUnrollBuffer(buffer, ret, i);
      });
    }
    const result = nestedUnrollBuffer(item, ret, 0);
    if (shared.isPromise(result)) {
      return result.then((nestedItem) => {
        buffer[i] = nestedItem;
        return nestedUnrollBuffer(buffer, "", i);
      });
    }
    ret = result;
  }
  return ret;
}
function unrollBuffer$1(buffer) {
  return nestedUnrollBuffer(buffer, "", 0);
}
function unrollBufferSync$1(buffer) {
  let ret = "";
  for (let i = 0; i < buffer.length; i++) {
    let item = buffer[i];
    if (shared.isString(item)) {
      ret += item;
    } else {
      ret += unrollBufferSync$1(item);
    }
  }
  return ret;
}
async function renderToString(input, context = {}) {
  if (isVNode$1(input)) {
    return renderToString(Vue.createApp({ render: () => input }), context);
  }
  const vnode = Vue.createVNode(input._component, input._props);
  vnode.appContext = input._context;
  input.provide(Vue.ssrContextKey, context);
  const buffer = await renderComponentVNode(vnode);
  const result = await unrollBuffer$1(buffer);
  await resolveTeleports(context);
  if (context.__watcherHandles) {
    for (const unwatch of context.__watcherHandles) {
      unwatch();
    }
  }
  return result;
}
async function resolveTeleports(context) {
  if (context.__teleportBuffers) {
    context.teleports = context.teleports || {};
    for (const key in context.__teleportBuffers) {
      context.teleports[key] = await unrollBuffer$1(
        await Promise.all([context.__teleportBuffers[key]])
      );
    }
  }
}

const { isVNode } = Vue.ssrUtils;
async function unrollBuffer(buffer, stream) {
  if (buffer.hasAsync) {
    for (let i = 0; i < buffer.length; i++) {
      let item = buffer[i];
      if (shared.isPromise(item)) {
        item = await item;
      }
      if (shared.isString(item)) {
        stream.push(item);
      } else {
        await unrollBuffer(item, stream);
      }
    }
  } else {
    unrollBufferSync(buffer, stream);
  }
}
function unrollBufferSync(buffer, stream) {
  for (let i = 0; i < buffer.length; i++) {
    let item = buffer[i];
    if (shared.isString(item)) {
      stream.push(item);
    } else {
      unrollBufferSync(item, stream);
    }
  }
}
function renderToSimpleStream(input, context, stream) {
  if (isVNode(input)) {
    return renderToSimpleStream(
      Vue.createApp({ render: () => input }),
      context,
      stream
    );
  }
  const vnode = Vue.createVNode(input._component, input._props);
  vnode.appContext = input._context;
  input.provide(Vue.ssrContextKey, context);
  Promise.resolve(renderComponentVNode(vnode)).then((buffer) => unrollBuffer(buffer, stream)).then(() => resolveTeleports(context)).then(() => {
    if (context.__watcherHandles) {
      for (const unwatch of context.__watcherHandles) {
        unwatch();
      }
    }
  }).then(() => stream.push(null)).catch((error) => {
    stream.destroy(error);
  });
  return stream;
}
function renderToStream(input, context = {}) {
  console.warn(
    `[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`
  );
  return renderToNodeStream(input, context);
}
function renderToNodeStream(input, context = {}) {
  const stream = new (require$$3).Readable({ read() {
  } }) ;
  if (!stream) {
    throw new Error(
      `ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.`
    );
  }
  return renderToSimpleStream(input, context, stream);
}
function pipeToNodeWritable(input, context = {}, writable) {
  renderToSimpleStream(input, context, {
    push(content) {
      if (content != null) {
        writable.write(content);
      } else {
        writable.end();
      }
    },
    destroy(err) {
      writable.destroy(err);
    }
  });
}
function renderToWebStream(input, context = {}) {
  if (typeof ReadableStream !== "function") {
    throw new Error(
      `ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.`
    );
  }
  const encoder = new TextEncoder();
  let cancelled = false;
  return new ReadableStream({
    start(controller) {
      renderToSimpleStream(input, context, {
        push(content) {
          if (cancelled) return;
          if (content != null) {
            controller.enqueue(encoder.encode(content));
          } else {
            controller.close();
          }
        },
        destroy(err) {
          controller.error(err);
        }
      });
    },
    cancel() {
      cancelled = true;
    }
  });
}
function pipeToWebWritable(input, context = {}, writable) {
  const writer = writable.getWriter();
  const encoder = new TextEncoder();
  let hasReady = false;
  try {
    hasReady = shared.isPromise(writer.ready);
  } catch (e) {
  }
  renderToSimpleStream(input, context, {
    async push(content) {
      if (hasReady) {
        await writer.ready;
      }
      if (content != null) {
        return writer.write(encoder.encode(content));
      } else {
        return writer.close();
      }
    },
    destroy(err) {
      console.log(err);
      writer.close();
    }
  });
}

Vue.initDirectivesForSSR();

var ssrIncludeBooleanAttr = serverRenderer_cjs_prod.ssrIncludeBooleanAttr = shared.includeBooleanAttr;
serverRenderer_cjs_prod.pipeToNodeWritable = pipeToNodeWritable;
serverRenderer_cjs_prod.pipeToWebWritable = pipeToWebWritable;
serverRenderer_cjs_prod.renderToNodeStream = renderToNodeStream;
serverRenderer_cjs_prod.renderToSimpleStream = renderToSimpleStream;
serverRenderer_cjs_prod.renderToStream = renderToStream;
var renderToString_1 = serverRenderer_cjs_prod.renderToString = renderToString;
serverRenderer_cjs_prod.renderToWebStream = renderToWebStream;
serverRenderer_cjs_prod.ssrGetDirectiveProps = ssrGetDirectiveProps;
serverRenderer_cjs_prod.ssrGetDynamicModelProps = ssrGetDynamicModelProps;
var ssrInterpolate_1 = serverRenderer_cjs_prod.ssrInterpolate = ssrInterpolate;
var ssrLooseContain_1 = serverRenderer_cjs_prod.ssrLooseContain = ssrLooseContain;
var ssrLooseEqual_1 = serverRenderer_cjs_prod.ssrLooseEqual = ssrLooseEqual;
var ssrRenderAttr_1 = serverRenderer_cjs_prod.ssrRenderAttr = ssrRenderAttr;
var ssrRenderAttrs_1 = serverRenderer_cjs_prod.ssrRenderAttrs = ssrRenderAttrs;
var ssrRenderClass_1 = serverRenderer_cjs_prod.ssrRenderClass = ssrRenderClass;
var ssrRenderComponent_1 = serverRenderer_cjs_prod.ssrRenderComponent = ssrRenderComponent;
serverRenderer_cjs_prod.ssrRenderDynamicAttr = ssrRenderDynamicAttr;
serverRenderer_cjs_prod.ssrRenderDynamicModel = ssrRenderDynamicModel;
var ssrRenderList_1 = serverRenderer_cjs_prod.ssrRenderList = ssrRenderList;
var ssrRenderSlot_1 = serverRenderer_cjs_prod.ssrRenderSlot = ssrRenderSlot;
serverRenderer_cjs_prod.ssrRenderSlotInner = ssrRenderSlotInner;
var ssrRenderStyle_1 = serverRenderer_cjs_prod.ssrRenderStyle = ssrRenderStyle;
var ssrRenderSuspense_1 = serverRenderer_cjs_prod.ssrRenderSuspense = ssrRenderSuspense;
var ssrRenderTeleport_1 = serverRenderer_cjs_prod.ssrRenderTeleport = ssrRenderTeleport;
var ssrRenderVNode = serverRenderer_cjs_prod.ssrRenderVNode = renderVNode;

const appHead = {"meta":[{"charset":"utf-8"},{"name":"viewport","content":"width=device-width, initial-scale=1"},{"name":"description","content":"Sistema Interno de Gesto de Recursos Humanos - Qualitec Instrumentos"},{"name":"robots","content":"noindex, nofollow"}],"link":[{"rel":"icon","type":"image/x-icon","href":"/favicon.ico"}],"style":[],"script":[],"noscript":[],"title":"Sistema Corporativo - Qualitec Instrumentos"};

const appRootTag = "div";

const appRootAttrs = {"id":"__nuxt"};

const appTeleportTag = "div";

const appTeleportAttrs = {"id":"teleports"};

const appSpaLoaderTag = "div";

const appSpaLoaderAttrs = {"id":"__nuxt-loader"};

const appId$1 = "nuxt-app";

const APP_ROOT_OPEN_TAG = `<${appRootTag}${propsToString(appRootAttrs)}>`;
const APP_ROOT_CLOSE_TAG = `</${appRootTag}>`;
const getServerEntry = () => Promise.resolve().then(function () { return server; }).then((r) => r.default || r);
const getPrecomputedDependencies = () => Promise.resolve().then(function () { return client_precomputed$1; }).then((r) => r.default || r).then((r) => typeof r === "function" ? r() : r);
const getSSRRenderer = lazyCachedFunction(async () => {
  const createSSRApp = await getServerEntry();
  if (!createSSRApp) {
    throw new Error("Server bundle is not available");
  }
  const precomputed = await getPrecomputedDependencies();
  const renderer = createRenderer$1(createSSRApp, {
    precomputed,
    manifest: void 0,
    renderToString,
    buildAssetsURL
  });
  async function renderToString(input, context) {
    const html = await renderToString_1(input, context);
    return APP_ROOT_OPEN_TAG + html + APP_ROOT_CLOSE_TAG;
  }
  return renderer;
});
const getSPARenderer = lazyCachedFunction(async () => {
  const precomputed = await getPrecomputedDependencies();
  const spaTemplate = await Promise.resolve().then(function () { return _virtual__spaTemplate; }).then((r) => r.template).catch(() => "").then((r) => {
    {
      const APP_SPA_LOADER_OPEN_TAG = `<${appSpaLoaderTag}${propsToString(appSpaLoaderAttrs)}>`;
      const APP_SPA_LOADER_CLOSE_TAG = `</${appSpaLoaderTag}>`;
      const appTemplate = APP_ROOT_OPEN_TAG + APP_ROOT_CLOSE_TAG;
      const loaderTemplate = r ? APP_SPA_LOADER_OPEN_TAG + r + APP_SPA_LOADER_CLOSE_TAG : "";
      return appTemplate + loaderTemplate;
    }
  });
  const renderer = createRenderer$1(() => () => {
  }, {
    precomputed,
    manifest: void 0,
    renderToString: () => spaTemplate,
    buildAssetsURL
  });
  const result = await renderer.renderToString({});
  const renderToString = (ssrContext) => {
    const config = useRuntimeConfig$1(ssrContext.event);
    ssrContext.modules ||= /* @__PURE__ */ new Set();
    ssrContext.payload.serverRendered = false;
    ssrContext.config = {
      public: config.public,
      app: config.app
    };
    return Promise.resolve(result);
  };
  return {
    rendererContext: renderer.rendererContext,
    renderToString
  };
});
function lazyCachedFunction(fn) {
  let res = null;
  return () => {
    if (res === null) {
      res = fn().catch((err) => {
        res = null;
        throw err;
      });
    }
    return res;
  };
}
function getRenderer(ssrContext) {
  return ssrContext.noSSR ? getSPARenderer() : getSSRRenderer();
}
const getSSRStyles = lazyCachedFunction(() => Promise.resolve().then(function () { return styles$1; }).then((r) => r.default || r));

function renderPayloadJsonScript(opts) {
  const contents = opts.data ? stringify$1(opts.data, opts.ssrContext._payloadReducers) : "";
  const payload = {
    "type": "application/json",
    "innerHTML": contents,
    "data-nuxt-data": appId$1,
    "data-ssr": !(opts.ssrContext.noSSR)
  };
  {
    payload.id = "__NUXT_DATA__";
  }
  if (opts.src) {
    payload["data-src"] = opts.src;
  }
  const config = uneval(opts.ssrContext.config);
  return [
    payload,
    {
      innerHTML: `window.__NUXT__={};window.__NUXT__.config=${config}`
    }
  ];
}

const unheadOptions = {
  disableDefaults: true,
};

function createSSRContext(event) {
  const ssrContext = {
    url: event.path,
    event,
    runtimeConfig: useRuntimeConfig$1(event),
    noSSR: event.context.nuxt?.noSSR || (false),
    head: createHead(unheadOptions),
    error: false,
    nuxt: void 0,
    /* NuxtApp */
    payload: {},
    _payloadReducers: /* @__PURE__ */ Object.create(null),
    modules: /* @__PURE__ */ new Set()
  };
  return ssrContext;
}
function setSSRError(ssrContext, error) {
  ssrContext.error = true;
  ssrContext.payload = { error };
  ssrContext.url = error.url;
}

async function renderInlineStyles(usedModules) {
  const styleMap = await getSSRStyles();
  const inlinedStyles = /* @__PURE__ */ new Set();
  for (const mod of usedModules) {
    if (mod in styleMap && styleMap[mod]) {
      for (const style of await styleMap[mod]()) {
        inlinedStyles.add(style);
      }
    }
  }
  return Array.from(inlinedStyles).map((style) => ({ innerHTML: style }));
}

const renderSSRHeadOptions = {"omitLineBreaks":true};

const entryIds = [];

globalThis.__buildAssetsURL = buildAssetsURL;
globalThis.__publicAssetsURL = publicAssetsURL;
const HAS_APP_TELEPORTS = !!(appTeleportAttrs.id);
const APP_TELEPORT_OPEN_TAG = HAS_APP_TELEPORTS ? `<${appTeleportTag}${propsToString(appTeleportAttrs)}>` : "";
const APP_TELEPORT_CLOSE_TAG = HAS_APP_TELEPORTS ? `</${appTeleportTag}>` : "";
const renderer = defineRenderHandler(async (event) => {
  const nitroApp = useNitroApp();
  const ssrError = event.path.startsWith("/__nuxt_error") ? getQuery(event) : null;
  if (ssrError && !("__unenv__" in event.node.req)) {
    throw createError$2({
      statusCode: 404,
      statusMessage: "Page Not Found: /__nuxt_error"
    });
  }
  const ssrContext = createSSRContext(event);
  const headEntryOptions = { mode: "server" };
  ssrContext.head.push(appHead, headEntryOptions);
  if (ssrError) {
    ssrError.statusCode &&= Number.parseInt(ssrError.statusCode);
    if (typeof ssrError.data === "string") {
      try {
        ssrError.data = destr(ssrError.data);
      } catch {
      }
    }
    setSSRError(ssrContext, ssrError);
  }
  const routeOptions = getRouteRules$1(event);
  if (routeOptions.ssr === false) {
    ssrContext.noSSR = true;
  }
  const renderer = await getRenderer(ssrContext);
  {
    for (const id of entryIds) {
      ssrContext.modules.add(id);
    }
  }
  const _rendered = await renderer.renderToString(ssrContext).catch(async (error) => {
    if (ssrContext._renderResponse && error.message === "skipping render") {
      return {};
    }
    const _err = !ssrError && ssrContext.payload?.error || error;
    await ssrContext.nuxt?.hooks.callHook("app:error", _err);
    throw _err;
  });
  const inlinedStyles = !ssrContext._renderResponse && true ? await renderInlineStyles(ssrContext.modules ?? []) : [];
  await ssrContext.nuxt?.hooks.callHook("app:rendered", { ssrContext, renderResult: _rendered });
  if (ssrContext._renderResponse) {
    return ssrContext._renderResponse;
  }
  if (ssrContext.payload?.error && !ssrError) {
    throw ssrContext.payload.error;
  }
  const NO_SCRIPTS = routeOptions.noScripts;
  const { styles, scripts } = getRequestDependencies(ssrContext, renderer.rendererContext);
  if (ssrContext._preloadManifest && !NO_SCRIPTS) {
    ssrContext.head.push({
      link: [
        { rel: "preload", as: "fetch", fetchpriority: "low", crossorigin: "anonymous", href: buildAssetsURL(`builds/meta/${ssrContext.runtimeConfig.app.buildId}.json`) }
      ]
    }, { ...headEntryOptions, tagPriority: "low" });
  }
  if (inlinedStyles.length) {
    ssrContext.head.push({ style: inlinedStyles });
  }
  const link = [];
  for (const resource of Object.values(styles)) {
    link.push({ rel: "stylesheet", href: renderer.rendererContext.buildAssetsURL(resource.file), crossorigin: "" });
  }
  if (link.length) {
    ssrContext.head.push({ link }, headEntryOptions);
  }
  if (!NO_SCRIPTS) {
    ssrContext.head.push({
      link: getPreloadLinks(ssrContext, renderer.rendererContext)
    }, headEntryOptions);
    ssrContext.head.push({
      link: getPrefetchLinks(ssrContext, renderer.rendererContext)
    }, headEntryOptions);
    ssrContext.head.push({
      script: renderPayloadJsonScript({ ssrContext, data: ssrContext.payload }) 
    }, {
      ...headEntryOptions,
      // this should come before another end of body scripts
      tagPosition: "bodyClose",
      tagPriority: "high"
    });
  }
  if (!routeOptions.noScripts) {
    const tagPosition = "head";
    ssrContext.head.push({
      script: Object.values(scripts).map((resource) => ({
        type: resource.module ? "module" : null,
        src: renderer.rendererContext.buildAssetsURL(resource.file),
        defer: resource.module ? null : true,
        // if we are rendering script tag payloads that import an async payload
        // we need to ensure this resolves before executing the Nuxt entry
        tagPosition,
        crossorigin: ""
      }))
    }, headEntryOptions);
  }
  const { headTags, bodyTags, bodyTagsOpen, htmlAttrs, bodyAttrs } = await renderSSRHead(ssrContext.head, renderSSRHeadOptions);
  const htmlContext = {
    htmlAttrs: htmlAttrs ? [htmlAttrs] : [],
    head: normalizeChunks([headTags]),
    bodyAttrs: bodyAttrs ? [bodyAttrs] : [],
    bodyPrepend: normalizeChunks([bodyTagsOpen, ssrContext.teleports?.body]),
    body: [
      _rendered.html,
      APP_TELEPORT_OPEN_TAG + (HAS_APP_TELEPORTS ? joinTags([ssrContext.teleports?.[`#${appTeleportAttrs.id}`]]) : "") + APP_TELEPORT_CLOSE_TAG
    ],
    bodyAppend: [bodyTags]
  };
  await nitroApp.hooks.callHook("render:html", htmlContext, { event });
  return {
    body: renderHTMLDocument(htmlContext),
    statusCode: getResponseStatus(event),
    statusMessage: getResponseStatusText(event),
    headers: {
      "content-type": "text/html;charset=utf-8",
      "x-powered-by": "Nuxt"
    }
  };
});
function normalizeChunks(chunks) {
  const result = [];
  for (const _chunk of chunks) {
    const chunk = _chunk?.trim();
    if (chunk) {
      result.push(chunk);
    }
  }
  return result;
}
function joinTags(tags) {
  return tags.join("");
}
function joinAttrs(chunks) {
  if (chunks.length === 0) {
    return "";
  }
  return " " + chunks.join(" ");
}
function renderHTMLDocument(html) {
  return `<!DOCTYPE html><html${joinAttrs(html.htmlAttrs)}><head>${joinTags(html.head)}</head><body${joinAttrs(html.bodyAttrs)}>${joinTags(html.bodyPrepend)}${joinTags(html.body)}${joinTags(html.bodyAppend)}</body></html>`;
}

const renderer$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: renderer
}, Symbol.toStringTag, { value: 'Module' }));

/*!
 * vue-router v4.6.4
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */

//#region src/utils/env.ts
const isBrowser = typeof document !== "undefined";
/**
* Allows differentiating lazy components from functional components and vue-class-component
* @internal
*
* @param component
*/
function isRouteComponent(component) {
	return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function isESModule(obj) {
	return obj.__esModule || obj[Symbol.toStringTag] === "Module" || obj.default && isRouteComponent(obj.default);
}
const assign = Object.assign;
function applyToParams(fn, params) {
	const newParams = {};
	for (const key in params) {
		const value = params[key];
		newParams[key] = isArray(value) ? value.map(fn) : fn(value);
	}
	return newParams;
}
const noop = () => {};
/**
* Typesafe alternative to Array.isArray
* https://github.com/microsoft/TypeScript/pull/48228
*
* @internal
*/
const isArray = Array.isArray;
function mergeOptions(defaults, partialOptions) {
	const options = {};
	for (const key in defaults) options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
	return options;
}

//#endregion
//#region src/encoding.ts
/**
* Encoding Rules ( = Space)
* - Path:  " < > # ? { }
* - Query:  " < > # & =
* - Hash:  " < > `
*
* On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
* defines some extra characters to be encoded. Most browsers do not encode them
* in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
* also encode `!'()*`. Leaving un-encoded only ASCII alphanumeric(`a-zA-Z0-9`)
* plus `-._~`. This extra safety should be applied to query by patching the
* string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
* should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
* into a `/` if directly typed in. The _backtick_ (`````) should also be
* encoded everywhere because some browsers like FF encode it when directly
* written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
*/
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
/**
* NOTE: It's not clear to me if we should encode the + symbol in queries, it
* seems to be less flexible than not doing so and I can't find out the legacy
* systems requiring this for regular requests like text/html. In the standard,
* the encoding of the plus character is only mentioned for
* application/x-www-form-urlencoded
* (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo
* leave the plus character as is in queries. To be more flexible, we allow the
* plus character on the query, but it can also be manually encoded by the user.
*
* Resources:
* - https://url.spec.whatwg.org/#urlencoded-parsing
* - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
*/
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
/**
* Encode characters that need to be encoded on the path, search and hash
* sections of the URL.
*
* @internal
* @param text - string to encode
* @returns encoded string
*/
function commonEncode(text) {
	return text == null ? "" : encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
/**
* Encode characters that need to be encoded on the hash section of the URL.
*
* @param text - string to encode
* @returns encoded string
*/
function encodeHash(text) {
	return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
/**
* Encode characters that need to be encoded query values on the query
* section of the URL.
*
* @param text - string to encode
* @returns encoded string
*/
function encodeQueryValue(text) {
	return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
/**
* Like `encodeQueryValue` but also encodes the `=` character.
*
* @param text - string to encode
*/
function encodeQueryKey(text) {
	return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
/**
* Encode characters that need to be encoded on the path section of the URL.
*
* @param text - string to encode
* @returns encoded string
*/
function encodePath(text) {
	return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
/**
* Encode characters that need to be encoded on the path section of the URL as a
* param. This function encodes everything {@link encodePath} does plus the
* slash (`/`) character. If `text` is `null` or `undefined`, returns an empty
* string instead.
*
* @param text - string to encode
* @returns encoded string
*/
function encodeParam(text) {
	return encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
	if (text == null) return null;
	try {
		return decodeURIComponent("" + text);
	} catch (err) {
	}
	return "" + text;
}

//#endregion
//#region src/location.ts
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
/**
* Transforms a URI into a normalized history location
*
* @param parseQuery
* @param location - URI to normalize
* @param currentLocation - current absolute location. Allows resolving relative
* paths. Must start with `/`. Defaults to `/`
* @returns a normalized history location
*/
function parseURL(parseQuery$1, location, currentLocation = "/") {
	let path, query = {}, searchString = "", hash = "";
	const hashPos = location.indexOf("#");
	let searchPos = location.indexOf("?");
	searchPos = hashPos >= 0 && searchPos > hashPos ? -1 : searchPos;
	if (searchPos >= 0) {
		path = location.slice(0, searchPos);
		searchString = location.slice(searchPos, hashPos > 0 ? hashPos : location.length);
		query = parseQuery$1(searchString.slice(1));
	}
	if (hashPos >= 0) {
		path = path || location.slice(0, hashPos);
		hash = location.slice(hashPos, location.length);
	}
	path = resolveRelativePath(path != null ? path : location, currentLocation);
	return {
		fullPath: path + searchString + hash,
		path,
		query,
		hash: decode(hash)
	};
}
/**
* Stringifies a URL object
*
* @param stringifyQuery
* @param location
*/
function stringifyURL(stringifyQuery$1, location) {
	const query = location.query ? stringifyQuery$1(location.query) : "";
	return location.path + (query && "?") + query + (location.hash || "");
}
/**
* Checks if two RouteLocation are equal. This means that both locations are
* pointing towards the same {@link RouteRecord} and that all `params`, `query`
* parameters and `hash` are the same
*
* @param stringifyQuery - A function that takes a query object of type LocationQueryRaw and returns a string representation of it.
* @param a - first {@link RouteLocation}
* @param b - second {@link RouteLocation}
*/
function isSameRouteLocation(stringifyQuery$1, a, b) {
	const aLastIndex = a.matched.length - 1;
	const bLastIndex = b.matched.length - 1;
	return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery$1(a.query) === stringifyQuery$1(b.query) && a.hash === b.hash;
}
/**
* Check if two `RouteRecords` are equal. Takes into account aliases: they are
* considered equal to the `RouteRecord` they are aliasing.
*
* @param a - first {@link RouteRecord}
* @param b - second {@link RouteRecord}
*/
function isSameRouteRecord(a, b) {
	return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
	if (Object.keys(a).length !== Object.keys(b).length) return false;
	for (var key in a) if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;
	return true;
}
function isSameRouteLocationParamsValue(a, b) {
	return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a?.valueOf() === b?.valueOf();
}
/**
* Check if two arrays are the same or if an array with one single entry is the
* same as another primitive value. Used to check query and parameters
*
* @param a - array of values
* @param b - array of values or a single value
*/
function isEquivalentArray(a, b) {
	return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
/**
* Resolves a relative path that starts with `.`.
*
* @param to - path location we are resolving
* @param from - currentLocation.path, should start with `/`
*/
function resolveRelativePath(to, from) {
	if (to.startsWith("/")) return to;
	if (!to) return from;
	const fromSegments = from.split("/");
	const toSegments = to.split("/");
	const lastToSegment = toSegments[toSegments.length - 1];
	if (lastToSegment === ".." || lastToSegment === ".") toSegments.push("");
	let position = fromSegments.length - 1;
	let toPosition;
	let segment;
	for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
		segment = toSegments[toPosition];
		if (segment === ".") continue;
		if (segment === "..") {
			if (position > 1) position--;
		} else break;
	}
	return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
}
/**
* Initial route location where the router is. Can be used in navigation guards
* to differentiate the initial navigation.
*
* @example
* ```js
* import { START_LOCATION } from 'vue-router'
*
* router.beforeEach((to, from) => {
*   if (from === START_LOCATION) {
*     // initial navigation
*   }
* })
* ```
*/
const START_LOCATION_NORMALIZED = {
	path: "/",
	name: void 0,
	params: {},
	query: {},
	hash: "",
	fullPath: "/",
	matched: [],
	meta: {},
	redirectedFrom: void 0
};

//#endregion
//#region src/history/common.ts
let NavigationType = /* @__PURE__ */ function(NavigationType$1) {
	NavigationType$1["pop"] = "pop";
	NavigationType$1["push"] = "push";
	return NavigationType$1;
}({});
let NavigationDirection = /* @__PURE__ */ function(NavigationDirection$1) {
	NavigationDirection$1["back"] = "back";
	NavigationDirection$1["forward"] = "forward";
	NavigationDirection$1["unknown"] = "";
	return NavigationDirection$1;
}({});
/**
* Starting location for Histories
*/
const START = "";
/**
* Normalizes a base by removing any trailing slash and reading the base tag if
* present.
*
* @param base - base to normalize
*/
function normalizeBase(base) {
	if (!base) if (isBrowser) {
		const baseEl = document.querySelector("base");
		base = baseEl && baseEl.getAttribute("href") || "/";
		base = base.replace(/^\w+:\/\/[^\/]+/, "");
	} else base = "/";
	if (base[0] !== "/" && base[0] !== "#") base = "/" + base;
	return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location) {
	return base.replace(BEFORE_HASH_RE, "#") + location;
}

//#endregion
//#region src/scrollBehavior.ts
function getElementPosition(el, offset) {
	const docRect = document.documentElement.getBoundingClientRect();
	const elRect = el.getBoundingClientRect();
	return {
		behavior: offset.behavior,
		left: elRect.left - docRect.left - (offset.left || 0),
		top: elRect.top - docRect.top - (offset.top || 0)
	};
}
const computeScrollPosition = () => ({
	left: window.scrollX,
	top: window.scrollY
});
function scrollToPosition(position) {
	let scrollToOptions;
	if ("el" in position) {
		const positionEl = position.el;
		const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
		const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
		if (!el) {
			return;
		}
		scrollToOptions = getElementPosition(el, position);
	} else scrollToOptions = position;
	if ("scrollBehavior" in document.documentElement.style) window.scrollTo(scrollToOptions);
	else window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
}
function getScrollKey(path, delta) {
	return (history.state ? history.state.position - delta : -1) + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
	scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
	const scroll = scrollPositions.get(key);
	scrollPositions.delete(key);
	return scroll;
}
/**
* ScrollBehavior instance used by the router to compute and restore the scroll
* position when navigating.
*/

//#endregion
//#region src/types/typeGuards.ts
function isRouteLocation(route) {
	return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
	return typeof name === "string" || typeof name === "symbol";
}

//#endregion
//#region src/errors.ts
/**
* Flags so we can combine them when checking for multiple errors. This is the internal version of
* {@link NavigationFailureType}.
*
* @internal
*/
let ErrorTypes = /* @__PURE__ */ function(ErrorTypes$1) {
	ErrorTypes$1[ErrorTypes$1["MATCHER_NOT_FOUND"] = 1] = "MATCHER_NOT_FOUND";
	ErrorTypes$1[ErrorTypes$1["NAVIGATION_GUARD_REDIRECT"] = 2] = "NAVIGATION_GUARD_REDIRECT";
	ErrorTypes$1[ErrorTypes$1["NAVIGATION_ABORTED"] = 4] = "NAVIGATION_ABORTED";
	ErrorTypes$1[ErrorTypes$1["NAVIGATION_CANCELLED"] = 8] = "NAVIGATION_CANCELLED";
	ErrorTypes$1[ErrorTypes$1["NAVIGATION_DUPLICATED"] = 16] = "NAVIGATION_DUPLICATED";
	return ErrorTypes$1;
}({});
const NavigationFailureSymbol = Symbol("");
({
	[ErrorTypes.MATCHER_NOT_FOUND]({ location, currentLocation }) {
		return `No match for\n ${JSON.stringify(location)}${currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : ""}`;
	},
	[ErrorTypes.NAVIGATION_GUARD_REDIRECT]({ from, to }) {
		return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
	},
	[ErrorTypes.NAVIGATION_ABORTED]({ from, to }) {
		return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
	},
	[ErrorTypes.NAVIGATION_CANCELLED]({ from, to }) {
		return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
	},
	[ErrorTypes.NAVIGATION_DUPLICATED]({ from, to }) {
		return `Avoided redundant navigation to current location: "${from.fullPath}".`;
	}
});
/**
* Creates a typed NavigationFailure object.
* @internal
* @param type - NavigationFailureType
* @param params - { from, to }
*/
function createRouterError(type, params) {
	return assign(/* @__PURE__ */ new Error(), {
		type,
		[NavigationFailureSymbol]: true
	}, params);
}
function isNavigationFailure(error, type) {
	return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const propertiesToLog = [
	"params",
	"query",
	"hash"
];
function stringifyRoute(to) {
	if (typeof to === "string") return to;
	if (to.path != null) return to.path;
	const location = {};
	for (const key of propertiesToLog) if (key in to) location[key] = to[key];
	return JSON.stringify(location, null, 2);
}

//#endregion
//#region src/query.ts
/**
* Transforms a queryString into a {@link LocationQuery} object. Accept both, a
* version with the leading `?` and without Should work as URLSearchParams

* @internal
*
* @param search - search string to parse
* @returns a query object
*/
function parseQuery(search) {
	const query = {};
	if (search === "" || search === "?") return query;
	const searchParams = (search[0] === "?" ? search.slice(1) : search).split("&");
	for (let i = 0; i < searchParams.length; ++i) {
		const searchParam = searchParams[i].replace(PLUS_RE, " ");
		const eqPos = searchParam.indexOf("=");
		const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
		const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
		if (key in query) {
			let currentValue = query[key];
			if (!isArray(currentValue)) currentValue = query[key] = [currentValue];
			currentValue.push(value);
		} else query[key] = value;
	}
	return query;
}
/**
* Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
* doesn't prepend a `?`
*
* @internal
*
* @param query - query object to stringify
* @returns string version of the query without the leading `?`
*/
function stringifyQuery(query) {
	let search = "";
	for (let key in query) {
		const value = query[key];
		key = encodeQueryKey(key);
		if (value == null) {
			if (value !== void 0) search += (search.length ? "&" : "") + key;
			continue;
		}
		(isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)]).forEach((value$1) => {
			if (value$1 !== void 0) {
				search += (search.length ? "&" : "") + key;
				if (value$1 != null) search += "=" + value$1;
			}
		});
	}
	return search;
}
/**
* Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
* numbers into strings, removing keys with an undefined value and replacing
* undefined with null in arrays
*
* @param query - query object to normalize
* @returns a normalized query object
*/
function normalizeQuery(query) {
	const normalizedQuery = {};
	for (const key in query) {
		const value = query[key];
		if (value !== void 0) normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
	}
	return normalizedQuery;
}

//#endregion
//#region src/injectionSymbols.ts
/**
* RouteRecord being rendered by the closest ancestor Router View. Used for
* `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
* Location Matched
*
* @internal
*/
const matchedRouteKey = Symbol("");
/**
* Allows overriding the router view depth to control which component in
* `matched` is rendered. rvd stands for Router View Depth
*
* @internal
*/
const viewDepthKey = Symbol("");
/**
* Allows overriding the router instance returned by `useRouter` in tests. r
* stands for router
*
* @internal
*/
const routerKey = Symbol("");
/**
* Allows overriding the current route returned by `useRoute` in tests. rl
* stands for route location
*
* @internal
*/
const routeLocationKey = Symbol("");
/**
* Allows overriding the current route used by router-view. Internally this is
* used when the `route` prop is passed.
*
* @internal
*/
const routerViewLocationKey = Symbol("");

//#endregion
//#region src/utils/callbacks.ts
/**
* Create a list of callbacks that can be reset. Used to create before and after navigation guards list
*/
function useCallbacks() {
	let handlers = [];
	function add(handler) {
		handlers.push(handler);
		return () => {
			const i = handlers.indexOf(handler);
			if (i > -1) handlers.splice(i, 1);
		};
	}
	function reset() {
		handlers = [];
	}
	return {
		add,
		list: () => handlers.slice(),
		reset
	};
}
function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn) => fn()) {
	const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
	return () => new Promise((resolve, reject) => {
		const next = (valid) => {
			if (valid === false) reject(createRouterError(ErrorTypes.NAVIGATION_ABORTED, {
				from,
				to
			}));
			else if (valid instanceof Error) reject(valid);
			else if (isRouteLocation(valid)) reject(createRouterError(ErrorTypes.NAVIGATION_GUARD_REDIRECT, {
				from: to,
				to: valid
			}));
			else {
				if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") enterCallbackArray.push(valid);
				resolve();
			}
		};
		const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to, from, next));
		let guardCall = Promise.resolve(guardReturn);
		if (guard.length < 3) guardCall = guardCall.then(next);
		guardCall.catch((err) => reject(err));
	});
}
function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn) => fn()) {
	const guards = [];
	for (const record of matched) {
		for (const name in record.components) {
			let rawComponent = record.components[name];
			if (guardType !== "beforeRouteEnter" && !record.instances[name]) continue;
			if (isRouteComponent(rawComponent)) {
				const guard = (rawComponent.__vccOpts || rawComponent)[guardType];
				guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
			} else {
				let componentPromise = rawComponent();
				guards.push(() => componentPromise.then((resolved) => {
					if (!resolved) throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);
					const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
					record.mods[name] = resolved;
					record.components[name] = resolvedComponent;
					const guard = (resolvedComponent.__vccOpts || resolvedComponent)[guardType];
					return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
				}));
			}
		}
	}
	return guards;
}
/**
* Split the leaving, updating, and entering records.
* @internal
*
* @param  to - Location we are navigating to
* @param from - Location we are navigating from
*/
function extractChangingRecords(to, from) {
	const leavingRecords = [];
	const updatingRecords = [];
	const enteringRecords = [];
	const len = Math.max(from.matched.length, to.matched.length);
	for (let i = 0; i < len; i++) {
		const recordFrom = from.matched[i];
		if (recordFrom) if (to.matched.find((record) => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);
		else leavingRecords.push(recordFrom);
		const recordTo = to.matched[i];
		if (recordTo) {
			if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) enteringRecords.push(recordTo);
		}
	}
	return [
		leavingRecords,
		updatingRecords,
		enteringRecords
	];
}

/*!
 * vue-router v4.6.4
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */

//#endregion
//#region src/history/memory.ts
/**
* Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.
* It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.
*
* @param base - Base applied to all urls, defaults to '/'
* @returns a history object that can be passed to the router constructor
*/
function createMemoryHistory(base = "") {
	let listeners = [];
	let queue = [[START, {}]];
	let position = 0;
	base = normalizeBase(base);
	function setLocation(location$1, state = {}) {
		position++;
		if (position !== queue.length) queue.splice(position);
		queue.push([location$1, state]);
	}
	function triggerListeners(to, from, { direction, delta }) {
		const info = {
			direction,
			delta,
			type: NavigationType.pop
		};
		for (const callback of listeners) callback(to, from, info);
	}
	const routerHistory = {
		location: START,
		state: {},
		base,
		createHref: createHref.bind(null, base),
		replace(to, state) {
			queue.splice(position--, 1);
			setLocation(to, state);
		},
		push(to, state) {
			setLocation(to, state);
		},
		listen(callback) {
			listeners.push(callback);
			return () => {
				const index = listeners.indexOf(callback);
				if (index > -1) listeners.splice(index, 1);
			};
		},
		destroy() {
			listeners = [];
			queue = [[START, {}]];
			position = 0;
		},
		go(delta, shouldTrigger = true) {
			const from = this.location;
			const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
			position = Math.max(0, Math.min(position + delta, queue.length - 1));
			if (shouldTrigger) triggerListeners(this.location, from, {
				direction,
				delta
			});
		}
	};
	Object.defineProperty(routerHistory, "location", {
		enumerable: true,
		get: () => queue[position][0]
	});
	Object.defineProperty(routerHistory, "state", {
		enumerable: true,
		get: () => queue[position][1]
	});
	return routerHistory;
}

//#endregion
//#region src/matcher/pathTokenizer.ts
let TokenType = /* @__PURE__ */ function(TokenType$1) {
	TokenType$1[TokenType$1["Static"] = 0] = "Static";
	TokenType$1[TokenType$1["Param"] = 1] = "Param";
	TokenType$1[TokenType$1["Group"] = 2] = "Group";
	return TokenType$1;
}({});
var TokenizerState = /* @__PURE__ */ function(TokenizerState$1) {
	TokenizerState$1[TokenizerState$1["Static"] = 0] = "Static";
	TokenizerState$1[TokenizerState$1["Param"] = 1] = "Param";
	TokenizerState$1[TokenizerState$1["ParamRegExp"] = 2] = "ParamRegExp";
	TokenizerState$1[TokenizerState$1["ParamRegExpEnd"] = 3] = "ParamRegExpEnd";
	TokenizerState$1[TokenizerState$1["EscapeNext"] = 4] = "EscapeNext";
	return TokenizerState$1;
}(TokenizerState || {});
const ROOT_TOKEN = {
	type: TokenType.Static,
	value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
	if (!path) return [[]];
	if (path === "/") return [[ROOT_TOKEN]];
	if (!path.startsWith("/")) throw new Error(`Invalid path "${path}"`);
	function crash(message) {
		throw new Error(`ERR (${state})/"${buffer}": ${message}`);
	}
	let state = TokenizerState.Static;
	let previousState = state;
	const tokens = [];
	let segment;
	function finalizeSegment() {
		if (segment) tokens.push(segment);
		segment = [];
	}
	let i = 0;
	let char;
	let buffer = "";
	let customRe = "";
	function consumeBuffer() {
		if (!buffer) return;
		if (state === TokenizerState.Static) segment.push({
			type: TokenType.Static,
			value: buffer
		});
		else if (state === TokenizerState.Param || state === TokenizerState.ParamRegExp || state === TokenizerState.ParamRegExpEnd) {
			if (segment.length > 1 && (char === "*" || char === "+")) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
			segment.push({
				type: TokenType.Param,
				value: buffer,
				regexp: customRe,
				repeatable: char === "*" || char === "+",
				optional: char === "*" || char === "?"
			});
		} else crash("Invalid state to consume buffer");
		buffer = "";
	}
	function addCharToBuffer() {
		buffer += char;
	}
	while (i < path.length) {
		char = path[i++];
		if (char === "\\" && state !== TokenizerState.ParamRegExp) {
			previousState = state;
			state = TokenizerState.EscapeNext;
			continue;
		}
		switch (state) {
			case TokenizerState.Static:
				if (char === "/") {
					if (buffer) consumeBuffer();
					finalizeSegment();
				} else if (char === ":") {
					consumeBuffer();
					state = TokenizerState.Param;
				} else addCharToBuffer();
				break;
			case TokenizerState.EscapeNext:
				addCharToBuffer();
				state = previousState;
				break;
			case TokenizerState.Param:
				if (char === "(") state = TokenizerState.ParamRegExp;
				else if (VALID_PARAM_RE.test(char)) addCharToBuffer();
				else {
					consumeBuffer();
					state = TokenizerState.Static;
					if (char !== "*" && char !== "?" && char !== "+") i--;
				}
				break;
			case TokenizerState.ParamRegExp:
				if (char === ")") if (customRe[customRe.length - 1] == "\\") customRe = customRe.slice(0, -1) + char;
				else state = TokenizerState.ParamRegExpEnd;
				else customRe += char;
				break;
			case TokenizerState.ParamRegExpEnd:
				consumeBuffer();
				state = TokenizerState.Static;
				if (char !== "*" && char !== "?" && char !== "+") i--;
				customRe = "";
				break;
			default:
				crash("Unknown state");
				break;
		}
	}
	if (state === TokenizerState.ParamRegExp) crash(`Unfinished custom RegExp for param "${buffer}"`);
	consumeBuffer();
	finalizeSegment();
	return tokens;
}

//#endregion
//#region src/matcher/pathParserRanker.ts
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
	sensitive: false,
	strict: false,
	start: true,
	end: true
};
var PathScore = /* @__PURE__ */ function(PathScore$1) {
	PathScore$1[PathScore$1["_multiplier"] = 10] = "_multiplier";
	PathScore$1[PathScore$1["Root"] = 90] = "Root";
	PathScore$1[PathScore$1["Segment"] = 40] = "Segment";
	PathScore$1[PathScore$1["SubSegment"] = 30] = "SubSegment";
	PathScore$1[PathScore$1["Static"] = 40] = "Static";
	PathScore$1[PathScore$1["Dynamic"] = 20] = "Dynamic";
	PathScore$1[PathScore$1["BonusCustomRegExp"] = 10] = "BonusCustomRegExp";
	PathScore$1[PathScore$1["BonusWildcard"] = -50] = "BonusWildcard";
	PathScore$1[PathScore$1["BonusRepeatable"] = -20] = "BonusRepeatable";
	PathScore$1[PathScore$1["BonusOptional"] = -8] = "BonusOptional";
	PathScore$1[PathScore$1["BonusStrict"] = .7000000000000001] = "BonusStrict";
	PathScore$1[PathScore$1["BonusCaseSensitive"] = .25] = "BonusCaseSensitive";
	return PathScore$1;
}(PathScore || {});
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
/**
* Creates a path parser from an array of Segments (a segment is an array of Tokens)
*
* @param segments - array of segments returned by tokenizePath
* @param extraOptions - optional options for the regexp
* @returns a PathParser
*/
function tokensToParser(segments, extraOptions) {
	const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
	const score = [];
	let pattern = options.start ? "^" : "";
	const keys = [];
	for (const segment of segments) {
		const segmentScores = segment.length ? [] : [PathScore.Root];
		if (options.strict && !segment.length) pattern += "/";
		for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
			const token = segment[tokenIndex];
			let subSegmentScore = PathScore.Segment + (options.sensitive ? PathScore.BonusCaseSensitive : 0);
			if (token.type === TokenType.Static) {
				if (!tokenIndex) pattern += "/";
				pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
				subSegmentScore += PathScore.Static;
			} else if (token.type === TokenType.Param) {
				const { value, repeatable, optional, regexp } = token;
				keys.push({
					name: value,
					repeatable,
					optional
				});
				const re$1 = regexp ? regexp : BASE_PARAM_PATTERN;
				if (re$1 !== BASE_PARAM_PATTERN) {
					subSegmentScore += PathScore.BonusCustomRegExp;
					try {
						`${re$1}`;
					} catch (err) {
						throw new Error(`Invalid custom RegExp for param "${value}" (${re$1}): ` + err.message);
					}
				}
				let subPattern = repeatable ? `((?:${re$1})(?:/(?:${re$1}))*)` : `(${re$1})`;
				if (!tokenIndex) subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
				if (optional) subPattern += "?";
				pattern += subPattern;
				subSegmentScore += PathScore.Dynamic;
				if (optional) subSegmentScore += PathScore.BonusOptional;
				if (repeatable) subSegmentScore += PathScore.BonusRepeatable;
				if (re$1 === ".*") subSegmentScore += PathScore.BonusWildcard;
			}
			segmentScores.push(subSegmentScore);
		}
		score.push(segmentScores);
	}
	if (options.strict && options.end) {
		const i = score.length - 1;
		score[i][score[i].length - 1] += PathScore.BonusStrict;
	}
	if (!options.strict) pattern += "/?";
	if (options.end) pattern += "$";
	else if (options.strict && !pattern.endsWith("/")) pattern += "(?:/|$)";
	const re = new RegExp(pattern, options.sensitive ? "" : "i");
	function parse(path) {
		const match = path.match(re);
		const params = {};
		if (!match) return null;
		for (let i = 1; i < match.length; i++) {
			const value = match[i] || "";
			const key = keys[i - 1];
			params[key.name] = value && key.repeatable ? value.split("/") : value;
		}
		return params;
	}
	function stringify(params) {
		let path = "";
		let avoidDuplicatedSlash = false;
		for (const segment of segments) {
			if (!avoidDuplicatedSlash || !path.endsWith("/")) path += "/";
			avoidDuplicatedSlash = false;
			for (const token of segment) if (token.type === TokenType.Static) path += token.value;
			else if (token.type === TokenType.Param) {
				const { value, repeatable, optional } = token;
				const param = value in params ? params[value] : "";
				if (isArray(param) && !repeatable) throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
				const text = isArray(param) ? param.join("/") : param;
				if (!text) if (optional) {
					if (segment.length < 2) if (path.endsWith("/")) path = path.slice(0, -1);
					else avoidDuplicatedSlash = true;
				} else throw new Error(`Missing required param "${value}"`);
				path += text;
			}
		}
		return path || "/";
	}
	return {
		re,
		score,
		keys,
		parse,
		stringify
	};
}
/**
* Compares an array of numbers as used in PathParser.score and returns a
* number. This function can be used to `sort` an array
*
* @param a - first array of numbers
* @param b - second array of numbers
* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
* should be sorted first
*/
function compareScoreArray(a, b) {
	let i = 0;
	while (i < a.length && i < b.length) {
		const diff = b[i] - a[i];
		if (diff) return diff;
		i++;
	}
	if (a.length < b.length) return a.length === 1 && a[0] === PathScore.Static + PathScore.Segment ? -1 : 1;
	else if (a.length > b.length) return b.length === 1 && b[0] === PathScore.Static + PathScore.Segment ? 1 : -1;
	return 0;
}
/**
* Compare function that can be used with `sort` to sort an array of PathParser
*
* @param a - first PathParser
* @param b - second PathParser
* @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
*/
function comparePathParserScore(a, b) {
	let i = 0;
	const aScore = a.score;
	const bScore = b.score;
	while (i < aScore.length && i < bScore.length) {
		const comp = compareScoreArray(aScore[i], bScore[i]);
		if (comp) return comp;
		i++;
	}
	if (Math.abs(bScore.length - aScore.length) === 1) {
		if (isLastScoreNegative(aScore)) return 1;
		if (isLastScoreNegative(bScore)) return -1;
	}
	return bScore.length - aScore.length;
}
/**
* This allows detecting splats at the end of a path: /home/:id(.*)*
*
* @param score - score to check
* @returns true if the last entry is negative
*/
function isLastScoreNegative(score) {
	const last = score[score.length - 1];
	return score.length > 0 && last[last.length - 1] < 0;
}
const PATH_PARSER_OPTIONS_DEFAULTS = {
	strict: false,
	end: true,
	sensitive: false
};

//#endregion
//#region src/matcher/pathMatcher.ts
function createRouteRecordMatcher(record, parent, options) {
	const parser = tokensToParser(tokenizePath(record.path), options);
	const matcher = assign(parser, {
		record,
		parent,
		children: [],
		alias: []
	});
	if (parent) {
		if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);
	}
	return matcher;
}

//#endregion
//#region src/matcher/index.ts
/**
* Creates a Router Matcher.
*
* @internal
* @param routes - array of initial routes
* @param globalOptions - global route options
*/
function createRouterMatcher(routes, globalOptions) {
	const matchers = [];
	const matcherMap = /* @__PURE__ */ new Map();
	globalOptions = mergeOptions(PATH_PARSER_OPTIONS_DEFAULTS, globalOptions);
	function getRecordMatcher(name) {
		return matcherMap.get(name);
	}
	function addRoute(record, parent, originalRecord) {
		const isRootAdd = !originalRecord;
		const mainNormalizedRecord = normalizeRouteRecord(record);
		mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
		const options = mergeOptions(globalOptions, record);
		const normalizedRecords = [mainNormalizedRecord];
		if ("alias" in record) {
			const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
			for (const alias of aliases) normalizedRecords.push(normalizeRouteRecord(assign({}, mainNormalizedRecord, {
				components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
				path: alias,
				aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
			})));
		}
		let matcher;
		let originalMatcher;
		for (const normalizedRecord of normalizedRecords) {
			const { path } = normalizedRecord;
			if (parent && path[0] !== "/") {
				const parentPath = parent.record.path;
				const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
				normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
			}
			matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
			if (originalRecord) {
				originalRecord.alias.push(matcher);
			} else {
				originalMatcher = originalMatcher || matcher;
				if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);
				if (isRootAdd && record.name && !isAliasRecord(matcher)) {
					removeRoute(record.name);
				}
			}
			if (isMatchable(matcher)) insertMatcher(matcher);
			if (mainNormalizedRecord.children) {
				const children = mainNormalizedRecord.children;
				for (let i = 0; i < children.length; i++) addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
			}
			originalRecord = originalRecord || matcher;
		}
		return originalMatcher ? () => {
			removeRoute(originalMatcher);
		} : noop;
	}
	function removeRoute(matcherRef) {
		if (isRouteName(matcherRef)) {
			const matcher = matcherMap.get(matcherRef);
			if (matcher) {
				matcherMap.delete(matcherRef);
				matchers.splice(matchers.indexOf(matcher), 1);
				matcher.children.forEach(removeRoute);
				matcher.alias.forEach(removeRoute);
			}
		} else {
			const index = matchers.indexOf(matcherRef);
			if (index > -1) {
				matchers.splice(index, 1);
				if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);
				matcherRef.children.forEach(removeRoute);
				matcherRef.alias.forEach(removeRoute);
			}
		}
	}
	function getRoutes() {
		return matchers;
	}
	function insertMatcher(matcher) {
		const index = findInsertionIndex(matcher, matchers);
		matchers.splice(index, 0, matcher);
		if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);
	}
	function resolve(location$1, currentLocation) {
		let matcher;
		let params = {};
		let path;
		let name;
		if ("name" in location$1 && location$1.name) {
			matcher = matcherMap.get(location$1.name);
			if (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, { location: location$1 });
			name = matcher.record.name;
			params = assign(pickParams(currentLocation.params, matcher.keys.filter((k) => !k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k) => k.optional) : []).map((k) => k.name)), location$1.params && pickParams(location$1.params, matcher.keys.map((k) => k.name)));
			path = matcher.stringify(params);
		} else if (location$1.path != null) {
			path = location$1.path;
			matcher = matchers.find((m) => m.re.test(path));
			if (matcher) {
				params = matcher.parse(path);
				name = matcher.record.name;
			}
		} else {
			matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
			if (!matcher) throw createRouterError(ErrorTypes.MATCHER_NOT_FOUND, {
				location: location$1,
				currentLocation
			});
			name = matcher.record.name;
			params = assign({}, currentLocation.params, location$1.params);
			path = matcher.stringify(params);
		}
		const matched = [];
		let parentMatcher = matcher;
		while (parentMatcher) {
			matched.unshift(parentMatcher.record);
			parentMatcher = parentMatcher.parent;
		}
		return {
			name,
			path,
			params,
			matched,
			meta: mergeMetaFields(matched)
		};
	}
	routes.forEach((route) => addRoute(route));
	function clearRoutes() {
		matchers.length = 0;
		matcherMap.clear();
	}
	return {
		addRoute,
		resolve,
		removeRoute,
		clearRoutes,
		getRoutes,
		getRecordMatcher
	};
}
/**
* Picks an object param to contain only specified keys.
*
* @param params - params object to pick from
* @param keys - keys to pick
*/
function pickParams(params, keys) {
	const newParams = {};
	for (const key of keys) if (key in params) newParams[key] = params[key];
	return newParams;
}
/**
* Normalizes a RouteRecordRaw. Creates a copy
*
* @param record
* @returns the normalized version
*/
function normalizeRouteRecord(record) {
	const normalized = {
		path: record.path,
		redirect: record.redirect,
		name: record.name,
		meta: record.meta || {},
		aliasOf: record.aliasOf,
		beforeEnter: record.beforeEnter,
		props: normalizeRecordProps(record),
		children: record.children || [],
		instances: {},
		leaveGuards: /* @__PURE__ */ new Set(),
		updateGuards: /* @__PURE__ */ new Set(),
		enterCallbacks: {},
		components: "components" in record ? record.components || null : record.component && { default: record.component }
	};
	Object.defineProperty(normalized, "mods", { value: {} });
	return normalized;
}
/**
* Normalize the optional `props` in a record to always be an object similar to
* components. Also accept a boolean for components.
* @param record
*/
function normalizeRecordProps(record) {
	const propsObject = {};
	const props = record.props || false;
	if ("component" in record) propsObject.default = props;
	else for (const name in record.components) propsObject[name] = typeof props === "object" ? props[name] : props;
	return propsObject;
}
/**
* Checks if a record or any of its parent is an alias
* @param record
*/
function isAliasRecord(record) {
	while (record) {
		if (record.record.aliasOf) return true;
		record = record.parent;
	}
	return false;
}
/**
* Merge meta fields of an array of records
*
* @param matched - array of matched records
*/
function mergeMetaFields(matched) {
	return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
/**
* Performs a binary search to find the correct insertion index for a new matcher.
*
* Matchers are primarily sorted by their score. If scores are tied then we also consider parent/child relationships,
* with descendants coming before ancestors. If there's still a tie, new routes are inserted after existing routes.
*
* @param matcher - new matcher to be inserted
* @param matchers - existing matchers
*/
function findInsertionIndex(matcher, matchers) {
	let lower = 0;
	let upper = matchers.length;
	while (lower !== upper) {
		const mid = lower + upper >> 1;
		if (comparePathParserScore(matcher, matchers[mid]) < 0) upper = mid;
		else lower = mid + 1;
	}
	const insertionAncestor = getInsertionAncestor(matcher);
	if (insertionAncestor) {
		upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
	}
	return upper;
}
function getInsertionAncestor(matcher) {
	let ancestor = matcher;
	while (ancestor = ancestor.parent) if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) return ancestor;
}
/**
* Checks if a matcher can be reachable. This means if it's possible to reach it as a route. For example, routes without
* a component, or name, or redirect, are just used to group other routes.
* @param matcher
* @param matcher.record record of the matcher
* @returns
*/
function isMatchable({ record }) {
	return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
}

//#endregion
//#region src/RouterLink.ts
/**
* Returns the internal behavior of a {@link RouterLink} without the rendering part.
*
* @param props - a `to` location and an optional `replace` flag
*/
function useLink(props) {
	const router = vueExports.inject(routerKey);
	const currentRoute = vueExports.inject(routeLocationKey);
	const route = vueExports.computed(() => {
		const to = vueExports.unref(props.to);
		return router.resolve(to);
	});
	const activeRecordIndex = vueExports.computed(() => {
		const { matched } = route.value;
		const { length } = matched;
		const routeMatched = matched[length - 1];
		const currentMatched = currentRoute.matched;
		if (!routeMatched || !currentMatched.length) return -1;
		const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
		if (index > -1) return index;
		const parentRecordPath = getOriginalPath(matched[length - 2]);
		return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
	});
	const isActive = vueExports.computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
	const isExactActive = vueExports.computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
	function navigate(e = {}) {
		if (guardEvent(e)) {
			const p = router[vueExports.unref(props.replace) ? "replace" : "push"](vueExports.unref(props.to)).catch(noop);
			if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) document.startViewTransition(() => p);
			return p;
		}
		return Promise.resolve();
	}
	/**
	* NOTE: update {@link _RouterLinkI}'s `$slots` type when updating this
	*/
	return {
		route,
		href: vueExports.computed(() => route.value.href),
		isActive,
		isExactActive,
		navigate
	};
}
function preferSingleVNode(vnodes) {
	return vnodes.length === 1 ? vnodes[0] : vnodes;
}
const RouterLinkImpl = /* @__PURE__ */ vueExports.defineComponent({
	name: "RouterLink",
	compatConfig: { MODE: 3 },
	props: {
		to: {
			type: [String, Object],
			required: true
		},
		replace: Boolean,
		activeClass: String,
		exactActiveClass: String,
		custom: Boolean,
		ariaCurrentValue: {
			type: String,
			default: "page"
		},
		viewTransition: Boolean
	},
	useLink,
	setup(props, { slots }) {
		const link = vueExports.reactive(useLink(props));
		const { options } = vueExports.inject(routerKey);
		const elClass = vueExports.computed(() => ({
			[getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
			[getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
		}));
		return () => {
			const children = slots.default && preferSingleVNode(slots.default(link));
			return props.custom ? children : vueExports.h("a", {
				"aria-current": link.isExactActive ? props.ariaCurrentValue : null,
				href: link.href,
				onClick: link.navigate,
				class: elClass.value
			}, children);
		};
	}
});
/**
* Component to render a link that triggers a navigation on click.
*/
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
	if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
	if (e.defaultPrevented) return;
	if (e.button !== void 0 && e.button !== 0) return;
	if (e.currentTarget && e.currentTarget.getAttribute) {
		const target = e.currentTarget.getAttribute("target");
		if (/\b_blank\b/i.test(target)) return;
	}
	if (e.preventDefault) e.preventDefault();
	return true;
}
function includesParams(outer, inner) {
	for (const key in inner) {
		const innerValue = inner[key];
		const outerValue = outer[key];
		if (typeof innerValue === "string") {
			if (innerValue !== outerValue) return false;
		} else if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value.valueOf() !== outerValue[i].valueOf())) return false;
	}
	return true;
}
/**
* Get the original path value of a record by following its aliasOf
* @param record
*/
function getOriginalPath(record) {
	return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
/**
* Utility class to get the active class based on defaults.
* @param propClass
* @param globalClass
* @param defaultClass
*/
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;

//#endregion
//#region src/RouterView.ts
const RouterViewImpl = /* @__PURE__ */ vueExports.defineComponent({
	name: "RouterView",
	inheritAttrs: false,
	props: {
		name: {
			type: String,
			default: "default"
		},
		route: Object
	},
	compatConfig: { MODE: 3 },
	setup(props, { attrs, slots }) {
		const injectedRoute = vueExports.inject(routerViewLocationKey);
		const routeToDisplay = vueExports.computed(() => props.route || injectedRoute.value);
		const injectedDepth = vueExports.inject(viewDepthKey, 0);
		const depth = vueExports.computed(() => {
			let initialDepth = vueExports.unref(injectedDepth);
			const { matched } = routeToDisplay.value;
			let matchedRoute;
			while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) initialDepth++;
			return initialDepth;
		});
		const matchedRouteRef = vueExports.computed(() => routeToDisplay.value.matched[depth.value]);
		vueExports.provide(viewDepthKey, vueExports.computed(() => depth.value + 1));
		vueExports.provide(matchedRouteKey, matchedRouteRef);
		vueExports.provide(routerViewLocationKey, routeToDisplay);
		const viewRef = vueExports.ref();
		vueExports.watch(() => [
			viewRef.value,
			matchedRouteRef.value,
			props.name
		], ([instance, to, name], [oldInstance, from, oldName]) => {
			if (to) {
				to.instances[name] = instance;
				if (from && from !== to && instance && instance === oldInstance) {
					if (!to.leaveGuards.size) to.leaveGuards = from.leaveGuards;
					if (!to.updateGuards.size) to.updateGuards = from.updateGuards;
				}
			}
			if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
		}, { flush: "post" });
		return () => {
			const route = routeToDisplay.value;
			const currentName = props.name;
			const matchedRoute = matchedRouteRef.value;
			const ViewComponent = matchedRoute && matchedRoute.components[currentName];
			if (!ViewComponent) return normalizeSlot$1(slots.default, {
				Component: ViewComponent,
				route
			});
			const routePropsOption = matchedRoute.props[currentName];
			const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
			const onVnodeUnmounted = (vnode) => {
				if (vnode.component.isUnmounted) matchedRoute.instances[currentName] = null;
			};
			const component = vueExports.h(ViewComponent, assign({}, routeProps, attrs, {
				onVnodeUnmounted,
				ref: viewRef
			}));
			return normalizeSlot$1(slots.default, {
				Component: component,
				route
			}) || component;
		};
	}
});
function normalizeSlot$1(slot, data) {
	if (!slot) return null;
	const slotContent = slot(data);
	return slotContent.length === 1 ? slotContent[0] : slotContent;
}
/**
* Component to display the current route the user is at.
*/
const RouterView = RouterViewImpl;

//#endregion
//#region src/router.ts
/**
* Creates a Router instance that can be used by a Vue app.
*
* @param options - {@link RouterOptions}
*/
function createRouter(options) {
	const matcher = createRouterMatcher(options.routes, options);
	const parseQuery$1 = options.parseQuery || parseQuery;
	const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
	const routerHistory = options.history;
	const beforeGuards = useCallbacks();
	const beforeResolveGuards = useCallbacks();
	const afterGuards = useCallbacks();
	const currentRoute = vueExports.shallowRef(START_LOCATION_NORMALIZED);
	let pendingLocation = START_LOCATION_NORMALIZED;
	if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) history.scrollRestoration = "manual";
	const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
	const encodeParams = applyToParams.bind(null, encodeParam);
	const decodeParams = applyToParams.bind(null, decode);
	function addRoute(parentOrRoute, route) {
		let parent;
		let record;
		if (isRouteName(parentOrRoute)) {
			parent = matcher.getRecordMatcher(parentOrRoute);
			record = route;
		} else record = parentOrRoute;
		return matcher.addRoute(record, parent);
	}
	function removeRoute(name) {
		const recordMatcher = matcher.getRecordMatcher(name);
		if (recordMatcher) matcher.removeRoute(recordMatcher);
	}
	function getRoutes() {
		return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
	}
	function hasRoute(name) {
		return !!matcher.getRecordMatcher(name);
	}
	function resolve(rawLocation, currentLocation) {
		currentLocation = assign({}, currentLocation || currentRoute.value);
		if (typeof rawLocation === "string") {
			const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
			const matchedRoute$1 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
			const href$1 = routerHistory.createHref(locationNormalized.fullPath);
			return assign(locationNormalized, matchedRoute$1, {
				params: decodeParams(matchedRoute$1.params),
				hash: decode(locationNormalized.hash),
				redirectedFrom: void 0,
				href: href$1
			});
		}
		let matcherLocation;
		if (rawLocation.path != null) {
			matcherLocation = assign({}, rawLocation, { path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path });
		} else {
			const targetParams = assign({}, rawLocation.params);
			for (const key in targetParams) if (targetParams[key] == null) delete targetParams[key];
			matcherLocation = assign({}, rawLocation, { params: encodeParams(targetParams) });
			currentLocation.params = encodeParams(currentLocation.params);
		}
		const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
		const hash = rawLocation.hash || "";
		matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
		const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
			hash: encodeHash(hash),
			path: matchedRoute.path
		}));
		const href = routerHistory.createHref(fullPath);
		return assign({
			fullPath,
			hash,
			query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
		}, matchedRoute, {
			redirectedFrom: void 0,
			href
		});
	}
	function locationAsObject(to) {
		return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
	}
	function checkCanceledNavigation(to, from) {
		if (pendingLocation !== to) return createRouterError(ErrorTypes.NAVIGATION_CANCELLED, {
			from,
			to
		});
	}
	function push(to) {
		return pushWithRedirect(to);
	}
	function replace(to) {
		return push(assign(locationAsObject(to), { replace: true }));
	}
	function handleRedirectRecord(to, from) {
		const lastMatched = to.matched[to.matched.length - 1];
		if (lastMatched && lastMatched.redirect) {
			const { redirect } = lastMatched;
			let newTargetLocation = typeof redirect === "function" ? redirect(to, from) : redirect;
			if (typeof newTargetLocation === "string") {
				newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
				newTargetLocation.params = {};
			}
			return assign({
				query: to.query,
				hash: to.hash,
				params: newTargetLocation.path != null ? {} : to.params
			}, newTargetLocation);
		}
	}
	function pushWithRedirect(to, redirectedFrom) {
		const targetLocation = pendingLocation = resolve(to);
		const from = currentRoute.value;
		const data = to.state;
		const force = to.force;
		const replace$1 = to.replace === true;
		const shouldRedirect = handleRedirectRecord(targetLocation, from);
		if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
			state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
			force,
			replace: replace$1
		}), redirectedFrom || targetLocation);
		const toLocation = targetLocation;
		toLocation.redirectedFrom = redirectedFrom;
		let failure;
		if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
			failure = createRouterError(ErrorTypes.NAVIGATION_DUPLICATED, {
				to: toLocation,
				from
			});
			handleScroll(from, from, true, false);
		}
		return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure$1) => {
			if (failure$1) {
				if (isNavigationFailure(failure$1, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {
					return pushWithRedirect(assign({ replace: replace$1 }, locationAsObject(failure$1.to), {
						state: typeof failure$1.to === "object" ? assign({}, data, failure$1.to.state) : data,
						force
					}), redirectedFrom || toLocation);
				}
			} else failure$1 = finalizeNavigation(toLocation, from, true, replace$1, data);
			triggerAfterEach(toLocation, from, failure$1);
			return failure$1;
		});
	}
	/**
	* Helper to reject and skip all navigation guards if a new navigation happened
	* @param to
	* @param from
	*/
	function checkCanceledNavigationAndReject(to, from) {
		const error = checkCanceledNavigation(to, from);
		return error ? Promise.reject(error) : Promise.resolve();
	}
	function runWithContext(fn) {
		const app = installedApps.values().next().value;
		return app && typeof app.runWithContext === "function" ? app.runWithContext(fn) : fn();
	}
	function navigate(to, from) {
		let guards;
		const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
		guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
		for (const record of leavingRecords) record.leaveGuards.forEach((guard) => {
			guards.push(guardToPromiseFn(guard, to, from));
		});
		const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
		guards.push(canceledNavigationCheck);
		return runGuardQueue(guards).then(() => {
			guards = [];
			for (const guard of beforeGuards.list()) guards.push(guardToPromiseFn(guard, to, from));
			guards.push(canceledNavigationCheck);
			return runGuardQueue(guards);
		}).then(() => {
			guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
			for (const record of updatingRecords) record.updateGuards.forEach((guard) => {
				guards.push(guardToPromiseFn(guard, to, from));
			});
			guards.push(canceledNavigationCheck);
			return runGuardQueue(guards);
		}).then(() => {
			guards = [];
			for (const record of enteringRecords) if (record.beforeEnter) if (isArray(record.beforeEnter)) for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));
			else guards.push(guardToPromiseFn(record.beforeEnter, to, from));
			guards.push(canceledNavigationCheck);
			return runGuardQueue(guards);
		}).then(() => {
			to.matched.forEach((record) => record.enterCallbacks = {});
			guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
			guards.push(canceledNavigationCheck);
			return runGuardQueue(guards);
		}).then(() => {
			guards = [];
			for (const guard of beforeResolveGuards.list()) guards.push(guardToPromiseFn(guard, to, from));
			guards.push(canceledNavigationCheck);
			return runGuardQueue(guards);
		}).catch((err) => isNavigationFailure(err, ErrorTypes.NAVIGATION_CANCELLED) ? err : Promise.reject(err));
	}
	function triggerAfterEach(to, from, failure) {
		afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
	}
	/**
	* - Cleans up any navigation guards
	* - Changes the url if necessary
	* - Calls the scrollBehavior
	*/
	function finalizeNavigation(toLocation, from, isPush, replace$1, data) {
		const error = checkCanceledNavigation(toLocation, from);
		if (error) return error;
		const isFirstNavigation = from === START_LOCATION_NORMALIZED;
		const state = !isBrowser ? {} : history.state;
		if (isPush) if (replace$1 || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({ scroll: isFirstNavigation && state && state.scroll }, data));
		else routerHistory.push(toLocation.fullPath, data);
		currentRoute.value = toLocation;
		handleScroll(toLocation, from, isPush, isFirstNavigation);
		markAsReady();
	}
	let removeHistoryListener;
	function setupListeners() {
		if (removeHistoryListener) return;
		removeHistoryListener = routerHistory.listen((to, _from, info) => {
			if (!router.listening) return;
			const toLocation = resolve(to);
			const shouldRedirect = handleRedirectRecord(toLocation, router.currentRoute.value);
			if (shouldRedirect) {
				pushWithRedirect(assign(shouldRedirect, {
					replace: true,
					force: true
				}), toLocation).catch(noop);
				return;
			}
			pendingLocation = toLocation;
			const from = currentRoute.value;
			if (isBrowser) saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
			navigate(toLocation, from).catch((error) => {
				if (isNavigationFailure(error, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_CANCELLED)) return error;
				if (isNavigationFailure(error, ErrorTypes.NAVIGATION_GUARD_REDIRECT)) {
					pushWithRedirect(assign(locationAsObject(error.to), { force: true }), toLocation).then((failure) => {
						if (isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED) && !info.delta && info.type === NavigationType.pop) routerHistory.go(-1, false);
					}).catch(noop);
					return Promise.reject();
				}
				if (info.delta) routerHistory.go(-info.delta, false);
				return triggerError(error, toLocation, from);
			}).then((failure) => {
				failure = failure || finalizeNavigation(toLocation, from, false);
				if (failure) {
					if (info.delta && !isNavigationFailure(failure, ErrorTypes.NAVIGATION_CANCELLED)) routerHistory.go(-info.delta, false);
					else if (info.type === NavigationType.pop && isNavigationFailure(failure, ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED)) routerHistory.go(-1, false);
				}
				triggerAfterEach(toLocation, from, failure);
			}).catch(noop);
		});
	}
	let readyHandlers = useCallbacks();
	let errorListeners = useCallbacks();
	let ready;
	/**
	* Trigger errorListeners added via onError and throws the error as well
	*
	* @param error - error to throw
	* @param to - location we were navigating to when the error happened
	* @param from - location we were navigating from when the error happened
	* @returns the error as a rejected promise
	*/
	function triggerError(error, to, from) {
		markAsReady(error);
		const list = errorListeners.list();
		if (list.length) list.forEach((handler) => handler(error, to, from));
		else {
			console.error(error);
		}
		return Promise.reject(error);
	}
	function isReady() {
		if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();
		return new Promise((resolve$1, reject) => {
			readyHandlers.add([resolve$1, reject]);
		});
	}
	function markAsReady(err) {
		if (!ready) {
			ready = !err;
			setupListeners();
			readyHandlers.list().forEach(([resolve$1, reject]) => err ? reject(err) : resolve$1());
			readyHandlers.reset();
		}
		return err;
	}
	function handleScroll(to, from, isPush, isFirstNavigation) {
		const { scrollBehavior } = options;
		if (!isBrowser || !scrollBehavior) return Promise.resolve();
		const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
		return vueExports.nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
	}
	const go = (delta) => routerHistory.go(delta);
	let started;
	const installedApps = /* @__PURE__ */ new Set();
	const router = {
		currentRoute,
		listening: true,
		addRoute,
		removeRoute,
		clearRoutes: matcher.clearRoutes,
		hasRoute,
		getRoutes,
		resolve,
		options,
		push,
		replace,
		go,
		back: () => go(-1),
		forward: () => go(1),
		beforeEach: beforeGuards.add,
		beforeResolve: beforeResolveGuards.add,
		afterEach: afterGuards.add,
		onError: errorListeners.add,
		isReady,
		install(app) {
			app.component("RouterLink", RouterLink);
			app.component("RouterView", RouterView);
			app.config.globalProperties.$router = router;
			Object.defineProperty(app.config.globalProperties, "$route", {
				enumerable: true,
				get: () => vueExports.unref(currentRoute)
			});
			if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
				started = true;
				push(routerHistory.location).catch((err) => {
				});
			}
			const reactiveRoute = {};
			for (const key in START_LOCATION_NORMALIZED) Object.defineProperty(reactiveRoute, key, {
				get: () => currentRoute.value[key],
				enumerable: true
			});
			app.provide(routerKey, router);
			app.provide(routeLocationKey, vueExports.shallowReactive(reactiveRoute));
			app.provide(routerViewLocationKey, currentRoute);
			const unmountApp = app.unmount;
			installedApps.add(app);
			app.unmount = function() {
				installedApps.delete(app);
				if (installedApps.size < 1) {
					pendingLocation = START_LOCATION_NORMALIZED;
					removeHistoryListener && removeHistoryListener();
					removeHistoryListener = null;
					currentRoute.value = START_LOCATION_NORMALIZED;
					started = false;
					ready = false;
				}
				unmountApp();
			};
		}
	};
	function runGuardQueue(guards) {
		return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
	}
	return router;
}
/**
* Returns the current route location. Equivalent to using `$route` inside
* templates.
*/
function useRoute$1(_name) {
	return vueExports.inject(routeLocationKey);
}

if (!globalThis.$fetch) {
  globalThis.$fetch = $fetch$1.create({
    baseURL: baseURL()
  });
}
if (!("global" in globalThis)) {
  globalThis.global = globalThis;
}
const appLayoutTransition = false;
const nuxtLinkDefaults = { "componentName": "NuxtLink" };
const asyncDataDefaults = { "deep": false };
const fetchDefaults = {};
const appId = "nuxt-app";
function getNuxtAppCtx(id = appId) {
  return getContext$1(id, {
    asyncContext: false
  });
}
const NuxtPluginIndicator = "__nuxt_plugin";
function createNuxtApp(options) {
  let hydratingCount = 0;
  const nuxtApp = {
    _id: options.id || appId || "nuxt-app",
    _scope: vueExports.effectScope(),
    provide: void 0,
    versions: {
      get nuxt() {
        return "4.2.2";
      },
      get vue() {
        return nuxtApp.vueApp.version;
      }
    },
    payload: vueExports.shallowReactive({
      ...options.ssrContext?.payload || {},
      data: vueExports.shallowReactive({}),
      state: vueExports.reactive({}),
      once: /* @__PURE__ */ new Set(),
      _errors: vueExports.shallowReactive({})
    }),
    static: {
      data: {}
    },
    runWithContext(fn) {
      if (nuxtApp._scope.active && !vueExports.getCurrentScope()) {
        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn));
      }
      return callWithNuxt(nuxtApp, fn);
    },
    isHydrating: false,
    deferHydration() {
      if (!nuxtApp.isHydrating) {
        return () => {
        };
      }
      hydratingCount++;
      let called = false;
      return () => {
        if (called) {
          return;
        }
        called = true;
        hydratingCount--;
        if (hydratingCount === 0) {
          nuxtApp.isHydrating = false;
          return nuxtApp.callHook("app:suspense:resolve");
        }
      };
    },
    _asyncDataPromises: {},
    _asyncData: vueExports.shallowReactive({}),
    _payloadRevivers: {},
    ...options
  };
  {
    nuxtApp.payload.serverRendered = true;
  }
  if (nuxtApp.ssrContext) {
    nuxtApp.payload.path = nuxtApp.ssrContext.url;
    nuxtApp.ssrContext.nuxt = nuxtApp;
    nuxtApp.ssrContext.payload = nuxtApp.payload;
    nuxtApp.ssrContext.config = {
      public: nuxtApp.ssrContext.runtimeConfig.public,
      app: nuxtApp.ssrContext.runtimeConfig.app
    };
  }
  nuxtApp.hooks = createHooks();
  nuxtApp.hook = nuxtApp.hooks.hook;
  {
    const contextCaller = async function(hooks, args) {
      for (const hook of hooks) {
        await nuxtApp.runWithContext(() => hook(...args));
      }
    };
    nuxtApp.hooks.callHook = (name, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args);
  }
  nuxtApp.callHook = nuxtApp.hooks.callHook;
  nuxtApp.provide = (name, value) => {
    const $name = "$" + name;
    defineGetter(nuxtApp, $name, value);
    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);
  };
  defineGetter(nuxtApp.vueApp, "$nuxt", nuxtApp);
  defineGetter(nuxtApp.vueApp.config.globalProperties, "$nuxt", nuxtApp);
  const runtimeConfig = options.ssrContext.runtimeConfig;
  nuxtApp.provide("config", runtimeConfig);
  return nuxtApp;
}
function registerPluginHooks(nuxtApp, plugin2) {
  if (plugin2.hooks) {
    nuxtApp.hooks.addHooks(plugin2.hooks);
  }
}
async function applyPlugin(nuxtApp, plugin2) {
  if (typeof plugin2 === "function") {
    const { provide: provide2 } = await nuxtApp.runWithContext(() => plugin2(nuxtApp)) || {};
    if (provide2 && typeof provide2 === "object") {
      for (const key in provide2) {
        nuxtApp.provide(key, provide2[key]);
      }
    }
  }
}
async function applyPlugins(nuxtApp, plugins2) {
  const resolvedPlugins = /* @__PURE__ */ new Set();
  const unresolvedPlugins = [];
  const parallels = [];
  let error = void 0;
  let promiseDepth = 0;
  async function executePlugin(plugin2) {
    const unresolvedPluginsForThisPlugin = plugin2.dependsOn?.filter((name) => plugins2.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];
    if (unresolvedPluginsForThisPlugin.length > 0) {
      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin2]);
    } else {
      const promise = applyPlugin(nuxtApp, plugin2).then(async () => {
        if (plugin2._name) {
          resolvedPlugins.add(plugin2._name);
          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {
            if (dependsOn.has(plugin2._name)) {
              dependsOn.delete(plugin2._name);
              if (dependsOn.size === 0) {
                promiseDepth++;
                await executePlugin(unexecutedPlugin);
              }
            }
          }));
        }
      }).catch((e) => {
        if (!plugin2.parallel && !nuxtApp.payload.error) {
          throw e;
        }
        error ||= e;
      });
      if (plugin2.parallel) {
        parallels.push(promise);
      } else {
        await promise;
      }
    }
  }
  for (const plugin2 of plugins2) {
    if (nuxtApp.ssrContext?.islandContext && plugin2.env?.islands === false) {
      continue;
    }
    registerPluginHooks(nuxtApp, plugin2);
  }
  for (const plugin2 of plugins2) {
    if (nuxtApp.ssrContext?.islandContext && plugin2.env?.islands === false) {
      continue;
    }
    await executePlugin(plugin2);
  }
  await Promise.all(parallels);
  if (promiseDepth) {
    for (let i = 0; i < promiseDepth; i++) {
      await Promise.all(parallels);
    }
  }
  if (error) {
    throw nuxtApp.payload.error || error;
  }
}
// @__NO_SIDE_EFFECTS__
function defineNuxtPlugin(plugin2) {
  if (typeof plugin2 === "function") {
    return plugin2;
  }
  const _name = plugin2._name || plugin2.name;
  delete plugin2.name;
  return Object.assign(plugin2.setup || (() => {
  }), plugin2, { [NuxtPluginIndicator]: true, _name });
}
function callWithNuxt(nuxt, setup, args) {
  const fn = () => setup();
  const nuxtAppCtx = getNuxtAppCtx(nuxt._id);
  {
    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));
  }
}
function tryUseNuxtApp(id) {
  let nuxtAppInstance;
  if (vueExports.hasInjectionContext()) {
    nuxtAppInstance = vueExports.getCurrentInstance()?.appContext.app.$nuxt;
  }
  nuxtAppInstance ||= getNuxtAppCtx(id).tryUse();
  return nuxtAppInstance || null;
}
function useNuxtApp(id) {
  const nuxtAppInstance = tryUseNuxtApp(id);
  if (!nuxtAppInstance) {
    {
      throw new Error("[nuxt] instance unavailable");
    }
  }
  return nuxtAppInstance;
}
// @__NO_SIDE_EFFECTS__
function useRuntimeConfig(_event) {
  return useNuxtApp().$config;
}
function defineGetter(obj, key, val) {
  Object.defineProperty(obj, key, { get: () => val });
}
const LayoutMetaSymbol = /* @__PURE__ */ Symbol("layout-meta");
const PageRouteSymbol = /* @__PURE__ */ Symbol("route");
globalThis._importMeta_.url.replace(/\/app\/.*$/, "/");
const useRouter = () => {
  return useNuxtApp()?.$router;
};
const useRoute = () => {
  if (vueExports.hasInjectionContext()) {
    return vueExports.inject(PageRouteSymbol, useNuxtApp()._route);
  }
  return useNuxtApp()._route;
};
// @__NO_SIDE_EFFECTS__
function defineNuxtRouteMiddleware(middleware) {
  return middleware;
}
const isProcessingMiddleware = () => {
  try {
    if (useNuxtApp()._processingMiddleware) {
      return true;
    }
  } catch {
    return false;
  }
  return false;
};
const URL_QUOTE_RE = /"/g;
const navigateTo = (to, options) => {
  to ||= "/";
  const toPath = typeof to === "string" ? to : "path" in to ? resolveRouteObject(to) : useRouter().resolve(to).href;
  const isExternalHost = hasProtocol(toPath, { acceptRelative: true });
  const isExternal = options?.external || isExternalHost;
  if (isExternal) {
    if (!options?.external) {
      throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
    }
    const { protocol } = new URL(toPath, "http://localhost");
    if (protocol && isScriptProtocol(protocol)) {
      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);
    }
  }
  const inMiddleware = isProcessingMiddleware();
  const router = useRouter();
  const nuxtApp = useNuxtApp();
  {
    if (nuxtApp.ssrContext) {
      const fullPath = typeof to === "string" || isExternal ? toPath : router.resolve(to).fullPath || "/";
      const location2 = isExternal ? toPath : joinURL((/* @__PURE__ */ useRuntimeConfig()).app.baseURL, fullPath);
      const redirect = async function(response) {
        await nuxtApp.callHook("app:redirected");
        const encodedLoc = location2.replace(URL_QUOTE_RE, "%22");
        const encodedHeader = encodeURL(location2, isExternalHost);
        nuxtApp.ssrContext._renderResponse = {
          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),
          body: `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`,
          headers: { location: encodedHeader }
        };
        return response;
      };
      if (!isExternal && inMiddleware) {
        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);
        return to;
      }
      return redirect(!inMiddleware ? void 0 : (
        /* abort route navigation */
        false
      ));
    }
  }
  if (isExternal) {
    nuxtApp._scope.stop();
    if (options?.replace) {
      (void 0).replace(toPath);
    } else {
      (void 0).href = toPath;
    }
    if (inMiddleware) {
      if (!nuxtApp.isHydrating) {
        return false;
      }
      return new Promise(() => {
      });
    }
    return Promise.resolve();
  }
  return options?.replace ? router.replace(to) : router.push(to);
};
function resolveRouteObject(to) {
  return withQuery(to.path || "", to.query || {}) + (to.hash || "");
}
function encodeURL(location2, isExternalHost = false) {
  const url = new URL(location2, "http://localhost");
  if (!isExternalHost) {
    return url.pathname + url.search + url.hash;
  }
  if (location2.startsWith("//")) {
    return url.toString().replace(url.protocol, "");
  }
  return url.toString();
}
const NUXT_ERROR_SIGNATURE = "__nuxt_error";
const useError = /* @__NO_SIDE_EFFECTS__ */ () => vueExports.toRef(useNuxtApp().payload, "error");
const showError = (error) => {
  const nuxtError = createError(error);
  try {
    const error2 = /* @__PURE__ */ useError();
    if (false) ;
    error2.value ||= nuxtError;
  } catch {
    throw nuxtError;
  }
  return nuxtError;
};
const isNuxtError = (error) => !!error && typeof error === "object" && NUXT_ERROR_SIGNATURE in error;
const createError = (error) => {
  const nuxtError = createError$2(error);
  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {
    value: true,
    configurable: false,
    writable: false
  });
  return nuxtError;
};
const unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:head",
  enforce: "pre",
  setup(nuxtApp) {
    const head = nuxtApp.ssrContext.head;
    nuxtApp.vueApp.use(head);
  }
});
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
async function getRouteRules(arg) {
  const path = typeof arg === "string" ? arg : arg.path;
  {
    useNuxtApp().ssrContext._preloadManifest = true;
    const _routeRulesMatcher = toRouteMatcher(
      createRouter$2({ routes: (/* @__PURE__ */ useRuntimeConfig()).nitro.routeRules })
    );
    return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());
  }
}
const __nuxt_page_meta$2 = {
  layout: false
};
const __nuxt_page_meta$1 = { layout: false };
const __nuxt_page_meta = {
  layout: "default"
};
const _routes = [
  {
    name: "index",
    path: "/",
    meta: __nuxt_page_meta$2 || {},
    component: () => Promise.resolve().then(function () { return index8YeaYnMR; })
  },
  {
    name: "login",
    path: "/login",
    meta: __nuxt_page_meta$1 || {},
    component: () => Promise.resolve().then(function () { return loginBr7CzZB7; })
  },
  {
    name: "dashboard",
    path: "/dashboard",
    meta: { "middleware": "auth" },
    component: () => Promise.resolve().then(function () { return dashboardDkREg1Jb; })
  },
  {
    name: "holerites",
    path: "/holerites",
    meta: { "middleware": "auth" },
    component: () => Promise.resolve().then(function () { return holeritesCiIcbPKe; })
  },
  {
    name: "meus-dados",
    path: "/meus-dados",
    meta: { "middleware": "auth" },
    component: () => Promise.resolve().then(function () { return meusDadosPAa5nP8t; })
  },
  {
    name: "admin-cargos",
    path: "/admin/cargos",
    meta: { "middleware": ["auth", "admin"] },
    component: () => Promise.resolve().then(function () { return cargosBp2cKJr1; })
  },
  {
    name: "admin-empresas",
    path: "/admin/empresas",
    meta: { "middleware": ["auth", "admin"] },
    component: () => Promise.resolve().then(function () { return empresasBLadY5Os; })
  },
  {
    name: "admin-jornadas",
    path: "/admin/jornadas",
    meta: { "middleware": ["auth", "admin"] },
    component: () => Promise.resolve().then(function () { return jornadasDRvczXH_; })
  },
  {
    name: "admin-holerites",
    path: "/admin/holerites",
    meta: { ...__nuxt_page_meta || {}, ...{ "middleware": "auth" } },
    component: () => Promise.resolve().then(function () { return holeritesBztWzTbT; })
  },
  {
    name: "admin-funcionarios",
    path: "/admin/funcionarios",
    meta: { "middleware": ["auth", "admin"] },
    component: () => Promise.resolve().then(function () { return funcionariosJNGLzgEn; })
  },
  {
    name: "admin-departamentos",
    path: "/admin/departamentos",
    meta: { "middleware": ["auth", "admin"] },
    component: () => Promise.resolve().then(function () { return departamentosCq7NYvfm; })
  }
];
const _wrapInTransition = (props, children) => {
  return { default: () => children.default?.() };
};
const ROUTE_KEY_PARENTHESES_RE = /(:\w+)\([^)]+\)/g;
const ROUTE_KEY_SYMBOLS_RE = /(:\w+)[?+*]/g;
const ROUTE_KEY_NORMAL_RE = /:\w+/g;
function generateRouteKey(route) {
  const source = route?.meta.key ?? route.path.replace(ROUTE_KEY_PARENTHESES_RE, "$1").replace(ROUTE_KEY_SYMBOLS_RE, "$1").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || "");
  return typeof source === "function" ? source(route) : source;
}
function isChangingPage(to, from) {
  if (to === from || from === START_LOCATION_NORMALIZED) {
    return false;
  }
  if (generateRouteKey(to) !== generateRouteKey(from)) {
    return true;
  }
  const areComponentsSame = to.matched.every(
    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default
  );
  if (areComponentsSame) {
    return false;
  }
  return true;
}
const routerOptions0 = {
  scrollBehavior(to, from, savedPosition) {
    const nuxtApp = useNuxtApp();
    const hashScrollBehaviour = useRouter().options?.scrollBehaviorType ?? "auto";
    if (to.path.replace(/\/$/, "") === from.path.replace(/\/$/, "")) {
      if (from.hash && !to.hash) {
        return { left: 0, top: 0 };
      }
      if (to.hash) {
        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior: hashScrollBehaviour };
      }
      return false;
    }
    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === "function" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;
    if (routeAllowsScrollToTop === false) {
      return false;
    }
    const hookToWait = nuxtApp._runningTransition ? "page:transition:finish" : "page:loading:end";
    return new Promise((resolve) => {
      if (from === START_LOCATION_NORMALIZED) {
        resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour));
        return;
      }
      nuxtApp.hooks.hookOnce(hookToWait, () => {
        requestAnimationFrame(() => resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour)));
      });
    });
  }
};
function _getHashElementScrollMarginTop(selector) {
  try {
    const elem = (void 0).querySelector(selector);
    if (elem) {
      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle((void 0).documentElement).scrollPaddingTop) || 0);
    }
  } catch {
  }
  return 0;
}
function _calculatePosition(to, from, savedPosition, defaultHashScrollBehaviour) {
  if (savedPosition) {
    return savedPosition;
  }
  const isPageNavigation = isChangingPage(to, from);
  if (to.hash) {
    return {
      el: to.hash,
      top: _getHashElementScrollMarginTop(to.hash),
      behavior: isPageNavigation ? defaultHashScrollBehaviour : "instant"
    };
  }
  return {
    left: 0,
    top: 0
  };
}
const configRouterOptions = {
  hashMode: false,
  scrollBehaviorType: "auto"
};
const routerOptions = {
  ...configRouterOptions,
  ...routerOptions0
};
const validate = /* @__PURE__ */ defineNuxtRouteMiddleware(async (to, from) => {
  let __temp, __restore;
  if (!to.meta?.validate) {
    return;
  }
  const result = ([__temp, __restore] = executeAsync(() => Promise.resolve(to.meta.validate(to))), __temp = await __temp, __restore(), __temp);
  if (result === true) {
    return;
  }
  const error = createError({
    fatal: false,
    statusCode: result && result.statusCode || 404,
    statusMessage: result && result.statusMessage || `Page Not Found: ${to.fullPath}`,
    data: {
      path: to.fullPath
    }
  });
  return error;
});
const manifest_45route_45rule = /* @__PURE__ */ defineNuxtRouteMiddleware(async (to) => {
  {
    return;
  }
});
const globalMiddleware = [
  validate,
  manifest_45route_45rule
];
const namedMiddleware = {
  admin: () => Promise.resolve().then(function () { return adminDhGiD5Ok; }),
  auth: () => Promise.resolve().then(function () { return authCudmmCPj; })
};
const plugin = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:router",
  enforce: "pre",
  async setup(nuxtApp) {
    let __temp, __restore;
    let routerBase = (/* @__PURE__ */ useRuntimeConfig()).app.baseURL;
    const history = routerOptions.history?.(routerBase) ?? createMemoryHistory(routerBase);
    const routes = routerOptions.routes ? ([__temp, __restore] = executeAsync(() => routerOptions.routes(_routes)), __temp = await __temp, __restore(), __temp) ?? _routes : _routes;
    let startPosition;
    const router = createRouter({
      ...routerOptions,
      scrollBehavior: (to, from, savedPosition) => {
        if (from === START_LOCATION_NORMALIZED) {
          startPosition = savedPosition;
          return;
        }
        if (routerOptions.scrollBehavior) {
          router.options.scrollBehavior = routerOptions.scrollBehavior;
          if ("scrollRestoration" in (void 0).history) {
            const unsub = router.beforeEach(() => {
              unsub();
              (void 0).history.scrollRestoration = "manual";
            });
          }
          return routerOptions.scrollBehavior(to, START_LOCATION_NORMALIZED, startPosition || savedPosition);
        }
      },
      history,
      routes
    });
    nuxtApp.vueApp.use(router);
    const previousRoute = vueExports.shallowRef(router.currentRoute.value);
    router.afterEach((_to, from) => {
      previousRoute.value = from;
    });
    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, "previousRoute", {
      get: () => previousRoute.value
    });
    const initialURL = nuxtApp.ssrContext.url;
    const _route = vueExports.shallowRef(router.currentRoute.value);
    const syncCurrentRoute = () => {
      _route.value = router.currentRoute.value;
    };
    router.afterEach((to, from) => {
      if (to.matched.at(-1)?.components?.default === from.matched.at(-1)?.components?.default) {
        syncCurrentRoute();
      }
    });
    const route = { sync: syncCurrentRoute };
    for (const key in _route.value) {
      Object.defineProperty(route, key, {
        get: () => _route.value[key],
        enumerable: true
      });
    }
    nuxtApp._route = vueExports.shallowReactive(route);
    nuxtApp._middleware ||= {
      global: [],
      named: {}
    };
    if (!nuxtApp.ssrContext?.islandContext) {
      router.afterEach(async (to, _from, failure) => {
        delete nuxtApp._processingMiddleware;
        if (failure) {
          await nuxtApp.callHook("page:loading:end");
        }
        if (failure?.type === 4) {
          return;
        }
        if (to.redirectedFrom && to.fullPath !== initialURL) {
          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || "/"));
        }
      });
    }
    try {
      if (true) {
        ;
        [__temp, __restore] = executeAsync(() => router.push(initialURL)), await __temp, __restore();
        ;
      }
      ;
      [__temp, __restore] = executeAsync(() => router.isReady()), await __temp, __restore();
      ;
    } catch (error2) {
      [__temp, __restore] = executeAsync(() => nuxtApp.runWithContext(() => showError(error2))), await __temp, __restore();
    }
    const resolvedInitialRoute = router.currentRoute.value;
    syncCurrentRoute();
    if (nuxtApp.ssrContext?.islandContext) {
      return { provide: { router } };
    }
    const initialLayout = nuxtApp.payload.state._layout;
    router.beforeEach(async (to, from) => {
      await nuxtApp.callHook("page:loading:start");
      to.meta = vueExports.reactive(to.meta);
      if (nuxtApp.isHydrating && initialLayout && !vueExports.isReadonly(to.meta.layout)) {
        to.meta.layout = initialLayout;
      }
      nuxtApp._processingMiddleware = true;
      if (!nuxtApp.ssrContext?.islandContext) {
        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);
        for (const component of to.matched) {
          const componentMiddleware = component.meta.middleware;
          if (!componentMiddleware) {
            continue;
          }
          for (const entry2 of toArray(componentMiddleware)) {
            middlewareEntries.add(entry2);
          }
        }
        {
          const routeRules = await nuxtApp.runWithContext(() => getRouteRules({ path: to.path }));
          if (routeRules.appMiddleware) {
            for (const key in routeRules.appMiddleware) {
              if (routeRules.appMiddleware[key]) {
                middlewareEntries.add(key);
              } else {
                middlewareEntries.delete(key);
              }
            }
          }
        }
        for (const entry2 of middlewareEntries) {
          const middleware = typeof entry2 === "string" ? nuxtApp._middleware.named[entry2] || await namedMiddleware[entry2]?.().then((r) => r.default || r) : entry2;
          if (!middleware) {
            throw new Error(`Unknown route middleware: '${entry2}'.`);
          }
          try {
            if (false) ;
            const result = await nuxtApp.runWithContext(() => middleware(to, from));
            if (true) {
              if (result === false || result instanceof Error) {
                const error2 = result || createError({
                  statusCode: 404,
                  statusMessage: `Page Not Found: ${initialURL}`
                });
                await nuxtApp.runWithContext(() => showError(error2));
                return false;
              }
            }
            if (result === true) {
              continue;
            }
            if (result === false) {
              return result;
            }
            if (result) {
              if (isNuxtError(result) && result.fatal) {
                await nuxtApp.runWithContext(() => showError(result));
              }
              return result;
            }
          } catch (err) {
            const error2 = createError(err);
            if (error2.fatal) {
              await nuxtApp.runWithContext(() => showError(error2));
            }
            return error2;
          }
        }
      }
    });
    router.onError(async () => {
      delete nuxtApp._processingMiddleware;
      await nuxtApp.callHook("page:loading:end");
    });
    router.afterEach((to) => {
      if (to.matched.length === 0) {
        return nuxtApp.runWithContext(() => showError(createError({
          statusCode: 404,
          fatal: false,
          statusMessage: `Page not found: ${to.fullPath}`,
          data: {
            path: to.fullPath
          }
        })));
      }
    });
    nuxtApp.hooks.hookOnce("app:created", async () => {
      try {
        if ("name" in resolvedInitialRoute) {
          resolvedInitialRoute.name = void 0;
        }
        await router.replace({
          ...resolvedInitialRoute,
          force: true
        });
        router.options.scrollBehavior = routerOptions.scrollBehavior;
      } catch (error2) {
        await nuxtApp.runWithContext(() => showError(error2));
      }
    });
    return { provide: { router } };
  }
});
async function fetchWithRetry(req, init) {
  const retries = 3;
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await fetch(req, init);
    } catch (error) {
      if (init?.signal?.aborted) {
        throw error;
      }
      if (attempt === retries) {
        console.error(`Error fetching request ${req}`, error, init);
        throw error;
      }
      console.warn(`Retrying fetch attempt ${attempt + 1} for request: ${req}`);
      await new Promise((resolve) => setTimeout(resolve, 100 * attempt));
    }
  }
  throw new Error("Unreachable code");
}
function setCookies(event, cookies) {
  const response = event.node.res;
  const headersWritable = () => !response.headersSent && !response.writableEnded;
  if (!headersWritable()) {
    return;
  }
  for (const { name, value, options } of cookies) {
    if (!headersWritable()) {
      break;
    }
    setCookie(event, name, value, options);
  }
}
const serverSupabaseClient = async (event) => {
  if (!event.context._supabaseClient) {
    const { url, key, cookiePrefix, cookieOptions, clientOptions: { auth = {}, global = {} } } = (/* @__PURE__ */ useRuntimeConfig()).public.supabase;
    event.context._supabaseClient = createServerClient(url, key, {
      auth,
      cookies: {
        getAll: () => parseCookieHeader(getHeader(event, "Cookie") ?? ""),
        setAll: (cookies) => setCookies(event, cookies)
      },
      cookieOptions: {
        ...cookieOptions,
        name: cookiePrefix
      },
      global: {
        fetch: fetchWithRetry,
        ...global
      }
    });
  }
  return event.context._supabaseClient;
};
const serverSupabaseUser = async (event) => {
  const client = await serverSupabaseClient(event);
  const { data, error } = await client.auth.getClaims();
  if (error) {
    throw createError$2({ statusMessage: error?.message });
  }
  return data?.claims ?? null;
};
const serverSupabaseSession = async (event) => {
  const client = await serverSupabaseClient(event);
  const { data: { session }, error } = await client.auth.getSession();
  if (error) {
    throw createError$2({ statusMessage: error?.message });
  }
  delete session?.user;
  return session;
};
const useStateKeyPrefix = "$s";
function useState(...args) {
  const autoKey = typeof args[args.length - 1] === "string" ? args.pop() : void 0;
  if (typeof args[0] !== "string") {
    args.unshift(autoKey);
  }
  const [_key, init] = args;
  if (!_key || typeof _key !== "string") {
    throw new TypeError("[nuxt] [useState] key must be a string: " + _key);
  }
  if (init !== void 0 && typeof init !== "function") {
    throw new Error("[nuxt] [useState] init must be a function: " + init);
  }
  const key = useStateKeyPrefix + _key;
  const nuxtApp = useNuxtApp();
  const state = vueExports.toRef(nuxtApp.payload.state, key);
  if (state.value === void 0 && init) {
    const initialValue = init();
    if (vueExports.isRef(initialValue)) {
      nuxtApp.payload.state[key] = initialValue;
      return initialValue;
    }
    state.value = initialValue;
  }
  return state;
}
const useSupabaseSession = () => useState("supabase_session", () => null);
const useSupabaseUser = () => useState("supabase_user", () => null);
function useRequestEvent(nuxtApp) {
  nuxtApp ||= useNuxtApp();
  return nuxtApp.ssrContext?.event;
}
function useRequestFetch() {
  return useRequestEvent()?.$fetch || globalThis.$fetch;
}
const supabase_server_NZuw_NDm2ZtOgvg4QqXN_Xqdg_KPvGuBBWKrLH15GWY = /* @__PURE__ */ defineNuxtPlugin({
  name: "supabase",
  enforce: "pre",
  async setup({ provide: provide2 }) {
    let __temp, __restore;
    const { url, key, cookiePrefix, useSsrCookies, cookieOptions, clientOptions } = (/* @__PURE__ */ useRuntimeConfig()).public.supabase;
    const event = useRequestEvent();
    const client = createServerClient(url, key, {
      ...clientOptions,
      cookies: {
        getAll: () => parseCookieHeader(getHeader(event, "Cookie") ?? ""),
        setAll: (cookies) => setCookies(event, cookies)
      },
      cookieOptions: {
        ...cookieOptions,
        name: cookiePrefix
      },
      global: {
        fetch: fetchWithRetry,
        ...clientOptions.global
      }
    });
    provide2("supabase", { client });
    if (useSsrCookies) {
      const [
        session,
        user
      ] = ([__temp, __restore] = executeAsync(() => Promise.all([
        serverSupabaseSession(event).catch(() => null),
        serverSupabaseUser(event).catch(() => null)
      ])), __temp = await __temp, __restore(), __temp);
      useSupabaseSession().value = session;
      useSupabaseUser().value = user;
    }
  }
});
function definePayloadReducer(name, reduce) {
  {
    useNuxtApp().ssrContext._payloadReducers[name] = reduce;
  }
}
const reducers = [
  ["NuxtError", (data) => isNuxtError(data) && data.toJSON()],
  ["EmptyShallowRef", (data) => vueExports.isRef(data) && vueExports.isShallow(data) && !data.value && (typeof data.value === "bigint" ? "0n" : JSON.stringify(data.value) || "_")],
  ["EmptyRef", (data) => vueExports.isRef(data) && !data.value && (typeof data.value === "bigint" ? "0n" : JSON.stringify(data.value) || "_")],
  ["ShallowRef", (data) => vueExports.isRef(data) && vueExports.isShallow(data) && data.value],
  ["ShallowReactive", (data) => vueExports.isReactive(data) && vueExports.isShallow(data) && vueExports.toRaw(data)],
  ["Ref", (data) => vueExports.isRef(data) && data.value],
  ["Reactive", (data) => vueExports.isReactive(data) && vueExports.toRaw(data)]
];
const revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:revive-payload:server",
  setup() {
    for (const [reducer, fn] of reducers) {
      definePayloadReducer(reducer, fn);
    }
  }
});
const components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8 = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:global-components"
});
const plugins = [
  unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU,
  plugin,
  supabase_server_NZuw_NDm2ZtOgvg4QqXN_Xqdg_KPvGuBBWKrLH15GWY,
  revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms,
  components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8
];
const ServerPlaceholder = vueExports.defineComponent({
  name: "ServerPlaceholder",
  render() {
    return vueExports.createElementBlock("div");
  }
});
const layouts = {
  default: vueExports.defineAsyncComponent(() => Promise.resolve().then(function () { return defaultBkCi9lIN; }).then((m) => m.default || m))
};
const LayoutLoader = vueExports.defineComponent({
  name: "LayoutLoader",
  inheritAttrs: false,
  props: {
    name: String,
    layoutProps: Object
  },
  setup(props, context) {
    return () => vueExports.h(layouts[props.name], props.layoutProps, context.slots);
  }
});
const nuxtLayoutProps = {
  name: {
    type: [String, Boolean, Object],
    default: null
  },
  fallback: {
    type: [String, Object],
    default: null
  }
};
const __nuxt_component_1$5 = vueExports.defineComponent({
  name: "NuxtLayout",
  inheritAttrs: false,
  props: nuxtLayoutProps,
  setup(props, context) {
    const nuxtApp = useNuxtApp();
    const injectedRoute = vueExports.inject(PageRouteSymbol);
    const shouldUseEagerRoute = !injectedRoute || injectedRoute === useRoute();
    const route = shouldUseEagerRoute ? useRoute$1() : injectedRoute;
    const layout = vueExports.computed(() => {
      let layout2 = vueExports.unref(props.name) ?? route?.meta.layout ?? "default";
      if (layout2 && !(layout2 in layouts)) {
        if (props.fallback) {
          layout2 = vueExports.unref(props.fallback);
        }
      }
      return layout2;
    });
    const layoutRef = vueExports.shallowRef();
    context.expose({ layoutRef });
    const done = nuxtApp.deferHydration();
    let lastLayout;
    return () => {
      const hasLayout = layout.value && layout.value in layouts;
      const transitionProps = route?.meta.layoutTransition ?? appLayoutTransition;
      const previouslyRenderedLayout = lastLayout;
      lastLayout = layout.value;
      return _wrapInTransition(hasLayout && transitionProps, {
        default: () => vueExports.h(vueExports.Suspense, { suspensible: true, onResolve: () => {
          vueExports.nextTick(done);
        } }, {
          default: () => vueExports.h(
            LayoutProvider,
            {
              layoutProps: vueExports.mergeProps(context.attrs, { ref: layoutRef }),
              key: layout.value || void 0,
              name: layout.value,
              shouldProvide: !props.name,
              isRenderingNewLayout: (name) => {
                return name !== previouslyRenderedLayout && name === layout.value;
              },
              hasTransition: !!transitionProps
            },
            context.slots
          )
        })
      }).default();
    };
  }
});
const LayoutProvider = vueExports.defineComponent({
  name: "NuxtLayoutProvider",
  inheritAttrs: false,
  props: {
    name: {
      type: [String, Boolean]
    },
    layoutProps: {
      type: Object
    },
    hasTransition: {
      type: Boolean
    },
    shouldProvide: {
      type: Boolean
    },
    isRenderingNewLayout: {
      type: Function,
      required: true
    }
  },
  setup(props, context) {
    const name = props.name;
    if (props.shouldProvide) {
      vueExports.provide(LayoutMetaSymbol, {
        isCurrent: (route) => name === (route.meta.layout ?? "default")
      });
    }
    const injectedRoute = vueExports.inject(PageRouteSymbol);
    const isNotWithinNuxtPage = injectedRoute && injectedRoute === useRoute();
    if (isNotWithinNuxtPage) {
      const vueRouterRoute = useRoute$1();
      const reactiveChildRoute = {};
      for (const _key in vueRouterRoute) {
        const key = _key;
        Object.defineProperty(reactiveChildRoute, key, {
          enumerable: true,
          get: () => {
            return props.isRenderingNewLayout(props.name) ? vueRouterRoute[key] : injectedRoute[key];
          }
        });
      }
      vueExports.provide(PageRouteSymbol, vueExports.shallowReactive(reactiveChildRoute));
    }
    return () => {
      if (!name || typeof name === "string" && !(name in layouts)) {
        return context.slots.default?.();
      }
      return vueExports.h(
        LayoutLoader,
        { key: name, layoutProps: props.layoutProps, name },
        context.slots
      );
    };
  }
});
const defineRouteProvider = (name = "RouteProvider") => vueExports.defineComponent({
  name,
  props: {
    route: {
      type: Object,
      required: true
    },
    vnode: Object,
    vnodeRef: Object,
    renderKey: String,
    trackRootNodes: Boolean
  },
  setup(props) {
    const previousKey = props.renderKey;
    const previousRoute = props.route;
    const route = {};
    for (const key in props.route) {
      Object.defineProperty(route, key, {
        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key],
        enumerable: true
      });
    }
    vueExports.provide(PageRouteSymbol, vueExports.shallowReactive(route));
    return () => {
      if (!props.vnode) {
        return props.vnode;
      }
      return vueExports.h(props.vnode, { ref: props.vnodeRef });
    };
  }
});
const RouteProvider = defineRouteProvider();
const __nuxt_component_2$3 = vueExports.defineComponent({
  name: "NuxtPage",
  inheritAttrs: false,
  props: {
    name: {
      type: String
    },
    transition: {
      type: [Boolean, Object],
      default: void 0
    },
    keepalive: {
      type: [Boolean, Object],
      default: void 0
    },
    route: {
      type: Object
    },
    pageKey: {
      type: [Function, String],
      default: null
    }
  },
  setup(props, { attrs, slots, expose }) {
    const nuxtApp = useNuxtApp();
    const pageRef = vueExports.ref();
    vueExports.inject(PageRouteSymbol, null);
    expose({ pageRef });
    vueExports.inject(LayoutMetaSymbol, null);
    nuxtApp.deferHydration();
    return () => {
      return vueExports.h(RouterView, { name: props.name, route: props.route, ...attrs }, {
        default: (routeProps) => {
          return vueExports.h(vueExports.Suspense, { suspensible: true }, {
            default() {
              return vueExports.h(RouteProvider, {
                vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,
                route: routeProps.route,
                vnodeRef: pageRef
              });
            }
          });
        }
      });
    };
  }
});
function normalizeSlot(slot, data) {
  const slotContent = slot(data);
  return slotContent.length === 1 ? vueExports.h(slotContent[0]) : vueExports.h(vueExports.Fragment, void 0, slotContent);
}
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$2$5 = {};
function _sfc_ssrRender(_ctx, _push, _parent, _attrs) {
  const _component_NuxtRouteAnnouncer = ServerPlaceholder;
  const _component_NuxtLayout = __nuxt_component_1$5;
  const _component_NuxtPage = __nuxt_component_2$3;
  _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
  _push(ssrRenderComponent_1(_component_NuxtRouteAnnouncer, null, null, _parent));
  _push(ssrRenderComponent_1(_component_NuxtLayout, null, {
    default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
      if (_push2) {
        _push2(ssrRenderComponent_1(_component_NuxtPage, null, null, _parent2, _scopeId));
      } else {
        return [
          vueExports.createVNode(_component_NuxtPage)
        ];
      }
    }),
    _: 1
  }, _parent));
  _push(`</div>`);
}
const _sfc_setup$2$5 = _sfc_main$2$5.setup;
_sfc_main$2$5.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("app.vue");
  return _sfc_setup$2$5 ? _sfc_setup$2$5(props, ctx) : void 0;
};
const AppComponent = /* @__PURE__ */ _export_sfc(_sfc_main$2$5, [["ssrRender", _sfc_ssrRender]]);
const _sfc_main$1$a = {
  __name: "nuxt-error-page",
  __ssrInlineRender: true,
  props: {
    error: Object
  },
  setup(__props) {
    const props = __props;
    const _error = props.error;
    const statusCode = Number(_error.statusCode || 500);
    const is404 = statusCode === 404;
    const statusMessage = _error.statusMessage ?? (is404 ? "Page Not Found" : "Internal Server Error");
    const description = _error.message || _error.toString();
    const stack = void 0;
    const _Error404 = vueExports.defineAsyncComponent(() => Promise.resolve().then(function () { return error404EKQ7dIt; }));
    const _Error = vueExports.defineAsyncComponent(() => Promise.resolve().then(function () { return error500WVnta9Y; }));
    const ErrorTemplate = is404 ? _Error404 : _Error;
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent_1(vueExports.unref(ErrorTemplate), vueExports.mergeProps({ statusCode: vueExports.unref(statusCode), statusMessage: vueExports.unref(statusMessage), description: vueExports.unref(description), stack: vueExports.unref(stack) }, _attrs), null, _parent));
    };
  }
};
const _sfc_setup$1$a = _sfc_main$1$a.setup;
_sfc_main$1$a.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/nuxt/dist/app/components/nuxt-error-page.vue");
  return _sfc_setup$1$a ? _sfc_setup$1$a(props, ctx) : void 0;
};
const _sfc_main$v = {
  __name: "nuxt-root",
  __ssrInlineRender: true,
  setup(__props) {
    const IslandRenderer = () => null;
    const nuxtApp = useNuxtApp();
    nuxtApp.deferHydration();
    nuxtApp.ssrContext.url;
    const SingleRenderer = false;
    vueExports.provide(PageRouteSymbol, useRoute());
    nuxtApp.hooks.callHookWith((hooks) => hooks.map((hook) => hook()), "vue:setup");
    const error = /* @__PURE__ */ useError();
    const abortRender = error.value && !nuxtApp.ssrContext.error;
    vueExports.onErrorCaptured((err, target, info) => {
      nuxtApp.hooks.callHook("vue:error", err, target, info).catch((hookError) => console.error("[nuxt] Error in `vue:error` hook", hookError));
      {
        const p = nuxtApp.runWithContext(() => showError(err));
        vueExports.onServerPrefetch(() => p);
        return false;
      }
    });
    const islandContext = nuxtApp.ssrContext.islandContext;
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderSuspense_1(_push, {
        default: () => {
          if (vueExports.unref(abortRender)) {
            _push(`<div></div>`);
          } else if (vueExports.unref(error)) {
            _push(ssrRenderComponent_1(vueExports.unref(_sfc_main$1$a), { error: vueExports.unref(error) }, null, _parent));
          } else if (vueExports.unref(islandContext)) {
            _push(ssrRenderComponent_1(vueExports.unref(IslandRenderer), { context: vueExports.unref(islandContext) }, null, _parent));
          } else if (vueExports.unref(SingleRenderer)) {
            ssrRenderVNode(_push, vueExports.createVNode(vueExports.resolveDynamicComponent(vueExports.unref(SingleRenderer)), null, null), _parent);
          } else {
            _push(ssrRenderComponent_1(vueExports.unref(AppComponent), null, null, _parent));
          }
        },
        _: 1
      });
    };
  }
};
const _sfc_setup$v = _sfc_main$v.setup;
_sfc_main$v.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/nuxt/dist/app/components/nuxt-root.vue");
  return _sfc_setup$v ? _sfc_setup$v(props, ctx) : void 0;
};
let entry;
{
  entry = async function createNuxtAppServer(ssrContext) {
    const vueApp = vueExports.createApp(_sfc_main$v);
    const nuxt = createNuxtApp({ vueApp, ssrContext });
    try {
      await applyPlugins(nuxt, plugins);
      await nuxt.hooks.callHook("app:created", vueApp);
    } catch (error) {
      await nuxt.hooks.callHook("app:error", error);
      nuxt.payload.error ||= createError(error);
    }
    if (ssrContext?._renderResponse) {
      throw new Error("skipping render");
    }
    return vueApp;
  };
}
const entry_default = (ssrContext) => entry(ssrContext);

const server = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  _: _export_sfc,
  a: asyncDataDefaults,
  b: useRequestFetch,
  c: createError,
  d: defineNuxtRouteMiddleware,
  default: entry_default,
  e: useRouter,
  f: fetchDefaults,
  g: useRuntimeConfig,
  h: nuxtLinkDefaults,
  i: useState,
  n: navigateTo,
  r: resolveRouteObject,
  u: useNuxtApp
}, Symbol.toStringTag, { value: 'Module' }));

const client_precomputed = ((h,j,k,m,o,q,u,x,z,A,B,C,D,E,F,G,H,I,J,K,L,N,P,Q,R)=>({dependencies:{"../node_modules/nuxt/dist/app/entry.js":{scripts:{"../node_modules/nuxt/dist/app/entry.js":h={resourceType:"script",module:true,prefetch:true,preload:true,file:"Dof5tm8h.js",name:"entry",src:"../node_modules/nuxt/dist/app/entry.js",isEntry:true,dynamicImports:["middleware/admin.ts","middleware/auth.ts","layouts/default.vue","../node_modules/nuxt/dist/app/components/error-404.vue","../node_modules/nuxt/dist/app/components/error-500.vue"],css:["entry.ByAGmITO.css"]}},styles:{"entry.ByAGmITO.css":j={file:"entry.ByAGmITO.css",resourceType:"style",prefetch:true,preload:true}},preload:{"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_CQeBvCLa.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_CQeBvCLa.js":k={resourceType:"script",module:true,prefetch:true,preload:true,file:"CQeBvCLa.js",name:"nuxt-link",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"../node_modules/nuxt/dist/app/components/error-404.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"../node_modules/nuxt/dist/app/components/error-404.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BQFFphwV.js",name:"error-404",src:"../node_modules/nuxt/dist/app/components/error-404.vue",isDynamicEntry:true,imports:["_CQeBvCLa.js","../node_modules/nuxt/dist/app/entry.js"],css:[]},"_CQeBvCLa.js":k,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"error-404.BLrjNXsr.css":{scripts:{},styles:{},preload:{"error-404.BLrjNXsr.css":{file:"error-404.BLrjNXsr.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"../node_modules/nuxt/dist/app/components/error-500.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"../node_modules/nuxt/dist/app/components/error-500.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BasvsJfT.js",name:"error-500",src:"../node_modules/nuxt/dist/app/components/error-500.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js"],css:[]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"error-500.DLkAwcfL.css":{scripts:{},styles:{},preload:{"error-500.DLkAwcfL.css":{file:"error-500.DLkAwcfL.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"entry.ByAGmITO.css":{scripts:{},styles:{},preload:{"entry.ByAGmITO.css":j},prefetch:{}},"_B3hq736_.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_B3hq736_.js":m={resourceType:"script",module:true,prefetch:true,preload:true,file:"B3hq736_.js",name:"UiCard",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_BBj1TRlb.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_BBj1TRlb.js":o={resourceType:"script",module:true,prefetch:true,preload:true,file:"BBj1TRlb.js",name:"useEmpresas",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_BW7GBc6I.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_BW7GBc6I.js":q={resourceType:"script",module:true,prefetch:true,preload:true,file:"BW7GBc6I.js",name:"UiAvatar",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_BgxB08uW.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_BgxB08uW.js":u={resourceType:"script",module:true,prefetch:true,preload:true,file:"BgxB08uW.js",name:"UiInput",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_C8njRs9f.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_C8njRs9f.js":x={resourceType:"script",module:true,prefetch:true,preload:true,file:"C8njRs9f.js",name:"UiButton",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_CC42nqUQ.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_CC42nqUQ.js":z={resourceType:"script",module:true,prefetch:true,preload:true,file:"CC42nqUQ.js",name:"useJornadas",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_CE9WuSm3.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_CE9WuSm3.js":A={resourceType:"script",module:true,prefetch:true,preload:true,file:"CE9WuSm3.js",name:"UiInputPIS",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_CxnKBDNi.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_CxnKBDNi.js":B={resourceType:"script",module:true,prefetch:true,preload:true,file:"CxnKBDNi.js",name:"useAuth",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_pPNOfkqo.js":{scripts:{},styles:{"UiModal.DV4OCzM3.css":C={file:"UiModal.DV4OCzM3.css",resourceType:"style",prefetch:true,preload:true},"entry.ByAGmITO.css":j},preload:{"_pPNOfkqo.js":D={resourceType:"script",module:true,prefetch:true,preload:true,file:"pPNOfkqo.js",name:"UiModal",imports:["../node_modules/nuxt/dist/app/entry.js"],css:["UiModal.DV4OCzM3.css"]},"UiModal.DV4OCzM3.css":C,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"UiModal.DV4OCzM3.css":C,"entry.ByAGmITO.css":j}},"_D3Q7_TfH.js":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C},preload:{"_D3Q7_TfH.js":E={resourceType:"script",module:true,prefetch:true,preload:true,file:"D3Q7_TfH.js",name:"HoleriteModal",imports:["../node_modules/nuxt/dist/app/entry.js","_C8njRs9f.js","_pPNOfkqo.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_C8njRs9f.js":x,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C}},"_D9PHrWlS.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_D9PHrWlS.js":F={resourceType:"script",module:true,prefetch:true,preload:true,file:"D9PHrWlS.js",name:"UiBadge",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_De7f5VEw.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_De7f5VEw.js":G={resourceType:"script",module:true,prefetch:true,preload:true,file:"De7f5VEw.js",name:"UiCheckbox",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_Dg3QPo2K.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_Dg3QPo2K.js":H={resourceType:"script",module:true,prefetch:true,preload:true,file:"Dg3QPo2K.js",name:"UiAlert",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_JOt2cbnr.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_JOt2cbnr.js":I={resourceType:"script",module:true,prefetch:true,preload:true,file:"JOt2cbnr.js",name:"UiTextarea",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_NU8WpVql.js":{scripts:{},styles:{"UiNotification.Dr6F62AN.css":J={file:"UiNotification.Dr6F62AN.css",resourceType:"style",prefetch:true,preload:true},"entry.ByAGmITO.css":j},preload:{"_NU8WpVql.js":K={resourceType:"script",module:true,prefetch:true,preload:true,file:"NU8WpVql.js",name:"UiNotification",imports:["../node_modules/nuxt/dist/app/entry.js"],css:["UiNotification.Dr6F62AN.css"]},"UiNotification.Dr6F62AN.css":J,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"UiNotification.Dr6F62AN.css":J,"entry.ByAGmITO.css":j}},"UiNotification.Dr6F62AN.css":{scripts:{},styles:{},preload:{"UiNotification.Dr6F62AN.css":J},prefetch:{}},"_UiModal.DV4OCzM3.css":{scripts:{},styles:{},preload:{"_UiModal.DV4OCzM3.css":{resourceType:"style",prefetch:true,preload:true,file:"UiModal.DV4OCzM3.css",src:"_UiModal.DV4OCzM3.css"}},prefetch:{}},"_UiNotification.Dr6F62AN.css":{scripts:{},styles:{},preload:{"_UiNotification.Dr6F62AN.css":{resourceType:"style",prefetch:true,preload:true,file:"UiNotification.Dr6F62AN.css",src:"_UiNotification.Dr6F62AN.css"}},prefetch:{}},"_bxN1EH-H.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_bxN1EH-H.js":L={resourceType:"script",module:true,prefetch:true,preload:true,file:"bxN1EH-H.js",name:"useCargos",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_csONegst.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_csONegst.js":N={resourceType:"script",module:true,prefetch:true,preload:true,file:"csONegst.js",name:"UiSelect",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"_oGf0Z06W.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_oGf0Z06W.js":P={resourceType:"script",module:true,prefetch:true,preload:true,file:"oGf0Z06W.js",name:"UiPageHeader",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"UiModal.DV4OCzM3.css":{scripts:{},styles:{},preload:{"UiModal.DV4OCzM3.css":C},prefetch:{}},"_vU175HOc.js":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"_vU175HOc.js":Q={resourceType:"script",module:true,prefetch:true,preload:true,file:"vU175HOc.js",name:"useAdmin",imports:["../node_modules/nuxt/dist/app/entry.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"layouts/default.vue":{scripts:{},styles:{"default.hv7OosX6.css":R={file:"default.hv7OosX6.css",resourceType:"style",prefetch:true,preload:true},"entry.ByAGmITO.css":j},preload:{"layouts/default.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"Dg0kh9aV.js",name:"default",src:"layouts/default.vue",isDynamicEntry:true,imports:["_CQeBvCLa.js","../node_modules/nuxt/dist/app/entry.js","_BW7GBc6I.js","_CxnKBDNi.js"],css:["default.hv7OosX6.css"]},"default.hv7OosX6.css":R,"_CQeBvCLa.js":k,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_BW7GBc6I.js":q,"_CxnKBDNi.js":B},prefetch:{"default.hv7OosX6.css":R,"entry.ByAGmITO.css":j}},"default.hv7OosX6.css":{scripts:{},styles:{},preload:{"default.hv7OosX6.css":R},prefetch:{}},"middleware/admin.ts":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"middleware/admin.ts":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DfQKilaR.js",name:"admin",src:"middleware/admin.ts",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_CxnKBDNi.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_CxnKBDNi.js":B},prefetch:{"entry.ByAGmITO.css":j}},"middleware/auth.ts":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"middleware/auth.ts":{resourceType:"script",module:true,prefetch:true,preload:true,file:"WGyxVUrI.js",name:"auth",src:"middleware/auth.ts",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_CxnKBDNi.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_CxnKBDNi.js":B},prefetch:{"entry.ByAGmITO.css":j}},"pages/admin/cargos.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J},preload:{"pages/admin/cargos.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"B4b02wwK.js",name:"cargos",src:"pages/admin/cargos.vue",isDynamicEntry:true,imports:["_C8njRs9f.js","_oGf0Z06W.js","_B3hq736_.js","_BgxB08uW.js","_JOt2cbnr.js","_csONegst.js","_pPNOfkqo.js","_NU8WpVql.js","../node_modules/nuxt/dist/app/entry.js","_bxN1EH-H.js"]},"_C8njRs9f.js":x,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_oGf0Z06W.js":P,"_B3hq736_.js":m,"_BgxB08uW.js":u,"_JOt2cbnr.js":I,"_csONegst.js":N,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_NU8WpVql.js":K,"UiNotification.Dr6F62AN.css":J,"_bxN1EH-H.js":L},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J}},"pages/admin/departamentos.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J},preload:{"pages/admin/departamentos.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CF4DT5E7.js",name:"departamentos",src:"pages/admin/departamentos.vue",isDynamicEntry:true,imports:["_C8njRs9f.js","_oGf0Z06W.js","_B3hq736_.js","_BgxB08uW.js","_JOt2cbnr.js","_csONegst.js","_pPNOfkqo.js","_NU8WpVql.js","../node_modules/nuxt/dist/app/entry.js","_vU175HOc.js"]},"_C8njRs9f.js":x,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_oGf0Z06W.js":P,"_B3hq736_.js":m,"_BgxB08uW.js":u,"_JOt2cbnr.js":I,"_csONegst.js":N,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_NU8WpVql.js":K,"UiNotification.Dr6F62AN.css":J,"_vU175HOc.js":Q},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J}},"pages/admin/empresas.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J},preload:{"pages/admin/empresas.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BlHcu9nE.js",name:"empresas",src:"pages/admin/empresas.vue",isDynamicEntry:true,imports:["_C8njRs9f.js","_oGf0Z06W.js","_D9PHrWlS.js","_B3hq736_.js","../node_modules/nuxt/dist/app/entry.js","_BgxB08uW.js","_csONegst.js","_De7f5VEw.js","_pPNOfkqo.js","_Dg3QPo2K.js","_NU8WpVql.js","_BBj1TRlb.js"]},"_C8njRs9f.js":x,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_oGf0Z06W.js":P,"_D9PHrWlS.js":F,"_B3hq736_.js":m,"_BgxB08uW.js":u,"_csONegst.js":N,"_De7f5VEw.js":G,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_Dg3QPo2K.js":H,"_NU8WpVql.js":K,"UiNotification.Dr6F62AN.css":J,"_BBj1TRlb.js":o},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J}},"pages/admin/funcionarios.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J},preload:{"pages/admin/funcionarios.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CdTpTACM.js",name:"funcionarios",src:"pages/admin/funcionarios.vue",isDynamicEntry:true,imports:["_C8njRs9f.js","_oGf0Z06W.js","_B3hq736_.js","_pPNOfkqo.js","_NU8WpVql.js","../node_modules/nuxt/dist/app/entry.js","_De7f5VEw.js","_BgxB08uW.js","_csONegst.js","_CE9WuSm3.js","_CC42nqUQ.js","_BBj1TRlb.js","_bxN1EH-H.js","_vU175HOc.js","_BW7GBc6I.js","_D9PHrWlS.js"]},"_C8njRs9f.js":x,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_oGf0Z06W.js":P,"_B3hq736_.js":m,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_NU8WpVql.js":K,"UiNotification.Dr6F62AN.css":J,"_De7f5VEw.js":G,"_BgxB08uW.js":u,"_csONegst.js":N,"_CE9WuSm3.js":A,"_CC42nqUQ.js":z,"_BBj1TRlb.js":o,"_bxN1EH-H.js":L,"_vU175HOc.js":Q,"_BW7GBc6I.js":q,"_D9PHrWlS.js":F},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J}},"pages/admin/holerites.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J},preload:{"pages/admin/holerites.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DnJjMrKv.js",name:"holerites",src:"pages/admin/holerites.vue",isDynamicEntry:true,imports:["_C8njRs9f.js","_csONegst.js","_D3Q7_TfH.js","_pPNOfkqo.js","_NU8WpVql.js","../node_modules/nuxt/dist/app/entry.js","_BgxB08uW.js","_Dg3QPo2K.js"]},"_C8njRs9f.js":x,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_csONegst.js":N,"_D3Q7_TfH.js":E,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_NU8WpVql.js":K,"UiNotification.Dr6F62AN.css":J,"_BgxB08uW.js":u,"_Dg3QPo2K.js":H},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J}},"pages/admin/jornadas.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J},preload:{"pages/admin/jornadas.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CgCQk-Uv.js",name:"jornadas",src:"pages/admin/jornadas.vue",isDynamicEntry:true,imports:["_C8njRs9f.js","_oGf0Z06W.js","_D9PHrWlS.js","_B3hq736_.js","_pPNOfkqo.js","_NU8WpVql.js","_CC42nqUQ.js","../node_modules/nuxt/dist/app/entry.js","_BgxB08uW.js","_De7f5VEw.js","_Dg3QPo2K.js"]},"_C8njRs9f.js":x,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_oGf0Z06W.js":P,"_D9PHrWlS.js":F,"_B3hq736_.js":m,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_NU8WpVql.js":K,"UiNotification.Dr6F62AN.css":J,"_CC42nqUQ.js":z,"_BgxB08uW.js":u,"_De7f5VEw.js":G,"_Dg3QPo2K.js":H},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C,"UiNotification.Dr6F62AN.css":J}},"pages/dashboard.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"pages/dashboard.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DZnlOBm2.js",name:"dashboard",src:"pages/dashboard.vue",isDynamicEntry:true,imports:["../node_modules/nuxt/dist/app/entry.js","_D9PHrWlS.js","_B3hq736_.js","_CQeBvCLa.js","_CxnKBDNi.js"]},"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_D9PHrWlS.js":F,"_B3hq736_.js":m,"_CQeBvCLa.js":k,"_CxnKBDNi.js":B},prefetch:{"entry.ByAGmITO.css":j}},"pages/holerites.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C},preload:{"pages/holerites.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BgWbzoC9.js",name:"holerites",src:"pages/holerites.vue",isDynamicEntry:true,imports:["_C8njRs9f.js","_D3Q7_TfH.js","../node_modules/nuxt/dist/app/entry.js","_CxnKBDNi.js","_pPNOfkqo.js"]},"_C8njRs9f.js":x,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_D3Q7_TfH.js":E,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_CxnKBDNi.js":B},prefetch:{"entry.ByAGmITO.css":j,"UiModal.DV4OCzM3.css":C}},"pages/index.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"pages/index.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"CTk-SFT0.js",name:"index",src:"pages/index.vue",isDynamicEntry:true,imports:["_CxnKBDNi.js","../node_modules/nuxt/dist/app/entry.js"]},"_CxnKBDNi.js":B,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j},prefetch:{"entry.ByAGmITO.css":j}},"pages/login.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j},preload:{"pages/login.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"DMuSzAsc.js",name:"login",src:"pages/login.vue",isDynamicEntry:true,imports:["_BgxB08uW.js","_C8njRs9f.js","../node_modules/nuxt/dist/app/entry.js","_CxnKBDNi.js"],css:[]},"_BgxB08uW.js":u,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_C8njRs9f.js":x,"_CxnKBDNi.js":B},prefetch:{"entry.ByAGmITO.css":j}},"login.DcJIUzVO.css":{scripts:{},styles:{},preload:{"login.DcJIUzVO.css":{file:"login.DcJIUzVO.css",resourceType:"style",prefetch:true,preload:true}},prefetch:{}},"pages/meus-dados.vue":{scripts:{},styles:{"entry.ByAGmITO.css":j,"UiNotification.Dr6F62AN.css":J,"UiModal.DV4OCzM3.css":C},preload:{"pages/meus-dados.vue":{resourceType:"script",module:true,prefetch:true,preload:true,file:"BOpLbSbZ.js",name:"meus-dados",src:"pages/meus-dados.vue",isDynamicEntry:true,imports:["_oGf0Z06W.js","_BW7GBc6I.js","_C8njRs9f.js","_D9PHrWlS.js","_B3hq736_.js","_BgxB08uW.js","../node_modules/nuxt/dist/app/entry.js","_csONegst.js","_CE9WuSm3.js","_Dg3QPo2K.js","_NU8WpVql.js","_pPNOfkqo.js","_CxnKBDNi.js"]},"_oGf0Z06W.js":P,"../node_modules/nuxt/dist/app/entry.js":h,"entry.ByAGmITO.css":j,"_BW7GBc6I.js":q,"_C8njRs9f.js":x,"_D9PHrWlS.js":F,"_B3hq736_.js":m,"_BgxB08uW.js":u,"_csONegst.js":N,"_CE9WuSm3.js":A,"_Dg3QPo2K.js":H,"_NU8WpVql.js":K,"UiNotification.Dr6F62AN.css":J,"_pPNOfkqo.js":D,"UiModal.DV4OCzM3.css":C,"_CxnKBDNi.js":B},prefetch:{"entry.ByAGmITO.css":j,"UiNotification.Dr6F62AN.css":J,"UiModal.DV4OCzM3.css":C}}},entrypoints:["../node_modules/nuxt/dist/app/entry.js"],modules:{"../node_modules/nuxt/dist/app/components/error-404.vue":{file:"BQFFphwV.js",resourceType:"script",mimeType:void 0,module:true},"error-404.BLrjNXsr.css":{file:"error-404.BLrjNXsr.css",resourceType:"style",mimeType:void 0,module:void 0},"../node_modules/nuxt/dist/app/components/error-500.vue":{file:"BasvsJfT.js",resourceType:"script",mimeType:void 0,module:true},"error-500.DLkAwcfL.css":{file:"error-500.DLkAwcfL.css",resourceType:"style",mimeType:void 0,module:void 0},"../node_modules/nuxt/dist/app/entry.js":{file:"Dof5tm8h.js",resourceType:"script",mimeType:void 0,module:true},"entry.ByAGmITO.css":{file:"entry.ByAGmITO.css",resourceType:"style",mimeType:void 0,module:void 0},"_B3hq736_.js":{file:"B3hq736_.js",resourceType:"script",mimeType:void 0,module:true},"_BBj1TRlb.js":{file:"BBj1TRlb.js",resourceType:"script",mimeType:void 0,module:true},"_BW7GBc6I.js":{file:"BW7GBc6I.js",resourceType:"script",mimeType:void 0,module:true},"_BgxB08uW.js":{file:"BgxB08uW.js",resourceType:"script",mimeType:void 0,module:true},"_C8njRs9f.js":{file:"C8njRs9f.js",resourceType:"script",mimeType:void 0,module:true},"_CC42nqUQ.js":{file:"CC42nqUQ.js",resourceType:"script",mimeType:void 0,module:true},"_CE9WuSm3.js":{file:"CE9WuSm3.js",resourceType:"script",mimeType:void 0,module:true},"_CQeBvCLa.js":{file:"CQeBvCLa.js",resourceType:"script",mimeType:void 0,module:true},"_CxnKBDNi.js":{file:"CxnKBDNi.js",resourceType:"script",mimeType:void 0,module:true},"_D3Q7_TfH.js":{file:"D3Q7_TfH.js",resourceType:"script",mimeType:void 0,module:true},"_D9PHrWlS.js":{file:"D9PHrWlS.js",resourceType:"script",mimeType:void 0,module:true},"_De7f5VEw.js":{file:"De7f5VEw.js",resourceType:"script",mimeType:void 0,module:true},"_Dg3QPo2K.js":{file:"Dg3QPo2K.js",resourceType:"script",mimeType:void 0,module:true},"_JOt2cbnr.js":{file:"JOt2cbnr.js",resourceType:"script",mimeType:void 0,module:true},"_NU8WpVql.js":{file:"NU8WpVql.js",resourceType:"script",mimeType:void 0,module:true},"UiNotification.Dr6F62AN.css":{file:"UiNotification.Dr6F62AN.css",resourceType:"style",mimeType:void 0,module:void 0},"_UiModal.DV4OCzM3.css":{file:"UiModal.DV4OCzM3.css",resourceType:"style",mimeType:void 0,module:void 0},"_UiNotification.Dr6F62AN.css":{file:"UiNotification.Dr6F62AN.css",resourceType:"style",mimeType:void 0,module:void 0},"_bxN1EH-H.js":{file:"bxN1EH-H.js",resourceType:"script",mimeType:void 0,module:true},"_csONegst.js":{file:"csONegst.js",resourceType:"script",mimeType:void 0,module:true},"_oGf0Z06W.js":{file:"oGf0Z06W.js",resourceType:"script",mimeType:void 0,module:true},"_pPNOfkqo.js":{file:"pPNOfkqo.js",resourceType:"script",mimeType:void 0,module:true},"UiModal.DV4OCzM3.css":{file:"UiModal.DV4OCzM3.css",resourceType:"style",mimeType:void 0,module:void 0},"_vU175HOc.js":{file:"vU175HOc.js",resourceType:"script",mimeType:void 0,module:true},"layouts/default.vue":{file:"Dg0kh9aV.js",resourceType:"script",mimeType:void 0,module:true},"default.hv7OosX6.css":{file:"default.hv7OosX6.css",resourceType:"style",mimeType:void 0,module:void 0},"middleware/admin.ts":{file:"DfQKilaR.js",resourceType:"script",mimeType:void 0,module:true},"middleware/auth.ts":{file:"WGyxVUrI.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/cargos.vue":{file:"B4b02wwK.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/departamentos.vue":{file:"CF4DT5E7.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/empresas.vue":{file:"BlHcu9nE.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/funcionarios.vue":{file:"CdTpTACM.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/holerites.vue":{file:"DnJjMrKv.js",resourceType:"script",mimeType:void 0,module:true},"pages/admin/jornadas.vue":{file:"CgCQk-Uv.js",resourceType:"script",mimeType:void 0,module:true},"pages/dashboard.vue":{file:"DZnlOBm2.js",resourceType:"script",mimeType:void 0,module:true},"pages/holerites.vue":{file:"BgWbzoC9.js",resourceType:"script",mimeType:void 0,module:true},"pages/index.vue":{file:"CTk-SFT0.js",resourceType:"script",mimeType:void 0,module:true},"pages/login.vue":{file:"DMuSzAsc.js",resourceType:"script",mimeType:void 0,module:true},"login.DcJIUzVO.css":{file:"login.DcJIUzVO.css",resourceType:"style",mimeType:void 0,module:void 0},"pages/meus-dados.vue":{file:"BOpLbSbZ.js",resourceType:"script",mimeType:void 0,module:true}}}))();

const client_precomputed$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: client_precomputed
}, Symbol.toStringTag, { value: 'Module' }));

const template = "";

const _virtual__spaTemplate = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  template: template
}, Symbol.toStringTag, { value: 'Module' }));

const interopDefault = r => r.default || r || [];
const styles = {
  "pages/login.vue": () => Promise.resolve().then(function () { return loginStyles_b2cz1sfn$1; }).then(interopDefault),
  "pages/login.vue?vue&type=style&index=0&scoped=adb25b66&lang.css": () => Promise.resolve().then(function () { return loginStyles_b2cz1sfn$1; }).then(interopDefault),
  "../node_modules/nuxt/dist/app/components/error-500.vue": () => Promise.resolve().then(function () { return error500Styles_Dw4YpQp$1; }).then(interopDefault),
  "../node_modules/nuxt/dist/app/components/error-404.vue": () => Promise.resolve().then(function () { return error404Styles_SO9LtFGn$1; }).then(interopDefault),
  "../node_modules/nuxt/dist/app/components/error-500.vue?vue&type=style&index=0&scoped=8851f357&lang.css": () => Promise.resolve().then(function () { return error500Styles_Dw4YpQp$1; }).then(interopDefault),
  "../node_modules/nuxt/dist/app/components/error-404.vue?vue&type=style&index=0&scoped=cd31e6b7&lang.css": () => Promise.resolve().then(function () { return error404Styles_SO9LtFGn$1; }).then(interopDefault),
  "components/ui/UiNotification.vue": () => Promise.resolve().then(function () { return UiNotificationStyles_BJrdoWL$1; }).then(interopDefault),
  "components/ui/UiModal.vue": () => Promise.resolve().then(function () { return UiModalStyles_0VvhfPF$1; }).then(interopDefault),
  "components/ui/UiNotification.vue?vue&type=style&index=0&scoped=09772c10&lang.css": () => Promise.resolve().then(function () { return UiNotificationStyles_BJrdoWL$1; }).then(interopDefault),
  "components/ui/UiModal.vue?vue&type=style&index=0&scoped=d7b8f265&lang.css": () => Promise.resolve().then(function () { return UiModalStyles_0VvhfPF$1; }).then(interopDefault),
  "components/layout/LayoutMobileMenu.vue": () => Promise.resolve().then(function () { return LayoutMobileMenuStyles_D4G5Vume$1; }).then(interopDefault),
  "components/layout/LayoutMobileMenu.vue?vue&type=style&index=0&scoped=a39f9b9e&lang.css": () => Promise.resolve().then(function () { return LayoutMobileMenuStyles_D4G5Vume$1; }).then(interopDefault)
};

const styles$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: styles
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$u = /* @__PURE__ */ vueExports.defineComponent({
  __name: "index",
  __ssrInlineRender: true,
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "flex items-center justify-center min-h-screen" }, _attrs))}><div class="text-center"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div><p class="mt-4 text-gray-600">Carregando...</p></div></div>`);
    };
  }
});
const _sfc_setup$u = _sfc_main$u.setup;
_sfc_main$u.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/index.vue");
  return _sfc_setup$u ? _sfc_setup$u(props, ctx) : void 0;
};

const index8YeaYnMR = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$u
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$t = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiInput",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    type: { default: "text" },
    label: {},
    placeholder: {},
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    icon: {},
    hint: {},
    error: {},
    showPasswordToggle: { type: Boolean, default: false },
    uppercase: { type: Boolean, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const id = vueExports.computed(() => `input-${Math.random().toString(36).substr(2, 9)}`);
    const passwordVisible = vueExports.ref(false);
    const computedType = vueExports.computed(() => {
      if (props.type === "password" && passwordVisible.value) return "text";
      return props.type;
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", vueExports.unref(id))} class="block text-sm font-medium text-gray-600 mb-1">${ssrInterpolate_1(__props.label)} `);
        if (__props.required) {
          _push(`<span class="text-red-500">*</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="relative">`);
      if (__props.icon) {
        _push(`<span class="absolute left-4 top-1/2 -translate-y-1/2 text-lg">${ssrInterpolate_1(__props.icon)}</span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<input${ssrRenderAttr_1("id", vueExports.unref(id))}${ssrRenderAttr_1("type", vueExports.unref(computedType))}${ssrRenderAttr_1("value", __props.modelValue)}${ssrRenderAttr_1("placeholder", __props.placeholder)}${ssrIncludeBooleanAttr(__props.disabled) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""} class="${ssrRenderClass_1([
        "w-full px-4 py-3 text-lg border-2 rounded-xl outline-none transition-colors",
        __props.icon ? "pl-12" : "",
        __props.showPasswordToggle ? "pr-14" : "",
        __props.disabled ? "border-gray-100 bg-gray-50 text-gray-500" : "border-gray-200 focus:border-primary-500 focus:ring-4 focus:ring-primary-100",
        __props.error ? "border-red-300" : "",
        __props.uppercase && __props.type !== "password" && __props.type !== "email" ? "uppercase" : ""
      ])}" style="${ssrRenderStyle_1(__props.uppercase && __props.type !== "password" && __props.type !== "email" ? "text-transform: uppercase;" : "")}">`);
      if (__props.showPasswordToggle && __props.type === "password") {
        _push(`<button type="button" class="absolute right-4 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600 p-1 transition-colors" tabindex="-1">`);
        if (!vueExports.unref(passwordVisible)) {
          _push(`<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`);
        } else {
          _push(`<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>`);
        }
        _push(`</button>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      if (__props.hint && !__props.error) {
        _push(`<p class="text-xs text-gray-400 mt-1">${ssrInterpolate_1(__props.hint)}</p>`);
      } else {
        _push(`<!---->`);
      }
      if (__props.error) {
        _push(`<p class="text-xs text-red-500 mt-1">${ssrInterpolate_1(__props.error)}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$t = _sfc_main$t.setup;
_sfc_main$t.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiInput.vue");
  return _sfc_setup$t ? _sfc_setup$t(props, ctx) : void 0;
};
const __nuxt_component_4 = Object.assign(_sfc_main$t, { __name: "UiInput" });

const _sfc_main$s = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiButton",
  __ssrInlineRender: true,
  props: {
    type: { default: "button" },
    variant: { default: "primary" },
    size: { default: "md" },
    disabled: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    icon: {}
  },
  setup(__props) {
    const props = __props;
    const sizeClasses = vueExports.computed(() => {
      const sizes = {
        sm: "px-3 py-2 text-sm",
        md: "px-4 py-3 text-base",
        lg: "px-6 py-4 text-lg font-bold"
      };
      return sizes[props.size];
    });
    const variantClasses = vueExports.computed(() => {
      const variants = {
        primary: "text-white bg-primary-600 hover:bg-primary-700 focus:ring-primary-200",
        secondary: "text-gray-600 bg-gray-100 hover:bg-gray-200 focus:ring-gray-200",
        danger: "text-red-600 bg-red-50 hover:bg-red-100 focus:ring-red-200",
        success: "text-white bg-green-600 hover:bg-green-700 focus:ring-green-200",
        ghost: "text-primary-600 bg-primary-50 hover:bg-primary-100 focus:ring-primary-200"
      };
      return variants[props.variant];
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<button${ssrRenderAttrs_1(vueExports.mergeProps({
        type: __props.type,
        disabled: __props.disabled || __props.loading,
        class: [
          "inline-flex items-center justify-center gap-2 font-medium rounded-xl transition-all",
          "focus:ring-4 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed",
          vueExports.unref(sizeClasses),
          vueExports.unref(variantClasses)
        ]
      }, _attrs))}>`);
      if (__props.loading) {
        _push(`<svg class="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`);
      } else {
        _push(`<!---->`);
      }
      if (__props.icon && !__props.loading) {
        _push(`<span class="text-lg">${ssrInterpolate_1(__props.icon)}</span>`);
      } else {
        _push(`<!---->`);
      }
      ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</button>`);
    };
  }
});
const _sfc_setup$s = _sfc_main$s.setup;
_sfc_main$s.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiButton.vue");
  return _sfc_setup$s ? _sfc_setup$s(props, ctx) : void 0;
};
const __nuxt_component_1$4 = Object.assign(_sfc_main$s, { __name: "UiButton" });

const useAuth = () => {
  const user = useState("auth-user", () => {
    return null;
  });
  const isAuthenticated = vueExports.computed(() => !!user.value);
  const isAdmin = vueExports.computed(() => user.value?.tipo === "admin");
  const login = async (email, senha) => {
    try {
      const response = await $fetch("/api/auth/login", {
        method: "POST",
        body: { email, senha }
      });
      if (response.success && response.user) {
        user.value = response.user;
        if (false) ;
        return { success: true, message: "Login realizado com sucesso!" };
      }
      return { success: false, message: "Email ou senha incorretos. Tente novamente." };
    } catch (error) {
      console.error("Erro no login:", error);
      return {
        success: false,
        message: error.data?.message || "Email ou senha incorretos. Tente novamente."
      };
    }
  };
  const logout = () => {
    user.value = null;
    navigateTo("/login");
  };
  const updateUser = (updatedData) => {
    if (user.value) {
      user.value = { ...user.value, ...updatedData };
    }
  };
  return {
    user,
    isAuthenticated,
    isAdmin,
    login,
    logout,
    updateUser
  };
};

const _imports_0 = publicAssetsURL("/images/qualitec_logo.png");
const _sfc_main$r = /* @__PURE__ */ vueExports.defineComponent({
  __name: "login",
  __ssrInlineRender: true,
  setup(__props) {
    useAuth();
    const email = vueExports.ref("");
    const senha = vueExports.ref("");
    const loading = vueExports.ref(false);
    const error = vueExports.ref("");
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiInput = __nuxt_component_4;
      const _component_UiButton = __nuxt_component_1$4;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-800 flex items-center justify-center p-4 relative overflow-hidden" }, _attrs))} data-v-adb25b66><div class="absolute inset-0 opacity-5" data-v-adb25b66><div class="absolute inset-0" style="${ssrRenderStyle_1({ "background-image": "radial-gradient(circle at 1px 1px, rgba(255,255,255,0.3) 1px, transparent 0)", "background-size": "20px 20px" })}" data-v-adb25b66></div><div class="absolute top-10 left-10 w-16 h-16 border-2 border-blue-300 rounded-full" data-v-adb25b66></div><div class="absolute top-32 right-20 w-12 h-12 border-2 border-blue-400 rotate-45" data-v-adb25b66></div><div class="absolute bottom-20 left-20 w-20 h-20 border-2 border-blue-300 rounded-full" data-v-adb25b66></div><div class="absolute bottom-40 right-32 w-14 h-14 border-2 border-blue-400 rotate-12" data-v-adb25b66></div><div class="absolute top-1/4 left-1/4 w-8 h-8 border border-blue-300 transform rotate-30" style="${ssrRenderStyle_1({ "clip-path": "polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%)" })}" data-v-adb25b66></div><div class="absolute bottom-1/4 right-1/4 w-6 h-6 border border-blue-400 transform rotate-45" style="${ssrRenderStyle_1({ "clip-path": "polygon(30% 0%, 70% 0%, 100% 50%, 70% 100%, 30% 100%, 0% 50%)" })}" data-v-adb25b66></div></div><div class="w-full max-w-lg relative z-10" data-v-adb25b66><div class="bg-white/95 backdrop-blur-sm rounded-xl shadow-2xl p-8 lg:p-12 border border-gray-200/50" data-v-adb25b66><div class="text-center mb-8" data-v-adb25b66><div class="flex justify-center mb-3" data-v-adb25b66><img${ssrRenderAttr_1("src", _imports_0)} alt="Qualitec Instrumentos" class="object-contain" style="${ssrRenderStyle_1({ "width": "calc(12rem + 2cm)", "height": "calc(12rem + 2cm)" })}" data-v-adb25b66></div><div class="mb-3" data-v-adb25b66><p class="text-sm text-gray-600 font-medium" data-v-adb25b66>Gesto de Recursos Humanos</p></div><div class="flex items-center justify-center mb-2" data-v-adb25b66><div class="h-px bg-gradient-to-r from-transparent via-blue-300 to-transparent w-24" data-v-adb25b66></div></div><p class="text-xs text-gray-500 font-medium" data-v-adb25b66>ISO 9001:2015 | Instrumentao Industrial</p></div><div class="mb-8 p-4 bg-blue-50 border border-blue-200 rounded-lg" data-v-adb25b66><div class="flex items-center justify-center mb-2" data-v-adb25b66><div class="w-8 h-8 bg-blue-600 rounded-full flex items-center justify-center" data-v-adb25b66><svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-adb25b66><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" data-v-adb25b66></path></svg></div></div><p class="text-center text-blue-800 text-sm font-medium" data-v-adb25b66>Acesso Restrito</p><p class="text-center text-blue-600 text-xs mt-1" data-v-adb25b66>Entre com suas credenciais corporativas fornecidas pelo RH</p></div><form class="space-y-6" data-v-adb25b66><div class="space-y-2" data-v-adb25b66><label class="block text-sm font-semibold text-gray-700 mb-2" data-v-adb25b66><span class="flex items-center" data-v-adb25b66><svg class="w-4 h-4 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-adb25b66><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207" data-v-adb25b66></path></svg> E-mail </span></label>`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: vueExports.unref(email),
        "onUpdate:modelValue": ($event) => vueExports.isRef(email) ? email.value = $event : null,
        type: "email",
        uppercase: false,
        placeholder: "seu.email@qualitecinstrumentos.com.br",
        required: "",
        error: vueExports.unref(error) ? " " : "",
        class: "w-full"
      }, null, _parent));
      _push(`</div><div class="space-y-2" data-v-adb25b66><label class="block text-sm font-semibold text-gray-700 mb-2" data-v-adb25b66><span class="flex items-center" data-v-adb25b66><svg class="w-4 h-4 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-adb25b66><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" data-v-adb25b66></path></svg> Senha de Acesso </span></label>`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: vueExports.unref(senha),
        "onUpdate:modelValue": ($event) => vueExports.isRef(senha) ? senha.value = $event : null,
        type: "password",
        placeholder: "Digite sua senha corporativa",
        required: "",
        "show-password-toggle": "",
        error: vueExports.unref(error) ? " " : "",
        class: "w-full"
      }, null, _parent));
      _push(`</div>`);
      if (vueExports.unref(error)) {
        _push(`<div class="p-4 bg-red-50 border border-red-200 rounded-lg" data-v-adb25b66><div class="flex items-center" data-v-adb25b66><svg class="w-5 h-5 text-red-600 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-adb25b66><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-adb25b66></path></svg><span class="text-red-800 text-sm font-medium" data-v-adb25b66>${ssrInterpolate_1(vueExports.unref(error))}</span></div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(ssrRenderComponent_1(_component_UiButton, {
        type: "submit",
        size: "lg",
        loading: vueExports.unref(loading),
        class: "w-full bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white font-semibold py-4 px-6 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-[1.02] focus:ring-4 focus:ring-blue-200"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (!vueExports.unref(loading)) {
              _push2(`<span class="flex items-center justify-center" data-v-adb25b66${_scopeId}><svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-adb25b66${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1" data-v-adb25b66${_scopeId}></path></svg> Acessar Sistema </span>`);
            } else {
              _push2(`<span class="flex items-center justify-center" data-v-adb25b66${_scopeId}><svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" data-v-adb25b66${_scopeId}><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" data-v-adb25b66${_scopeId}></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" data-v-adb25b66${_scopeId}></path></svg> Autenticando... </span>`);
            }
          } else {
            return [
              !vueExports.unref(loading) ? (vueExports.openBlock(), vueExports.createBlock("span", {
                key: 0,
                class: "flex items-center justify-center"
              }, [
                (vueExports.openBlock(), vueExports.createBlock("svg", {
                  class: "w-5 h-5 mr-2",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  vueExports.createVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"
                  })
                ])),
                vueExports.createTextVNode(" Acessar Sistema ")
              ])) : (vueExports.openBlock(), vueExports.createBlock("span", {
                key: 1,
                class: "flex items-center justify-center"
              }, [
                (vueExports.openBlock(), vueExports.createBlock("svg", {
                  class: "animate-spin -ml-1 mr-3 h-5 w-5 text-white",
                  xmlns: "http://www.w3.org/2000/svg",
                  fill: "none",
                  viewBox: "0 0 24 24"
                }, [
                  vueExports.createVNode("circle", {
                    class: "opacity-25",
                    cx: "12",
                    cy: "12",
                    r: "10",
                    stroke: "currentColor",
                    "stroke-width": "4"
                  }),
                  vueExports.createVNode("path", {
                    class: "opacity-75",
                    fill: "currentColor",
                    d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  })
                ])),
                vueExports.createTextVNode(" Autenticando... ")
              ]))
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</form><div class="mt-8 p-5 bg-gradient-to-r from-gray-50 to-blue-50 rounded-xl border border-gray-200" data-v-adb25b66><div class="text-center" data-v-adb25b66><div class="flex items-center justify-center mb-3" data-v-adb25b66><div class="w-10 h-10 bg-blue-600 rounded-full flex items-center justify-center mr-3" data-v-adb25b66><svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-adb25b66><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" data-v-adb25b66></path></svg></div><div data-v-adb25b66><p class="text-blue-800 font-bold text-sm" data-v-adb25b66>Sistema Seguro</p><p class="text-blue-600 text-xs" data-v-adb25b66>Certificado ISO 9001:2015</p></div></div><p class="text-gray-600 text-xs leading-relaxed" data-v-adb25b66> Plataforma corporativa para gesto de recursos humanos.<br data-v-adb25b66> Acesso monitorado e protegido por criptografia avanada. </p></div></div></div><div class="mt-8 text-center" data-v-adb25b66><div class="bg-white/10 backdrop-blur-sm rounded-lg p-4 border border-white/20" data-v-adb25b66><p class="text-white/90 text-sm font-medium mb-1" data-v-adb25b66> QUALITEC INSTRUMENTOS LTDA </p><p class="text-white/70 text-xs" data-v-adb25b66>  2026 - Instrumentao Industrial | Criogenia | leo &amp; Gs </p><p class="text-white/60 text-xs mt-1" data-v-adb25b66> Todos os direitos reservados </p></div></div></div></div>`);
    };
  }
});
const _sfc_setup$r = _sfc_main$r.setup;
_sfc_main$r.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/login.vue");
  return _sfc_setup$r ? _sfc_setup$r(props, ctx) : void 0;
};
const login = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__scopeId", "data-v-adb25b66"]]);

const loginBr7CzZB7 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: login
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$q = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiBadge",
  __ssrInlineRender: true,
  props: {
    variant: { default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const variantClasses = vueExports.computed(() => {
      const variants = {
        primary: "bg-primary-100 text-primary-800",
        success: "bg-green-100 text-green-800",
        warning: "bg-yellow-100 text-yellow-800",
        danger: "bg-red-100 text-red-800",
        info: "bg-blue-100 text-blue-800",
        gray: "bg-gray-100 text-gray-600"
      };
      return variants[props.variant];
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<span${ssrRenderAttrs_1(vueExports.mergeProps({
        class: ["inline-flex items-center px-3 py-1 rounded-full text-sm font-medium", vueExports.unref(variantClasses)]
      }, _attrs))}>`);
      ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</span>`);
    };
  }
});
const _sfc_setup$q = _sfc_main$q.setup;
_sfc_main$q.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiBadge.vue");
  return _sfc_setup$q ? _sfc_setup$q(props, ctx) : void 0;
};
const __nuxt_component_2$2 = Object.assign(_sfc_main$q, { __name: "UiBadge" });

const _sfc_main$p = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiCard",
  __ssrInlineRender: true,
  props: {
    title: {},
    subtitle: {},
    icon: {},
    padding: { default: "p-6 lg:p-8" },
    className: {}
  },
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({
        class: ["bg-white rounded-2xl shadow-sm border border-gray-100", __props.padding, __props.className]
      }, _attrs))}>`);
      if (__props.title || _ctx.$slots.header) {
        _push(`<div class="flex items-center justify-between mb-6">`);
        if (__props.title) {
          _push(`<h3 class="text-xl font-bold text-gray-800 flex items-center gap-2">`);
          if (__props.icon) {
            _push(`<span class="text-xl">${ssrInterpolate_1(__props.icon)}</span>`);
          } else {
            _push(`<!---->`);
          }
          _push(` ${ssrInterpolate_1(__props.title)} `);
          if (__props.subtitle) {
            _push(`<span class="text-sm font-normal text-gray-400">${ssrInterpolate_1(__props.subtitle)}</span>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</h3>`);
        } else {
          _push(`<!---->`);
        }
        ssrRenderSlot_1(_ctx.$slots, "header", {}, null, _push, _parent);
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</div>`);
    };
  }
});
const _sfc_setup$p = _sfc_main$p.setup;
_sfc_main$p.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiCard.vue");
  return _sfc_setup$p ? _sfc_setup$p(props, ctx) : void 0;
};
const __nuxt_component_2$1 = Object.assign(_sfc_main$p, { __name: "UiCard" });

const firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);
// @__NO_SIDE_EFFECTS__
function defineNuxtLink(options) {
  const componentName = options.componentName || "NuxtLink";
  function isHashLinkWithoutHashMode(link) {
    return typeof link === "string" && link.startsWith("#");
  }
  function resolveTrailingSlashBehavior(to, resolve, trailingSlash) {
    const effectiveTrailingSlash = trailingSlash ?? options.trailingSlash;
    if (!to || effectiveTrailingSlash !== "append" && effectiveTrailingSlash !== "remove") {
      return to;
    }
    if (typeof to === "string") {
      return applyTrailingSlashBehavior(to, effectiveTrailingSlash);
    }
    const path = "path" in to && to.path !== void 0 ? to.path : resolve(to).path;
    const resolvedPath = {
      ...to,
      name: void 0,
      // named routes would otherwise always override trailing slash behavior
      path: applyTrailingSlashBehavior(path, effectiveTrailingSlash)
    };
    return resolvedPath;
  }
  function useNuxtLink(props) {
    const router = useRouter();
    const config = useRuntimeConfig();
    const hasTarget = vueExports.computed(() => !!props.target && props.target !== "_self");
    const isAbsoluteUrl = vueExports.computed(() => {
      const path = props.to || props.href || "";
      return typeof path === "string" && hasProtocol(path, { acceptRelative: true });
    });
    const builtinRouterLink = vueExports.resolveComponent("RouterLink");
    const useBuiltinLink = builtinRouterLink && typeof builtinRouterLink !== "string" ? builtinRouterLink.useLink : void 0;
    const isExternal = vueExports.computed(() => {
      if (props.external) {
        return true;
      }
      const path = props.to || props.href || "";
      if (typeof path === "object") {
        return false;
      }
      return path === "" || isAbsoluteUrl.value;
    });
    const to = vueExports.computed(() => {
      const path = props.to || props.href || "";
      if (isExternal.value) {
        return path;
      }
      return resolveTrailingSlashBehavior(path, router.resolve, props.trailingSlash);
    });
    const link = isExternal.value ? void 0 : useBuiltinLink?.({ ...props, to });
    const href = vueExports.computed(() => {
      const effectiveTrailingSlash = props.trailingSlash ?? options.trailingSlash;
      if (!to.value || isAbsoluteUrl.value || isHashLinkWithoutHashMode(to.value)) {
        return to.value;
      }
      if (isExternal.value) {
        const path = typeof to.value === "object" && "path" in to.value ? resolveRouteObject(to.value) : to.value;
        const href2 = typeof path === "object" ? router.resolve(path).href : path;
        return applyTrailingSlashBehavior(href2, effectiveTrailingSlash);
      }
      if (typeof to.value === "object") {
        return router.resolve(to.value)?.href ?? null;
      }
      return applyTrailingSlashBehavior(joinURL(config.app.baseURL, to.value), effectiveTrailingSlash);
    });
    return {
      to,
      hasTarget,
      isAbsoluteUrl,
      isExternal,
      //
      href,
      isActive: link?.isActive ?? vueExports.computed(() => to.value === router.currentRoute.value.path),
      isExactActive: link?.isExactActive ?? vueExports.computed(() => to.value === router.currentRoute.value.path),
      route: link?.route ?? vueExports.computed(() => router.resolve(to.value)),
      async navigate(_e) {
        await navigateTo(href.value, { replace: props.replace, external: isExternal.value || hasTarget.value });
      }
    };
  }
  return vueExports.defineComponent({
    name: componentName,
    props: {
      // Routing
      to: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      href: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      // Attributes
      target: {
        type: String,
        default: void 0,
        required: false
      },
      rel: {
        type: String,
        default: void 0,
        required: false
      },
      noRel: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Prefetching
      prefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      prefetchOn: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      noPrefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Styling
      activeClass: {
        type: String,
        default: void 0,
        required: false
      },
      exactActiveClass: {
        type: String,
        default: void 0,
        required: false
      },
      prefetchedClass: {
        type: String,
        default: void 0,
        required: false
      },
      // Vue Router's `<RouterLink>` additional props
      replace: {
        type: Boolean,
        default: void 0,
        required: false
      },
      ariaCurrentValue: {
        type: String,
        default: void 0,
        required: false
      },
      // Edge cases handling
      external: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Slot API
      custom: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Behavior
      trailingSlash: {
        type: String,
        default: void 0,
        required: false
      }
    },
    useLink: useNuxtLink,
    setup(props, { slots }) {
      const router = useRouter();
      const { to, href, navigate, isExternal, hasTarget, isAbsoluteUrl } = useNuxtLink(props);
      vueExports.shallowRef(false);
      const el = void 0;
      const elRef = void 0;
      async function prefetch(nuxtApp = useNuxtApp()) {
        {
          return;
        }
      }
      return () => {
        if (!isExternal.value && !hasTarget.value && !isHashLinkWithoutHashMode(to.value)) {
          const routerLinkProps = {
            ref: elRef,
            to: to.value,
            activeClass: props.activeClass || options.activeClass,
            exactActiveClass: props.exactActiveClass || options.exactActiveClass,
            replace: props.replace,
            ariaCurrentValue: props.ariaCurrentValue,
            custom: props.custom
          };
          if (!props.custom) {
            routerLinkProps.rel = props.rel || void 0;
          }
          return vueExports.h(
            vueExports.resolveComponent("RouterLink"),
            routerLinkProps,
            slots.default
          );
        }
        const target = props.target || null;
        const rel = firstNonUndefined(
          // converts `""` to `null` to prevent the attribute from being added as empty (`rel=""`)
          props.noRel ? "" : props.rel,
          options.externalRelAttribute,
          /*
          * A fallback rel of `noopener noreferrer` is applied for external links or links that open in a new tab.
          * This solves a reverse tabnapping security flaw in browsers pre-2021 as well as improving privacy.
          */
          isAbsoluteUrl.value || hasTarget.value ? "noopener noreferrer" : ""
        ) || null;
        if (props.custom) {
          if (!slots.default) {
            return null;
          }
          return slots.default({
            href: href.value,
            navigate,
            prefetch,
            get route() {
              if (!href.value) {
                return void 0;
              }
              const url = new URL(href.value, "http://localhost");
              return {
                path: url.pathname,
                fullPath: url.pathname,
                get query() {
                  return parseQuery$1(url.search);
                },
                hash: url.hash,
                params: {},
                name: void 0,
                matched: [],
                redirectedFrom: void 0,
                meta: {},
                href: href.value
              };
            },
            rel,
            target,
            isExternal: isExternal.value || hasTarget.value,
            isActive: false,
            isExactActive: false
          });
        }
        return vueExports.h("a", {
          ref: el,
          href: href.value || null,
          // converts `""` to `null` to prevent the attribute from being added as empty (`href=""`)
          rel,
          target,
          onClick: (event) => {
            if (isExternal.value || hasTarget.value) {
              return;
            }
            event.preventDefault();
            return props.replace ? router.replace(href.value) : router.push(href.value);
          }
        }, slots.default?.());
      };
    }
  });
}
const __nuxt_component_0$5 = /* @__PURE__ */ defineNuxtLink(nuxtLinkDefaults);
function applyTrailingSlashBehavior(to, trailingSlash) {
  const normalizeFn = trailingSlash === "append" ? withTrailingSlash : withoutTrailingSlash;
  const hasProtocolDifferentFromHttp = hasProtocol(to) && !to.startsWith("http");
  if (hasProtocolDifferentFromHttp) {
    return to;
  }
  return normalizeFn(to, true);
}

const _sfc_main$2$4 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "DashboardCard",
  __ssrInlineRender: true,
  props: {
    title: {},
    description: {},
    to: {},
    color: { default: "blue" },
    iconPath: { default: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" }
  },
  setup(__props) {
    const props = __props;
    const colorMap = {
      blue: { bg: "bg-blue-100", icon: "text-blue-600", hover: "group-hover:bg-blue-200" },
      green: { bg: "bg-green-100", icon: "text-green-600", hover: "group-hover:bg-green-200" },
      purple: { bg: "bg-purple-100", icon: "text-purple-600", hover: "group-hover:bg-purple-200" },
      orange: { bg: "bg-orange-100", icon: "text-orange-600", hover: "group-hover:bg-orange-200" }
    };
    const iconBgClass = vueExports.computed(() => colorMap[props.color].bg);
    const iconColorClass = vueExports.computed(() => colorMap[props.color].icon);
    const groupHoverClass = vueExports.computed(() => colorMap[props.color].hover);
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderVNode(_push, vueExports.createVNode(vueExports.resolveDynamicComponent(__props.to ? "NuxtLink" : "div"), vueExports.mergeProps({
        to: __props.to,
        class: [
          "bg-white rounded-2xl p-6 shadow-sm border border-gray-100 transition-all",
          __props.to ? "hover:shadow-md hover:border-primary-200 group" : ""
        ]
      }, _attrs), {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="${ssrRenderClass_1([[vueExports.unref(iconBgClass), __props.to ? vueExports.unref(groupHoverClass) : ""], "w-14 h-14 rounded-xl flex items-center justify-center mb-4 transition-colors"])}"${_scopeId}>`);
            ssrRenderSlot_1(_ctx.$slots, "icon", {}, () => {
              _push2(`<svg class="${ssrRenderClass_1([vueExports.unref(iconColorClass), "w-7 h-7"])}" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"${ssrRenderAttr_1("d", __props.iconPath)}${_scopeId}></path></svg>`);
            }, _push2, _parent2, _scopeId);
            _push2(`</div><h3 class="text-xl font-bold text-gray-800 mb-2"${_scopeId}>${ssrInterpolate_1(__props.title)}</h3><p class="text-gray-500"${_scopeId}>${ssrInterpolate_1(__props.description)}</p>`);
            ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push2, _parent2, _scopeId);
          } else {
            return [
              vueExports.createVNode("div", {
                class: ["w-14 h-14 rounded-xl flex items-center justify-center mb-4 transition-colors", [vueExports.unref(iconBgClass), __props.to ? vueExports.unref(groupHoverClass) : ""]]
              }, [
                vueExports.renderSlot(_ctx.$slots, "icon", {}, () => [
                  (vueExports.openBlock(), vueExports.createBlock("svg", {
                    class: ["w-7 h-7", vueExports.unref(iconColorClass)],
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24"
                  }, [
                    vueExports.createVNode("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: __props.iconPath
                    }, null, 8, ["d"])
                  ], 2))
                ])
              ], 2),
              vueExports.createVNode("h3", { class: "text-xl font-bold text-gray-800 mb-2" }, vueExports.toDisplayString(__props.title), 1),
              vueExports.createVNode("p", { class: "text-gray-500" }, vueExports.toDisplayString(__props.description), 1),
              vueExports.renderSlot(_ctx.$slots, "default")
            ];
          }
        }),
        _: 3
      }), _parent);
    };
  }
});
const _sfc_setup$2$4 = _sfc_main$2$4.setup;
_sfc_main$2$4.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/dashboard/DashboardCard.vue");
  return _sfc_setup$2$4 ? _sfc_setup$2$4(props, ctx) : void 0;
};
const __nuxt_component_0$4 = Object.assign(_sfc_main$2$4, { __name: "DashboardCard" });
const _sfc_main$1$9 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "DashboardStatCard",
  __ssrInlineRender: true,
  props: {
    to: {},
    value: {},
    label: {},
    color: {},
    iconPath: {}
  },
  setup(__props) {
    const props = __props;
    const gradientMap = {
      blue: "bg-gradient-to-br from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700",
      purple: "bg-gradient-to-br from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700",
      green: "bg-gradient-to-br from-green-500 to-green-600 hover:from-green-600 hover:to-green-700",
      orange: "bg-gradient-to-br from-orange-500 to-orange-600 hover:from-orange-600 hover:to-orange-700"
    };
    const gradientClass = vueExports.computed(() => gradientMap[props.color]);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$5;
      _push(ssrRenderComponent_1(_component_NuxtLink, vueExports.mergeProps({
        to: __props.to,
        class: [
          "rounded-2xl p-5 text-white transition-all",
          vueExports.unref(gradientClass)
        ]
      }, _attrs), {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="w-10 h-10 mb-3 opacity-90" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"${ssrRenderAttr_1("d", __props.iconPath)}${_scopeId}></path></svg><p class="text-3xl font-bold"${_scopeId}>${ssrInterpolate_1(__props.value)}</p><p class="text-white/80"${_scopeId}>${ssrInterpolate_1(__props.label)}</p>`);
          } else {
            return [
              (vueExports.openBlock(), vueExports.createBlock("svg", {
                class: "w-10 h-10 mb-3 opacity-90",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                vueExports.createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: __props.iconPath
                }, null, 8, ["d"])
              ])),
              vueExports.createVNode("p", { class: "text-3xl font-bold" }, vueExports.toDisplayString(__props.value), 1),
              vueExports.createVNode("p", { class: "text-white/80" }, vueExports.toDisplayString(__props.label), 1)
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _sfc_setup$1$9 = _sfc_main$1$9.setup;
_sfc_main$1$9.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/dashboard/DashboardStatCard.vue");
  return _sfc_setup$1$9 ? _sfc_setup$1$9(props, ctx) : void 0;
};
const __nuxt_component_3$1 = Object.assign(_sfc_main$1$9, { __name: "DashboardStatCard" });
const _sfc_main$o = /* @__PURE__ */ vueExports.defineComponent({
  __name: "dashboard",
  __ssrInlineRender: true,
  setup(__props) {
    const { user, isAdmin } = useAuth();
    const stats = vueExports.ref({
      totalFuncionarios: 0,
      totalDepartamentos: 0,
      folhaMensal: 0,
      totalAniversariantes: 0
    });
    const aniversariantes = vueExports.ref([]);
    const loading = vueExports.ref(true);
    const dadosCompletos = vueExports.ref(null);
    const empresaUsuario = vueExports.ref(null);
    const cargosMap = vueExports.ref({});
    const departamentosMap = vueExports.ref({});
    const obterSaudacao = () => {
      const agora = /* @__PURE__ */ new Date();
      const horarioBrasilia = new Date(agora.getTime() - 3 * 60 * 60 * 1e3);
      const hora = horarioBrasilia.getHours();
      if (hora >= 5 && hora < 12) {
        return "Bom dia";
      } else if (hora >= 12 && hora < 18) {
        return "Boa tarde";
      } else {
        return "Boa noite";
      }
    };
    const obterNomeCargo = (id) => {
      const idStr = id?.toString();
      return cargosMap.value[idStr] || idStr || "No informado";
    };
    const obterNomeDepartamento = (id) => {
      const idStr = id?.toString();
      return departamentosMap.value[idStr] || idStr || "No informado";
    };
    const formatarMoeda = (valor) => {
      return new Intl.NumberFormat("pt-BR", {
        style: "currency",
        currency: "BRL"
      }).format(valor);
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_DashboardCard = __nuxt_component_0$4;
      const _component_UiBadge = __nuxt_component_2$2;
      const _component_UiCard = __nuxt_component_2$1;
      const _component_DashboardStatCard = __nuxt_component_3$1;
      _push(`<div${ssrRenderAttrs_1(_attrs)}><div class="mb-8"><h1 class="text-3xl lg:text-4xl font-bold text-gray-800">${ssrInterpolate_1(obterSaudacao())} ${ssrInterpolate_1(vueExports.unref(user)?.nome?.split(" ")[0])}! </h1><p class="text-lg text-gray-500 mt-2"> Bem-vindo ao Sistema de RH. Aqui voc encontra tudo sobre sua vida profissional. </p></div><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">`);
      _push(ssrRenderComponent_1(_component_DashboardCard, {
        to: "/meus-dados",
        title: "Meus Dados",
        description: "Veja e atualize suas informaes pessoais",
        color: "blue",
        "icon-path": "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"
      }, null, _parent));
      if (!vueExports.unref(isAdmin)) {
        _push(ssrRenderComponent_1(_component_DashboardCard, {
          to: "/holerites",
          title: "Meus Holerites",
          description: "Acesse seus contracheques e baixe em PDF",
          color: "green",
          "icon-path": "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(ssrRenderComponent_1(_component_DashboardCard, {
        title: vueExports.unref(empresaUsuario) ? vueExports.unref(empresaUsuario).nome_fantasia || vueExports.unref(empresaUsuario).nome : "Minha Empresa",
        description: vueExports.unref(empresaUsuario) ? `CNPJ: ${vueExports.unref(empresaUsuario).cnpj || "No informado"}` : "Aguardando cadastro",
        color: "purple",
        "icon-path": "M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent_1(_component_UiBadge, {
              variant: vueExports.unref(empresaUsuario) ? "success" : "warning",
              class: "mt-3"
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${ssrInterpolate_1(vueExports.unref(empresaUsuario) ? " Vinculado" : " Pendente")}`);
                } else {
                  return [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(empresaUsuario) ? " Vinculado" : " Pendente"), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              vueExports.createVNode(_component_UiBadge, {
                variant: vueExports.unref(empresaUsuario) ? "success" : "warning",
                class: "mt-3"
              }, {
                default: vueExports.withCtx(() => [
                  vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(empresaUsuario) ? " Vinculado" : " Pendente"), 1)
                ]),
                _: 1
              }, 8, ["variant"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div>`);
      _push(ssrRenderComponent_1(_component_UiCard, {
        title: "Suas Informaes",
        icon: "",
        class: "mb-8"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="grid grid-cols-1 md:grid-cols-2 gap-6"${_scopeId}><div class="space-y-4"${_scopeId}><div${_scopeId}><p class="text-sm text-gray-500 mb-1"${_scopeId}>Nome Completo</p><p class="text-lg font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(vueExports.unref(dadosCompletos)?.nome_completo || vueExports.unref(user)?.nome)}</p></div><div${_scopeId}><p class="text-sm text-gray-500 mb-1"${_scopeId}>Cargo</p><p class="text-lg font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(obterNomeCargo(vueExports.unref(dadosCompletos)?.cargo_id))}</p></div>`);
            if (vueExports.unref(empresaUsuario)) {
              _push2(`<div${_scopeId}><p class="text-sm text-gray-500 mb-1"${_scopeId}>Empresa</p><p class="text-lg font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(vueExports.unref(empresaUsuario).nome_fantasia || vueExports.unref(empresaUsuario).nome)}</p><p class="text-sm text-gray-500"${_scopeId}>${ssrInterpolate_1(vueExports.unref(empresaUsuario).nome)}</p></div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div><div class="space-y-4"${_scopeId}><div${_scopeId}><p class="text-sm text-gray-500 mb-1"${_scopeId}>Departamento</p><p class="text-lg font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(obterNomeDepartamento(vueExports.unref(dadosCompletos)?.departamento_id))}</p></div><div${_scopeId}><p class="text-sm text-gray-500 mb-1"${_scopeId}>Email</p><p class="text-lg font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(vueExports.unref(dadosCompletos)?.email || vueExports.unref(user)?.email)}</p></div>`);
            if (vueExports.unref(empresaUsuario)?.cnpj) {
              _push2(`<div${_scopeId}><p class="text-sm text-gray-500 mb-1"${_scopeId}>CNPJ da Empresa</p><p class="text-lg font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(vueExports.unref(empresaUsuario).cnpj)}</p></div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "grid grid-cols-1 md:grid-cols-2 gap-6" }, [
                vueExports.createVNode("div", { class: "space-y-4" }, [
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("p", { class: "text-sm text-gray-500 mb-1" }, "Nome Completo"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800" }, vueExports.toDisplayString(vueExports.unref(dadosCompletos)?.nome_completo || vueExports.unref(user)?.nome), 1)
                  ]),
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("p", { class: "text-sm text-gray-500 mb-1" }, "Cargo"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800" }, vueExports.toDisplayString(obterNomeCargo(vueExports.unref(dadosCompletos)?.cargo_id)), 1)
                  ]),
                  vueExports.unref(empresaUsuario) ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 0 }, [
                    vueExports.createVNode("p", { class: "text-sm text-gray-500 mb-1" }, "Empresa"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800" }, vueExports.toDisplayString(vueExports.unref(empresaUsuario).nome_fantasia || vueExports.unref(empresaUsuario).nome), 1),
                    vueExports.createVNode("p", { class: "text-sm text-gray-500" }, vueExports.toDisplayString(vueExports.unref(empresaUsuario).nome), 1)
                  ])) : vueExports.createCommentVNode("", true)
                ]),
                vueExports.createVNode("div", { class: "space-y-4" }, [
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("p", { class: "text-sm text-gray-500 mb-1" }, "Departamento"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800" }, vueExports.toDisplayString(obterNomeDepartamento(vueExports.unref(dadosCompletos)?.departamento_id)), 1)
                  ]),
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("p", { class: "text-sm text-gray-500 mb-1" }, "Email"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800" }, vueExports.toDisplayString(vueExports.unref(dadosCompletos)?.email || vueExports.unref(user)?.email), 1)
                  ]),
                  vueExports.unref(empresaUsuario)?.cnpj ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 0 }, [
                    vueExports.createVNode("p", { class: "text-sm text-gray-500 mb-1" }, "CNPJ da Empresa"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800" }, vueExports.toDisplayString(vueExports.unref(empresaUsuario).cnpj), 1)
                  ])) : vueExports.createCommentVNode("", true)
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      if (vueExports.unref(isAdmin)) {
        _push(`<!--[--><h2 class="text-2xl font-bold text-gray-800 mb-6 flex items-center gap-3">  rea do Administrador </h2><div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">`);
        _push(ssrRenderComponent_1(_component_DashboardStatCard, {
          to: "/admin/funcionarios",
          value: vueExports.unref(loading) ? "..." : (vueExports.unref(stats).totalFuncionarios || 0).toString(),
          label: "Funcionrios",
          color: "blue",
          "icon-path": "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_DashboardStatCard, {
          to: "/admin/departamentos",
          value: vueExports.unref(loading) ? "..." : (vueExports.unref(stats).totalDepartamentos || 0).toString(),
          label: "Departamentos",
          color: "purple",
          "icon-path": "M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_DashboardStatCard, {
          to: "/admin/holerites",
          value: vueExports.unref(loading) ? "..." : formatarMoeda(vueExports.unref(stats).folhaMensal || 0),
          label: "Folha Mensal",
          color: "green",
          "icon-path": "M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z"
        }, null, _parent));
        _push(`<div class="bg-gradient-to-br from-orange-500 to-orange-600 rounded-2xl p-5 text-white"><svg class="w-10 h-10 mb-3 opacity-90" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 15.546c-.523 0-1.046.151-1.5.454a2.704 2.704 0 01-3 0 2.704 2.704 0 00-3 0 2.704 2.704 0 01-3 0 2.704 2.704 0 00-3 0 2.704 2.704 0 01-3 0 2.701 2.701 0 00-1.5-.454M9 6v2m3-2v2m3-2v2M9 3h.01M12 3h.01M15 3h.01M21 21v-7a2 2 0 00-2-2H5a2 2 0 00-2 2v7h18zm-3-9v-2a2 2 0 00-2-2H8a2 2 0 00-2 2v2h12z"></path></svg><p class="text-3xl font-bold">${ssrInterpolate_1(vueExports.unref(loading) ? "..." : vueExports.unref(stats).totalAniversariantes || 0)}</p><p class="text-white/80">Aniversariantes</p></div></div>`);
        _push(ssrRenderComponent_1(_component_UiCard, { title: " Aniversariantes do Ms" }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              if (vueExports.unref(loading)) {
                _push2(`<div class="text-center py-8"${_scopeId}><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"${_scopeId}></div><p class="mt-2 text-gray-600"${_scopeId}>Carregando...</p></div>`);
              } else if (vueExports.unref(aniversariantes).length === 0) {
                _push2(`<div class="text-center py-8 text-gray-500"${_scopeId}> Nenhum aniversariante este ms </div>`);
              } else {
                _push2(`<div class="space-y-4"${_scopeId}><!--[-->`);
                ssrRenderList_1(vueExports.unref(aniversariantes), (aniversariante) => {
                  _push2(`<div class="flex items-center gap-4 p-4 bg-gray-50 rounded-xl hover:bg-gray-100 transition-colors"${_scopeId}><div class="w-12 h-12 bg-orange-100 rounded-full flex items-center justify-center"${_scopeId}><span class="text-orange-600 font-bold text-lg"${_scopeId}>${ssrInterpolate_1(aniversariante.dia)}</span></div><div class="flex-1"${_scopeId}><h4 class="font-semibold text-gray-900"${_scopeId}>${ssrInterpolate_1(aniversariante.nome_completo)}</h4><p class="text-sm text-gray-600"${_scopeId}>${ssrInterpolate_1(aniversariante.cargo)} - ${ssrInterpolate_1(aniversariante.departamento)}</p></div><div class="text-2xl"${_scopeId}></div></div>`);
                });
                _push2(`<!--]--></div>`);
              }
            } else {
              return [
                vueExports.unref(loading) ? (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 0,
                  class: "text-center py-8"
                }, [
                  vueExports.createVNode("div", { class: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto" }),
                  vueExports.createVNode("p", { class: "mt-2 text-gray-600" }, "Carregando...")
                ])) : vueExports.unref(aniversariantes).length === 0 ? (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 1,
                  class: "text-center py-8 text-gray-500"
                }, " Nenhum aniversariante este ms ")) : (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 2,
                  class: "space-y-4"
                }, [
                  (vueExports.openBlock(true), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(vueExports.unref(aniversariantes), (aniversariante) => {
                    return vueExports.openBlock(), vueExports.createBlock("div", {
                      key: aniversariante.id,
                      class: "flex items-center gap-4 p-4 bg-gray-50 rounded-xl hover:bg-gray-100 transition-colors"
                    }, [
                      vueExports.createVNode("div", { class: "w-12 h-12 bg-orange-100 rounded-full flex items-center justify-center" }, [
                        vueExports.createVNode("span", { class: "text-orange-600 font-bold text-lg" }, vueExports.toDisplayString(aniversariante.dia), 1)
                      ]),
                      vueExports.createVNode("div", { class: "flex-1" }, [
                        vueExports.createVNode("h4", { class: "font-semibold text-gray-900" }, vueExports.toDisplayString(aniversariante.nome_completo), 1),
                        vueExports.createVNode("p", { class: "text-sm text-gray-600" }, vueExports.toDisplayString(aniversariante.cargo) + " - " + vueExports.toDisplayString(aniversariante.departamento), 1)
                      ]),
                      vueExports.createVNode("div", { class: "text-2xl" }, "")
                    ]);
                  }), 128))
                ]))
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<!--]-->`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$o = _sfc_main$o.setup;
_sfc_main$o.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/dashboard.vue");
  return _sfc_setup$o ? _sfc_setup$o(props, ctx) : void 0;
};

const dashboardDkREg1Jb = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$o
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$n = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiModal",
  __ssrInlineRender: true,
  props: {
    modelValue: { type: Boolean },
    title: {},
    maxWidth: { default: "max-w-lg" },
    maxHeight: { default: "max-h-[90vh]" },
    contentPadding: { default: "p-6" },
    contentMaxHeight: { default: "calc(90vh - 180px)" },
    closeOnBackdrop: { type: Boolean, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderTeleport_1(_push, (_push2) => {
        if (__props.modelValue) {
          _push2(`<div class="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4" data-v-d7b8f265><div class="${ssrRenderClass_1(["bg-white rounded-2xl w-full overflow-hidden", __props.maxWidth, __props.maxHeight])}" data-v-d7b8f265><div class="sticky top-0 bg-white border-b p-6 flex items-center justify-between" data-v-d7b8f265><h2 class="text-2xl font-bold text-gray-800" data-v-d7b8f265>${ssrInterpolate_1(__props.title)}</h2><button class="p-2 hover:bg-gray-100 rounded-lg transition-colors" data-v-d7b8f265><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-d7b8f265><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" data-v-d7b8f265></path></svg></button></div><div class="${ssrRenderClass_1(["overflow-y-auto", __props.contentPadding])}" style="${ssrRenderStyle_1({ maxHeight: __props.contentMaxHeight })}" data-v-d7b8f265>`);
          ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push2, _parent);
          _push2(`</div>`);
          if (_ctx.$slots.footer) {
            _push2(`<div class="border-t p-6 flex justify-end gap-3" data-v-d7b8f265>`);
            ssrRenderSlot_1(_ctx.$slots, "footer", {}, null, _push2, _parent);
            _push2(`</div>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`</div></div>`);
        } else {
          _push2(`<!---->`);
        }
      }, "body", false, _parent);
    };
  }
});
const _sfc_setup$n = _sfc_main$n.setup;
_sfc_main$n.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiModal.vue");
  return _sfc_setup$n ? _sfc_setup$n(props, ctx) : void 0;
};
const __nuxt_component_3 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$n, [["__scopeId", "data-v-d7b8f265"]]), { __name: "UiModal" });

const _sfc_main$1$8 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiEmptyState",
  __ssrInlineRender: true,
  props: {
    title: {},
    description: {},
    icon: { default: "document" }
  },
  setup(__props) {
    const props = __props;
    const iconPath = vueExports.computed(() => {
      const icons = {
        document: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z",
        users: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z",
        search: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
      };
      return icons[props.icon];
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "bg-white rounded-2xl p-12 shadow-sm border border-gray-100 text-center" }, _attrs))}><svg class="w-16 h-16 text-gray-300 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"${ssrRenderAttr_1("d", vueExports.unref(iconPath))}></path></svg><h3 class="text-xl font-bold text-gray-600 mb-2">${ssrInterpolate_1(__props.title)}</h3><p class="text-gray-500">${ssrInterpolate_1(__props.description)}</p>`);
      ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</div>`);
    };
  }
});
const _sfc_setup$1$8 = _sfc_main$1$8.setup;
_sfc_main$1$8.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiEmptyState.vue");
  return _sfc_setup$1$8 ? _sfc_setup$1$8(props, ctx) : void 0;
};
const __nuxt_component_2 = Object.assign(_sfc_main$1$8, { __name: "UiEmptyState" });
const _sfc_main$m = /* @__PURE__ */ vueExports.defineComponent({
  __name: "HoleriteModal",
  __ssrInlineRender: true,
  props: {
    holerite: {},
    userName: {},
    userCargo: {},
    userDepartamento: {}
  },
  emits: ["close", "download"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const formatarMoeda = (valor) => {
      if (!valor) return "R$ 0,00";
      try {
        return new Intl.NumberFormat("pt-BR", {
          style: "currency",
          currency: "BRL"
        }).format(valor);
      } catch (error) {
        return "R$ 0,00";
      }
    };
    const formatarPeriodo = (inicio, fim) => {
      if (!inicio || !fim) return "Perodo no definido";
      try {
        const dataInicio = new Date(inicio).toLocaleDateString("pt-BR");
        const dataFim = new Date(fim).toLocaleDateString("pt-BR");
        return `${dataInicio} - ${dataFim}`;
      } catch (error) {
        return "Perodo invlido";
      }
    };
    const baixarHTML = async () => {
      try {
        const response = await fetch(`/api/holerites/${props.holerite.id}/html`);
        if (!response.ok) {
          throw new Error("Erro ao gerar HTML");
        }
        const blob = await response.blob();
        const url = (void 0).URL.createObjectURL(blob);
        const a = (void 0).createElement("a");
        a.href = url;
        const nomeArquivo = props.holerite?.funcionario?.nome_completo?.replace(/\s+/g, "-") || props.userName?.replace(/\s+/g, "-") || "funcionario";
        a.download = `holerite-${nomeArquivo}.html`;
        (void 0).body.appendChild(a);
        a.click();
        (void 0).URL.revokeObjectURL(url);
        (void 0).body.removeChild(a);
      } catch (error) {
        console.error("Erro ao baixar HTML:", error);
        alert("Erro ao baixar HTML do holerite");
      }
    };
    const baixarPDF = async () => {
      try {
        emit("download", props.holerite);
      } catch (error) {
        console.error("Erro ao baixar PDF:", error);
        alert("Erro ao baixar PDF do holerite");
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiModal = __nuxt_component_3;
      const _component_UiButton = __nuxt_component_1$4;
      if (__props.holerite) {
        _push(ssrRenderComponent_1(_component_UiModal, vueExports.mergeProps({
          "model-value": true,
          title: "Detalhes do Holerite",
          "max-width": "max-w-4xl",
          "onUpdate:modelValue": ($event) => _ctx.$emit("close")
        }, _attrs), {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="space-y-6"${_scopeId}><div class="bg-gray-50 rounded-xl p-4"${_scopeId}><p class="font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(__props.holerite?.funcionario?.nome_completo || __props.userName || "Funcionrio")}</p><p class="text-gray-500"${_scopeId}>${ssrInterpolate_1(__props.holerite?.funcionario?.cargo || __props.userCargo || "Cargo no informado")} - ${ssrInterpolate_1(__props.holerite?.funcionario?.empresa || "Empresa")}</p><p class="text-sm text-gray-400 mt-1"${_scopeId}> Perodo: ${ssrInterpolate_1(formatarPeriodo(__props.holerite?.periodo_inicio, __props.holerite?.periodo_fim))}</p></div><div${_scopeId}><h3 class="text-lg font-bold text-green-600 mb-3"${_scopeId}>Proventos</h3><div class="space-y-2"${_scopeId}><div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>Salrio Base</span><span class="font-semibold"${_scopeId}>${ssrInterpolate_1(formatarMoeda(__props.holerite.salario_base))}</span></div>`);
              if (__props.holerite.beneficios && __props.holerite.beneficios.length > 0) {
                _push2(`<div${_scopeId}><!--[-->`);
                ssrRenderList_1(__props.holerite.beneficios, (beneficio) => {
                  _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>${ssrInterpolate_1(beneficio.tipo)}</span><span class="font-semibold text-green-600"${_scopeId}>+ ${ssrInterpolate_1(formatarMoeda(beneficio.valor))}</span></div>`);
                });
                _push2(`<!--]--></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (__props.holerite.bonus) {
                _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>Bnus</span><span class="font-semibold"${_scopeId}>${ssrInterpolate_1(formatarMoeda(__props.holerite.bonus))}</span></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (__props.holerite.horas_extras) {
                _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>Horas Extras</span><span class="font-semibold"${_scopeId}>${ssrInterpolate_1(formatarMoeda(__props.holerite.horas_extras))}</span></div>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div><div class="flex justify-between py-2 mt-2 bg-green-50 px-3 rounded-lg"${_scopeId}><span class="font-bold text-green-700"${_scopeId}>Total Proventos</span><span class="font-bold text-green-700"${_scopeId}>${ssrInterpolate_1(formatarMoeda(__props.holerite.total_proventos))}</span></div></div><div${_scopeId}><h3 class="text-lg font-bold text-red-600 mb-3"${_scopeId}>Descontos</h3><div class="space-y-2"${_scopeId}>`);
              if (__props.holerite.inss) {
                _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>INSS</span><span class="font-semibold text-red-600"${_scopeId}>- ${ssrInterpolate_1(formatarMoeda(__props.holerite.inss))}</span></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (__props.holerite.irrf) {
                _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>IRRF</span><span class="font-semibold text-red-600"${_scopeId}>- ${ssrInterpolate_1(formatarMoeda(__props.holerite.irrf))}</span></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (__props.holerite.beneficios && __props.holerite.beneficios.length > 0) {
                _push2(`<!--[-->`);
                ssrRenderList_1(__props.holerite.beneficios.filter((b) => b.desconto && b.desconto > 0), (beneficio) => {
                  _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>${ssrInterpolate_1(beneficio.tipo)} (Desconto)</span><span class="font-semibold text-red-600"${_scopeId}>- ${ssrInterpolate_1(formatarMoeda(beneficio.desconto))}</span></div>`);
                });
                _push2(`<!--]-->`);
              } else {
                _push2(`<!---->`);
              }
              if (__props.holerite.descontos_personalizados && __props.holerite.descontos_personalizados.length > 0) {
                _push2(`<div${_scopeId}><!--[-->`);
                ssrRenderList_1(__props.holerite.descontos_personalizados, (desconto) => {
                  _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>${ssrInterpolate_1(desconto.tipo)}</span><span class="font-semibold text-red-600"${_scopeId}>- ${ssrInterpolate_1(formatarMoeda(desconto.valor))}</span></div>`);
                });
                _push2(`<!--]--></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (__props.holerite.vale_transporte) {
                _push2(`<div class="flex justify-between py-2 border-b border-gray-100"${_scopeId}><span class="text-gray-600"${_scopeId}>Vale Transporte</span><span class="font-semibold text-red-600"${_scopeId}>- ${ssrInterpolate_1(formatarMoeda(__props.holerite.vale_transporte))}</span></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (__props.holerite.adiantamento && __props.holerite.adiantamento > 0) {
                _push2(`<div class="flex justify-between py-2 border-b border-gray-100 bg-yellow-50"${_scopeId}><span class="text-gray-600 font-semibold"${_scopeId}> Adiantamento Pago</span><span class="font-semibold text-red-600"${_scopeId}>- ${ssrInterpolate_1(formatarMoeda(__props.holerite.adiantamento))}</span></div>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div><div class="flex justify-between py-2 mt-2 bg-red-50 px-3 rounded-lg"${_scopeId}><span class="font-bold text-red-700"${_scopeId}>Total Descontos</span><span class="font-bold text-red-700"${_scopeId}>- ${ssrInterpolate_1(formatarMoeda(__props.holerite.total_descontos))}</span></div></div><div class="bg-primary-50 rounded-xl p-4"${_scopeId}><div class="flex justify-between items-center"${_scopeId}><span class="text-xl font-bold text-primary-800"${_scopeId}>Salrio Lquido</span><span class="text-2xl font-bold text-primary-700"${_scopeId}>${ssrInterpolate_1(formatarMoeda(__props.holerite.salario_liquido))}</span></div></div><div class="flex justify-end gap-3 pt-4 border-t border-gray-200"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "secondary",
                onClick: ($event) => _ctx.$emit("close")
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(` Fechar `);
                  } else {
                    return [
                      vueExports.createTextVNode(" Fechar ")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: baixarHTML
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Baixar HTML `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Baixar HTML ")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, { onClick: baixarPDF }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Baixar PDF `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Baixar PDF ")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(`</div></div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "space-y-6" }, [
                  vueExports.createVNode("div", { class: "bg-gray-50 rounded-xl p-4" }, [
                    vueExports.createVNode("p", { class: "font-semibold text-gray-800" }, vueExports.toDisplayString(__props.holerite?.funcionario?.nome_completo || __props.userName || "Funcionrio"), 1),
                    vueExports.createVNode("p", { class: "text-gray-500" }, vueExports.toDisplayString(__props.holerite?.funcionario?.cargo || __props.userCargo || "Cargo no informado") + " - " + vueExports.toDisplayString(__props.holerite?.funcionario?.empresa || "Empresa"), 1),
                    vueExports.createVNode("p", { class: "text-sm text-gray-400 mt-1" }, " Perodo: " + vueExports.toDisplayString(formatarPeriodo(__props.holerite?.periodo_inicio, __props.holerite?.periodo_fim)), 1)
                  ]),
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("h3", { class: "text-lg font-bold text-green-600 mb-3" }, "Proventos"),
                    vueExports.createVNode("div", { class: "space-y-2" }, [
                      vueExports.createVNode("div", { class: "flex justify-between py-2 border-b border-gray-100" }, [
                        vueExports.createVNode("span", { class: "text-gray-600" }, "Salrio Base"),
                        vueExports.createVNode("span", { class: "font-semibold" }, vueExports.toDisplayString(formatarMoeda(__props.holerite.salario_base)), 1)
                      ]),
                      __props.holerite.beneficios && __props.holerite.beneficios.length > 0 ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 0 }, [
                        (vueExports.openBlock(true), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(__props.holerite.beneficios, (beneficio) => {
                          return vueExports.openBlock(), vueExports.createBlock("div", {
                            key: beneficio.tipo,
                            class: "flex justify-between py-2 border-b border-gray-100"
                          }, [
                            vueExports.createVNode("span", { class: "text-gray-600" }, vueExports.toDisplayString(beneficio.tipo), 1),
                            vueExports.createVNode("span", { class: "font-semibold text-green-600" }, "+ " + vueExports.toDisplayString(formatarMoeda(beneficio.valor)), 1)
                          ]);
                        }), 128))
                      ])) : vueExports.createCommentVNode("", true),
                      __props.holerite.bonus ? (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 1,
                        class: "flex justify-between py-2 border-b border-gray-100"
                      }, [
                        vueExports.createVNode("span", { class: "text-gray-600" }, "Bnus"),
                        vueExports.createVNode("span", { class: "font-semibold" }, vueExports.toDisplayString(formatarMoeda(__props.holerite.bonus)), 1)
                      ])) : vueExports.createCommentVNode("", true),
                      __props.holerite.horas_extras ? (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 2,
                        class: "flex justify-between py-2 border-b border-gray-100"
                      }, [
                        vueExports.createVNode("span", { class: "text-gray-600" }, "Horas Extras"),
                        vueExports.createVNode("span", { class: "font-semibold" }, vueExports.toDisplayString(formatarMoeda(__props.holerite.horas_extras)), 1)
                      ])) : vueExports.createCommentVNode("", true)
                    ]),
                    vueExports.createVNode("div", { class: "flex justify-between py-2 mt-2 bg-green-50 px-3 rounded-lg" }, [
                      vueExports.createVNode("span", { class: "font-bold text-green-700" }, "Total Proventos"),
                      vueExports.createVNode("span", { class: "font-bold text-green-700" }, vueExports.toDisplayString(formatarMoeda(__props.holerite.total_proventos)), 1)
                    ])
                  ]),
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("h3", { class: "text-lg font-bold text-red-600 mb-3" }, "Descontos"),
                    vueExports.createVNode("div", { class: "space-y-2" }, [
                      __props.holerite.inss ? (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 0,
                        class: "flex justify-between py-2 border-b border-gray-100"
                      }, [
                        vueExports.createVNode("span", { class: "text-gray-600" }, "INSS"),
                        vueExports.createVNode("span", { class: "font-semibold text-red-600" }, "- " + vueExports.toDisplayString(formatarMoeda(__props.holerite.inss)), 1)
                      ])) : vueExports.createCommentVNode("", true),
                      __props.holerite.irrf ? (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 1,
                        class: "flex justify-between py-2 border-b border-gray-100"
                      }, [
                        vueExports.createVNode("span", { class: "text-gray-600" }, "IRRF"),
                        vueExports.createVNode("span", { class: "font-semibold text-red-600" }, "- " + vueExports.toDisplayString(formatarMoeda(__props.holerite.irrf)), 1)
                      ])) : vueExports.createCommentVNode("", true),
                      __props.holerite.beneficios && __props.holerite.beneficios.length > 0 ? (vueExports.openBlock(true), vueExports.createBlock(vueExports.Fragment, { key: 2 }, vueExports.renderList(__props.holerite.beneficios.filter((b) => b.desconto && b.desconto > 0), (beneficio) => {
                        return vueExports.openBlock(), vueExports.createBlock("div", {
                          key: beneficio.tipo,
                          class: "flex justify-between py-2 border-b border-gray-100"
                        }, [
                          vueExports.createVNode("span", { class: "text-gray-600" }, vueExports.toDisplayString(beneficio.tipo) + " (Desconto)", 1),
                          vueExports.createVNode("span", { class: "font-semibold text-red-600" }, "- " + vueExports.toDisplayString(formatarMoeda(beneficio.desconto)), 1)
                        ]);
                      }), 128)) : vueExports.createCommentVNode("", true),
                      __props.holerite.descontos_personalizados && __props.holerite.descontos_personalizados.length > 0 ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 3 }, [
                        (vueExports.openBlock(true), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(__props.holerite.descontos_personalizados, (desconto) => {
                          return vueExports.openBlock(), vueExports.createBlock("div", {
                            key: desconto.tipo,
                            class: "flex justify-between py-2 border-b border-gray-100"
                          }, [
                            vueExports.createVNode("span", { class: "text-gray-600" }, vueExports.toDisplayString(desconto.tipo), 1),
                            vueExports.createVNode("span", { class: "font-semibold text-red-600" }, "- " + vueExports.toDisplayString(formatarMoeda(desconto.valor)), 1)
                          ]);
                        }), 128))
                      ])) : vueExports.createCommentVNode("", true),
                      __props.holerite.vale_transporte ? (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 4,
                        class: "flex justify-between py-2 border-b border-gray-100"
                      }, [
                        vueExports.createVNode("span", { class: "text-gray-600" }, "Vale Transporte"),
                        vueExports.createVNode("span", { class: "font-semibold text-red-600" }, "- " + vueExports.toDisplayString(formatarMoeda(__props.holerite.vale_transporte)), 1)
                      ])) : vueExports.createCommentVNode("", true),
                      __props.holerite.adiantamento && __props.holerite.adiantamento > 0 ? (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 5,
                        class: "flex justify-between py-2 border-b border-gray-100 bg-yellow-50"
                      }, [
                        vueExports.createVNode("span", { class: "text-gray-600 font-semibold" }, " Adiantamento Pago"),
                        vueExports.createVNode("span", { class: "font-semibold text-red-600" }, "- " + vueExports.toDisplayString(formatarMoeda(__props.holerite.adiantamento)), 1)
                      ])) : vueExports.createCommentVNode("", true)
                    ]),
                    vueExports.createVNode("div", { class: "flex justify-between py-2 mt-2 bg-red-50 px-3 rounded-lg" }, [
                      vueExports.createVNode("span", { class: "font-bold text-red-700" }, "Total Descontos"),
                      vueExports.createVNode("span", { class: "font-bold text-red-700" }, "- " + vueExports.toDisplayString(formatarMoeda(__props.holerite.total_descontos)), 1)
                    ])
                  ]),
                  vueExports.createVNode("div", { class: "bg-primary-50 rounded-xl p-4" }, [
                    vueExports.createVNode("div", { class: "flex justify-between items-center" }, [
                      vueExports.createVNode("span", { class: "text-xl font-bold text-primary-800" }, "Salrio Lquido"),
                      vueExports.createVNode("span", { class: "text-2xl font-bold text-primary-700" }, vueExports.toDisplayString(formatarMoeda(__props.holerite.salario_liquido)), 1)
                    ])
                  ]),
                  vueExports.createVNode("div", { class: "flex justify-end gap-3 pt-4 border-t border-gray-200" }, [
                    vueExports.createVNode(_component_UiButton, {
                      variant: "secondary",
                      onClick: ($event) => _ctx.$emit("close")
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode(" Fechar ")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: baixarHTML
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Baixar HTML ")
                      ]),
                      _: 1
                    }),
                    vueExports.createVNode(_component_UiButton, { onClick: baixarPDF }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Baixar PDF ")
                      ]),
                      _: 1
                    })
                  ])
                ])
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$m = _sfc_main$m.setup;
_sfc_main$m.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/holerites/HoleriteModal.vue");
  return _sfc_setup$m ? _sfc_setup$m(props, ctx) : void 0;
};
const HoleriteModal = Object.assign(_sfc_main$m, { __name: "HoleritesHoleriteModal" });

const useHolerites = () => {
  const isAdiantamento = (holerite) => {
    if (holerite.quinzena === 1) return true;
    if (holerite.periodo_inicio && holerite.periodo_fim) {
      const inicio = new Date(holerite.periodo_inicio);
      const fim = new Date(holerite.periodo_fim);
      return inicio.getDate() === 1 && fim.getDate() <= 15;
    }
    return holerite.tipo?.toLowerCase().includes("adiantamento") || holerite.referencia?.toLowerCase().includes("adiantamento");
  };
  const getTipoHolerite = (holerite) => {
    return isAdiantamento(holerite) ? "adiantamento" : "folha_mensal";
  };
  const getTipoLabel = (holerite) => {
    return isAdiantamento(holerite) ? " Adiantamento" : " Folha Mensal";
  };
  const isFeriado = (data) => {
    const feriados = [
      // Feriados fixos
      "01-01",
      // Ano Novo
      "04-21",
      // Tiradentes
      "05-01",
      // Dia do Trabalhador
      "09-07",
      // Independncia do Brasil
      "10-12",
      // Nossa Senhora Aparecida
      "11-02",
      // Finados
      "11-15",
      // Proclamao da Repblica
      "12-25"
      // Natal
      // Adicione outros feriados fixos conforme necessrio
    ];
    const meseDia = data.toISOString().slice(5, 10);
    return feriados.includes(meseDia);
  };
  const isFimDeSemana = (data) => {
    const diaSemana = data.getDay();
    return diaSemana === 0 || diaSemana === 6;
  };
  const isDiaUtil = (data) => {
    return !isFimDeSemana(data) && !isFeriado(data);
  };
  const obterUltimoDiaUtil = (data) => {
    const novaData = new Date(data);
    while (!isDiaUtil(novaData)) {
      novaData.setDate(novaData.getDate() - 1);
    }
    return novaData;
  };
  const calcularDataDisponibilizacaoHolerite20 = (ano, mes) => {
    const dia20 = new Date(ano, mes - 1, 20);
    if (isDiaUtil(dia20)) {
      const dataDisponibilizacao = new Date(dia20);
      dataDisponibilizacao.setDate(dataDisponibilizacao.getDate() - 2);
      if (!isDiaUtil(dataDisponibilizacao)) {
        return obterUltimoDiaUtil(dataDisponibilizacao);
      }
      return dataDisponibilizacao;
    } else {
      const ultimoDiaUtil = obterUltimoDiaUtil(dia20);
      const dataDisponibilizacao = new Date(ultimoDiaUtil);
      dataDisponibilizacao.setDate(dataDisponibilizacao.getDate() - 2);
      if (!isDiaUtil(dataDisponibilizacao)) {
        return obterUltimoDiaUtil(dataDisponibilizacao);
      }
      return dataDisponibilizacao;
    }
  };
  const deveEstarDisponivelHolerite20 = (ano, mes) => {
    const hoje = /* @__PURE__ */ new Date();
    const dataDisponibilizacao = calcularDataDisponibilizacaoHolerite20(ano, mes);
    return hoje >= dataDisponibilizacao;
  };
  const calcularProximasDisponibilizacoes = () => {
    const hoje = /* @__PURE__ */ new Date();
    const proximasDisponibilizacoes = [];
    for (let i = 0; i < 6; i++) {
      const data = new Date(hoje.getFullYear(), hoje.getMonth() + i, 1);
      const ano = data.getFullYear();
      const mes = data.getMonth() + 1;
      proximasDisponibilizacoes.push({
        tipo: "inicio_mes",
        mes,
        ano,
        dataDisponibilizacao: new Date(ano, mes - 1, 1),
        // Placeholder - ser manual
        descricao: `Holerite ${mes.toString().padStart(2, "0")}/${ano} - 1 Quinzena (Manual)`
      });
      const dataHolerite20 = calcularDataDisponibilizacaoHolerite20(ano, mes);
      proximasDisponibilizacoes.push({
        tipo: "dia_20",
        mes,
        ano,
        dataDisponibilizacao: dataHolerite20,
        descricao: `Holerite ${mes.toString().padStart(2, "0")}/${ano} - 2 Quinzena (Automtico)`
      });
    }
    return proximasDisponibilizacoes.sort(
      (a, b) => a.dataDisponibilizacao.getTime() - b.dataDisponibilizacao.getTime()
    );
  };
  const formatarData = (data) => {
    return data.toLocaleDateString("pt-BR", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric"
    });
  };
  const formatarDataHora = (data) => {
    return data.toLocaleString("pt-BR", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  const calcularPeriodoQuinzenal = (ano, mes, quinzena) => {
    if (quinzena === 1) {
      return {
        inicio: new Date(ano, mes - 1, 1),
        fim: new Date(ano, mes - 1, 15),
        descricao: `1 Quinzena - 01 a 15/${mes.toString().padStart(2, "0")}/${ano}`
      };
    } else {
      const ultimoDia = new Date(ano, mes, 0).getDate();
      return {
        inicio: new Date(ano, mes - 1, 16),
        fim: new Date(ano, mes - 1, ultimoDia),
        descricao: `2 Quinzena - 16 a ${ultimoDia}/${mes.toString().padStart(2, "0")}/${ano}`
      };
    }
  };
  const isSalarioQuinzenal = (funcionario) => {
    return funcionario?.tipo_salario === "quinzenal";
  };
  const calcularValorQuinzenal = (salarioMensal) => {
    return salarioMensal / 2;
  };
  return {
    // Funes de tipo de holerite
    isAdiantamento,
    getTipoHolerite,
    getTipoLabel,
    // Funes de data e feriados
    isFeriado,
    isFimDeSemana,
    isDiaUtil,
    obterUltimoDiaUtil,
    calcularDataDisponibilizacaoHolerite20,
    deveEstarDisponivelHolerite20,
    calcularProximasDisponibilizacoes,
    // Funes de formatao
    formatarData,
    formatarDataHora,
    // Funes de clculo
    calcularPeriodoQuinzenal,
    isSalarioQuinzenal,
    calcularValorQuinzenal
  };
};
const _sfc_main$1$7 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "HoleriteCard",
  __ssrInlineRender: true,
  props: {
    holerite: {}
  },
  emits: ["view", "download"],
  setup(__props) {
    const props = __props;
    const { formatarData } = useHolerites();
    const isDisponivel = vueExports.computed(() => {
      return true;
    });
    const formatarMoeda = (valor) => {
      if (valor === void 0 || valor === null) {
        return "0,00";
      }
      try {
        return valor.toFixed(2).replace(".", ",");
      } catch (error) {
        return "0,00";
      }
    };
    const getStatusColor = (status) => {
      const colors = {
        "Pago": {
          bg: "bg-green-100",
          badge: "bg-green-100 text-green-800"
        },
        "Pendente": {
          bg: "bg-yellow-100",
          badge: "bg-yellow-100 text-yellow-800"
        },
        "Programado": {
          bg: "bg-blue-100",
          badge: "bg-blue-100 text-blue-800"
        },
        "Cancelado": {
          bg: "bg-red-100",
          badge: "bg-red-100 text-red-800"
        },
        "enviado": {
          bg: "bg-green-100",
          badge: "bg-green-100 text-green-800"
        },
        "gerado": {
          bg: "bg-blue-100",
          badge: "bg-blue-100 text-blue-800"
        }
      };
      return colors[status || "Pendente"] || colors["Pendente"];
    };
    const isAdiantamento = vueExports.computed(() => {
      return props.holerite?.quinzena === 1 || props.holerite?.tipo?.toLowerCase().includes("adiantamento") || props.holerite?.referencia?.toLowerCase().includes("adiantamento");
    });
    const getTipoHoleriteStyle = () => {
      if (isAdiantamento.value) {
        return {
          card: "bg-gradient-to-br from-orange-50 to-yellow-50 border-orange-200",
          icon: "bg-gradient-to-br from-orange-400 to-yellow-500 text-white shadow-lg",
          badge: "bg-gradient-to-r from-orange-500 to-yellow-600 text-white shadow-sm"
        };
      } else {
        return {
          card: "bg-gradient-to-br from-blue-50 to-indigo-50 border-blue-200",
          icon: "bg-gradient-to-br from-blue-500 to-indigo-600 text-white shadow-lg",
          badge: "bg-gradient-to-r from-blue-600 to-indigo-700 text-white shadow-sm"
        };
      }
    };
    const getTipoHoleriteIcon = () => {
      return isAdiantamento.value ? "" : "";
    };
    const getTipoHoleriteLabel = () => {
      return isAdiantamento.value ? "Adiantamento" : "Folha Mensal";
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiButton = __nuxt_component_1$4;
      if (__props.holerite) {
        _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({
          class: [
            "border rounded-xl p-6 hover:shadow-lg transition-shadow",
            getTipoHoleriteStyle().card
          ]
        }, _attrs))}><div class="flex items-start justify-between"><div class="flex-1"><div class="flex items-center gap-3 mb-3"><div class="${ssrRenderClass_1([
          "w-12 h-12 rounded-full flex items-center justify-center text-2xl",
          getTipoHoleriteStyle().icon
        ])}">${ssrInterpolate_1(getTipoHoleriteIcon())}</div><div><div class="flex items-center gap-2 mb-1"><h3 class="text-lg font-bold text-gray-800">${ssrInterpolate_1(__props.holerite.referencia)}</h3><span class="${ssrRenderClass_1([
          "px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide",
          getTipoHoleriteStyle().badge
        ])}">${ssrInterpolate_1(getTipoHoleriteLabel())}</span></div><div class="flex items-center gap-2 text-sm text-gray-500"><span>${ssrInterpolate_1(__props.holerite.competencia)}</span>`);
        if (__props.holerite.quinzena) {
          _push(`<span class="px-2 py-0.5 bg-blue-100 text-blue-800 rounded-full text-xs font-medium">${ssrInterpolate_1(__props.holerite.quinzena)} Quinzena </span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<span class="${ssrRenderClass_1([
          "px-2 py-0.5 rounded-full text-xs font-medium",
          getStatusColor(__props.holerite.status).badge
        ])}">${ssrInterpolate_1(__props.holerite.status)}</span></div></div></div><div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4"><div><div class="text-xs text-gray-500 mb-1">Proventos</div><div class="text-sm font-semibold text-green-600"> R$ ${ssrInterpolate_1(formatarMoeda(__props.holerite.totalProventos))}</div></div><div><div class="text-xs text-gray-500 mb-1">Descontos</div><div class="text-sm font-semibold text-red-600"> R$ ${ssrInterpolate_1(formatarMoeda(__props.holerite.totalDescontos))}</div></div><div><div class="text-xs text-gray-500 mb-1">Lquido</div><div class="text-lg font-bold text-blue-600"> R$ ${ssrInterpolate_1(formatarMoeda(__props.holerite.liquido))}</div></div>`);
        if (__props.holerite.dataDisponibilizacao) {
          _push(`<div><div class="text-xs text-gray-500 mb-1">Disponvel em</div><div class="text-sm font-medium text-gray-700">${ssrInterpolate_1(__props.holerite.dataDisponibilizacao ? vueExports.unref(formatarData)(__props.holerite.dataDisponibilizacao) : "N/A")}</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
        if (__props.holerite.periodoInicio && __props.holerite.periodoFim) {
          _push(`<div class="mt-3 p-3 bg-blue-50 rounded-lg"><div class="text-xs text-blue-700 font-medium mb-1"> Perodo de Referncia</div><div class="text-sm text-blue-800">${ssrInterpolate_1(__props.holerite.periodoInicio ? vueExports.unref(formatarData)(__props.holerite.periodoInicio) : "N/A")} at ${ssrInterpolate_1(__props.holerite.periodoFim ? vueExports.unref(formatarData)(__props.holerite.periodoFim) : "N/A")}</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div><div class="flex flex-col gap-2 ml-4">`);
        _push(ssrRenderComponent_1(_component_UiButton, {
          variant: "primary",
          size: "sm",
          onClick: ($event) => _ctx.$emit("view", __props.holerite),
          disabled: !vueExports.unref(isDisponivel)
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  Visualizar `);
            } else {
              return [
                vueExports.createTextVNode("  Visualizar ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_UiButton, {
          variant: "secondary",
          size: "sm",
          onClick: ($event) => _ctx.$emit("download", __props.holerite),
          disabled: !vueExports.unref(isDisponivel)
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`  Baixar PDF `);
            } else {
              return [
                vueExports.createTextVNode("  Baixar PDF ")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div></div></div>`);
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$7 = _sfc_main$1$7.setup;
_sfc_main$1$7.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/holerites/HoleriteCard.vue");
  return _sfc_setup$1$7 ? _sfc_setup$1$7(props, ctx) : void 0;
};
const HoleriteCard = Object.assign(_sfc_main$1$7, { __name: "HoleritesHoleriteCard" });
const _sfc_main$l = /* @__PURE__ */ vueExports.defineComponent({
  __name: "holerites",
  __ssrInlineRender: true,
  async setup(__props) {
    const { user } = useAuth();
    const {
      getTipoHolerite
    } = useHolerites();
    const filtroMes = vueExports.ref("");
    const filtroAno = vueExports.ref("");
    const filtroTipo = vueExports.ref("");
    const holeriteVisualizado = vueExports.ref(null);
    const holerites = vueExports.ref([]);
    const carregando = vueExports.ref(true);
    const temSalarioQuinzenal = vueExports.computed(() => {
      return user.value?.tipo_salario === "quinzenal";
    });
    const mesesOptions = [
      { value: "01", label: "Janeiro" },
      { value: "02", label: "Fevereiro" },
      { value: "03", label: "Maro" },
      { value: "04", label: "Abril" },
      { value: "05", label: "Maio" },
      { value: "06", label: "Junho" },
      { value: "07", label: "Julho" },
      { value: "08", label: "Agosto" },
      { value: "09", label: "Setembro" },
      { value: "10", label: "Outubro" },
      { value: "11", label: "Novembro" },
      { value: "12", label: "Dezembro" }
    ];
    const anosOptions = [
      { value: "2026", label: "2026" },
      { value: "2025", label: "2025" },
      { value: "2024", label: "2024" }
    ];
    const holeritesFiltrados = vueExports.computed(() => {
      return holerites.value.filter((h) => {
        if (filtroMes.value && h.mes !== filtroMes.value) return false;
        if (filtroAno.value && h.ano !== filtroAno.value) return false;
        if (filtroTipo.value) {
          const tipoHolerite = getTipoHolerite(h);
          if (filtroTipo.value === "adiantamento" && tipoHolerite !== "adiantamento") return false;
          if (filtroTipo.value === "folha_mensal" && tipoHolerite !== "folha_mensal") return false;
        }
        return true;
      });
    });
    const limparFiltros = () => {
      filtroMes.value = "";
      filtroAno.value = "";
      filtroTipo.value = "";
    };
    const visualizarHolerite = async (holerite) => {
      let dadosFuncionario = {
        nome_completo: user.value?.nome || "Funcionrio",
        cargo: user.value?.cargo || "No definido",
        empresa: "Empresa"
      };
      try {
        if (user.value) {
          const funcionarioCompleto = await $fetch(`/api/funcionarios/${user.value.id}`);
          dadosFuncionario = {
            nome_completo: funcionarioCompleto.nome_completo || user.value?.nome || "Funcionrio",
            cargo: funcionarioCompleto.cargo || user.value?.cargo || "No definido",
            empresa: "Empresa"
          };
          if (funcionarioCompleto.empresa_id) {
            const empresaResponse = await $fetch(`/api/empresas/${funcionarioCompleto.empresa_id}`);
            const empresa = empresaResponse.data || empresaResponse;
            dadosFuncionario.empresa = empresa.nome_fantasia || empresa.nome || "Empresa";
          }
        }
      } catch (error) {
        console.error("Erro ao buscar empresa:", error);
      }
      const holeriteCompleto = {
        ...holerite,
        funcionario: dadosFuncionario,
        // Garantir que as datas e valores estejam no formato correto
        periodo_inicio: holerite.periodoInicio,
        periodo_fim: holerite.periodoFim,
        salario_base: holerite.salarioBase,
        salario_liquido: holerite.liquido,
        // Corrigir o campo
        total_proventos: holerite.totalProventos,
        total_descontos: holerite.totalDescontos
      };
      holeriteVisualizado.value = holeriteCompleto;
    };
    const baixarPDF = (holerite) => {
      (void 0).open(`/api/holerites/${holerite.id}/pdf`, "_blank");
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiEmptyState = __nuxt_component_2;
      _push(`<div${ssrRenderAttrs_1(_attrs)}><div class="bg-white rounded-xl border border-gray-200 p-6 mb-6"><h3 class="text-lg font-semibold text-gray-900 mb-4"> Filtrar Holerites</h3><div class="flex flex-col sm:flex-row gap-4"><div class="flex-1"><label class="block text-sm font-medium text-gray-700 mb-1">Ms</label><select class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(filtroMes)) ? ssrLooseContain_1(vueExports.unref(filtroMes), "") : ssrLooseEqual_1(vueExports.unref(filtroMes), "")) ? " selected" : ""}>Todos os meses</option><!--[-->`);
      ssrRenderList_1(mesesOptions, (mes) => {
        _push(`<option${ssrRenderAttr_1("value", mes.value)}${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(filtroMes)) ? ssrLooseContain_1(vueExports.unref(filtroMes), mes.value) : ssrLooseEqual_1(vueExports.unref(filtroMes), mes.value)) ? " selected" : ""}>${ssrInterpolate_1(mes.label)}</option>`);
      });
      _push(`<!--]--></select></div><div class="flex-1"><label class="block text-sm font-medium text-gray-700 mb-1">Ano</label><select class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(filtroAno)) ? ssrLooseContain_1(vueExports.unref(filtroAno), "") : ssrLooseEqual_1(vueExports.unref(filtroAno), "")) ? " selected" : ""}>Todos os anos</option><!--[-->`);
      ssrRenderList_1(anosOptions, (ano) => {
        _push(`<option${ssrRenderAttr_1("value", ano.value)}${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(filtroAno)) ? ssrLooseContain_1(vueExports.unref(filtroAno), ano.value) : ssrLooseEqual_1(vueExports.unref(filtroAno), ano.value)) ? " selected" : ""}>${ssrInterpolate_1(ano.label)}</option>`);
      });
      _push(`<!--]--></select></div><div class="flex-1"><label class="block text-sm font-medium text-gray-700 mb-1">Tipo</label><select class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><option value=""${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(filtroTipo)) ? ssrLooseContain_1(vueExports.unref(filtroTipo), "") : ssrLooseEqual_1(vueExports.unref(filtroTipo), "")) ? " selected" : ""}>Todos os tipos</option><option value="adiantamento"${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(filtroTipo)) ? ssrLooseContain_1(vueExports.unref(filtroTipo), "adiantamento") : ssrLooseEqual_1(vueExports.unref(filtroTipo), "adiantamento")) ? " selected" : ""}> Adiantamento</option><option value="folha_mensal"${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(filtroTipo)) ? ssrLooseContain_1(vueExports.unref(filtroTipo), "folha_mensal") : ssrLooseEqual_1(vueExports.unref(filtroTipo), "folha_mensal")) ? " selected" : ""}> Folha Mensal</option></select></div><div class="flex items-end">`);
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "secondary",
        onClick: limparFiltros
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`Limpar`);
          } else {
            return [
              vueExports.createTextVNode("Limpar")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div>`);
      if (vueExports.unref(temSalarioQuinzenal)) {
        _push(`<div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-xl"><div class="flex items-start gap-3"><span class="text-2xl"></span><div><h3 class="font-semibold text-blue-800 mb-2">Holerites Automticos</h3><div class="text-sm text-blue-700 space-y-1"><p> <strong>2 Quinzena:</strong> Disponibilizado automaticamente 2 dias antes do dia 20</p><p> <strong>1 Quinzena:</strong> Liberado manualmente pelo RH no incio do ms</p><p> <strong>Fins de semana/Feriados:</strong> Antecipado para o ltimo dia til anterior</p></div></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (!vueExports.unref(user)) {
        _push(`<div class="text-center py-12"><p class="text-red-600"> Erro: Usurio no autenticado. Faa login novamente.</p></div>`);
      } else if (vueExports.unref(carregando)) {
        _push(`<div class="text-center py-12"><div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div><p class="mt-4 text-gray-600">Carregando holerites...</p></div>`);
      } else {
        _push(`<div class="space-y-4"><!--[-->`);
        ssrRenderList_1(vueExports.unref(holeritesFiltrados), (holerite) => {
          _push(`<!--[-->`);
          if (holerite && holerite.id) {
            _push(ssrRenderComponent_1(HoleriteCard, {
              holerite,
              onView: visualizarHolerite,
              onDownload: baixarPDF
            }, null, _parent));
          } else {
            _push(`<!---->`);
          }
          _push(`<!--]-->`);
        });
        _push(`<!--]-->`);
        if (vueExports.unref(holeritesFiltrados).length === 0) {
          _push(ssrRenderComponent_1(_component_UiEmptyState, {
            title: "Nenhum holerite encontrado",
            description: "Tente ajustar os filtros ou aguarde a gerao do prximo holerite."
          }, null, _parent));
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      }
      if (vueExports.unref(holeriteVisualizado)) {
        _push(ssrRenderComponent_1(HoleriteModal, {
          holerite: vueExports.unref(holeriteVisualizado),
          "user-name": vueExports.unref(user)?.nome || "",
          "user-cargo": vueExports.unref(user)?.cargo || "",
          "user-departamento": vueExports.unref(user)?.departamento || "",
          onClose: ($event) => holeriteVisualizado.value = null,
          onDownload: baixarPDF
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$l = _sfc_main$l.setup;
_sfc_main$l.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/holerites.vue");
  return _sfc_setup$l ? _sfc_setup$l(props, ctx) : void 0;
};

const holeritesCiIcbPKe = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$l
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$k = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiPageHeader",
  __ssrInlineRender: true,
  props: {
    title: {},
    description: {}
  },
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-8" }, _attrs))}><div><h1 class="text-3xl lg:text-4xl font-bold text-gray-800">${ssrInterpolate_1(__props.title)}</h1>`);
      if (__props.description) {
        _push(`<p class="text-lg text-gray-500 mt-2">${ssrInterpolate_1(__props.description)}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
      ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</div>`);
    };
  }
});
const _sfc_setup$k = _sfc_main$k.setup;
_sfc_main$k.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiPageHeader.vue");
  return _sfc_setup$k ? _sfc_setup$k(props, ctx) : void 0;
};
const __nuxt_component_0$3 = Object.assign(_sfc_main$k, { __name: "UiPageHeader" });

const _sfc_main$j = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiAvatar",
  __ssrInlineRender: true,
  props: {
    name: {},
    src: {},
    avatarType: {},
    size: { default: "md" },
    color: { default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const initials = vueExports.computed(() => {
      return props.name.split(" ").map((n) => n.charAt(0)).slice(0, 2).join("").toUpperCase();
    });
    const sizeClasses = vueExports.computed(() => {
      const sizes = {
        sm: "w-10 h-10",
        md: "w-12 h-12",
        lg: "w-16 h-16",
        xl: "w-32 h-32"
      };
      return sizes[props.size];
    });
    const textSizeClass = vueExports.computed(() => {
      const sizes = {
        sm: "text-sm",
        md: "text-lg",
        lg: "text-2xl",
        xl: "text-5xl"
      };
      return sizes[props.size];
    });
    const colorClasses = vueExports.computed(() => {
      if (props.avatarType) {
        return "bg-gray-100";
      }
      const colors = {
        primary: "bg-primary-100 text-primary-700",
        green: "bg-green-100 text-green-700",
        orange: "bg-orange-200 text-orange-700",
        purple: "bg-purple-100 text-purple-700",
        gray: "bg-gray-100 text-gray-500"
      };
      return colors[props.color];
    });
    const avatarMap = {
      // Avatares bsicos
      "person-1": "",
      // GERENTE - Responsvel por Fiscal, Financeiro, Comercial, RH e Administrativo
      "gerente-1": "",
      "gerente-2": "",
      "gerente-3": "",
      "gerente-4": "",
      // ASSISTENTE COMERCIAL
      "ass-comercial-1": "",
      "ass-comercial-2": "",
      "ass-comercial-3": "",
      "ass-comercial-4": "",
      "ass-comercial-5": "",
      // REPRESENTANTE COMERCIAL
      "rep-comercial-1": "",
      "rep-comercial-2": "",
      "rep-comercial-3": "",
      // AUXILIAR COMERCIAL
      "aux-comercial-1": "",
      "aux-comercial-2": "",
      "aux-comercial-3": "",
      // ASSISTENTE DE PRODUO
      "ass-producao-1": "",
      "ass-producao-2": "",
      "ass-producao-3": "",
      "ass-producao-4": "",
      // AUXILIAR DE PRODUO
      "aux-producao-1": "",
      "aux-producao-2": "",
      "aux-producao-3": "",
      // SOLDADOR
      "soldador-1": "",
      "soldador-2": "",
      "soldador-3": "",
      "soldador-4": "",
      "soldador-5": "",
      "soldador-6": "",
      // AUXILIAR ADMINISTRATIVO
      "aux-admin-1": "",
      "aux-admin-2": "",
      "aux-admin-3": "",
      "aux-admin-4": "",
      // LDER DE ESTOQUE
      "lider-estoque-1": "",
      "lider-estoque-2": "",
      "lider-estoque-3": "",
      "lider-estoque-4": "",
      // AUXILIAR DE ESTOQUE
      "aux-estoque-1": "",
      "aux-estoque-2": "",
      "aux-estoque-3": "",
      "aux-estoque-4": "",
      // AUXILIAR DE EXPEDIO
      "aux-expedicao-1": "",
      "aux-expedicao-2": "",
      "aux-expedicao-3": "",
      "aux-expedicao-4": "",
      // AUXILIAR DE SERVIOS GERAIS
      "aux-servicos-1": "",
      "aux-servicos-2": "",
      "aux-servicos-3": "",
      "aux-servicos-4": "",
      // TI (Tcnico de Informtica)
      "ti-1": "",
      "ti-2": "",
      "ti-3": "",
      "ti-4": "",
      "ti-5": "",
      "ti-6": ""
    };
    const getAvatarEmoji = (avatarType) => {
      return avatarMap[avatarType] || "";
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({
        class: [
          "rounded-xl flex items-center justify-center font-bold",
          vueExports.unref(sizeClasses),
          vueExports.unref(colorClasses)
        ]
      }, _attrs))}>`);
      if (__props.src) {
        _push(`<img${ssrRenderAttr_1("src", __props.src)}${ssrRenderAttr_1("alt", __props.name)} class="w-full h-full object-cover rounded-xl">`);
      } else if (__props.avatarType) {
        _push(`<div class="${ssrRenderClass_1(vueExports.unref(textSizeClass))}">${ssrInterpolate_1(getAvatarEmoji(__props.avatarType))}</div>`);
      } else {
        _push(`<span class="${ssrRenderClass_1(vueExports.unref(textSizeClass))}">${ssrInterpolate_1(vueExports.unref(initials))}</span>`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$j = _sfc_main$j.setup;
_sfc_main$j.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiAvatar.vue");
  return _sfc_setup$j ? _sfc_setup$j(props, ctx) : void 0;
};
const __nuxt_component_1$3 = Object.assign(_sfc_main$j, { __name: "UiAvatar" });

const _sfc_main$i = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiSelect",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    options: {},
    label: {},
    placeholder: {},
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const getOptionValue = (opt) => {
      if (opt.value === null) return "";
      return opt.value.toString();
    };
    const isSelected = (opt) => {
      if (opt.value === null) {
        return props.modelValue === null || props.modelValue === "" || props.modelValue === void 0;
      }
      if (props.modelValue === null || props.modelValue === void 0) {
        return false;
      }
      return opt.value === props.modelValue || opt.value.toString() === props.modelValue.toString();
    };
    const id = vueExports.computed(() => `select-${Math.random().toString(36).substr(2, 9)}`);
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", vueExports.unref(id))} class="block text-sm font-medium text-gray-600 mb-1">${ssrInterpolate_1(__props.label)} `);
        if (__props.required) {
          _push(`<span class="text-red-500">*</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<select${ssrRenderAttr_1("id", vueExports.unref(id))}${ssrRenderAttr_1("value", __props.modelValue)}${ssrIncludeBooleanAttr(__props.disabled) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""} class="${ssrRenderClass_1([
        "w-full px-4 py-3 text-lg border-2 rounded-xl outline-none transition-colors",
        __props.disabled ? "border-gray-100 bg-gray-50 text-gray-500" : "border-gray-200 focus:border-primary-500"
      ])}">`);
      if (__props.placeholder) {
        _push(`<option value="">${ssrInterpolate_1(__props.placeholder)}</option>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<!--[-->`);
      ssrRenderList_1(__props.options, (opt) => {
        _push(`<option${ssrRenderAttr_1("value", getOptionValue(opt))}${ssrIncludeBooleanAttr(isSelected(opt)) ? " selected" : ""}>${ssrInterpolate_1(opt.label)}</option>`);
      });
      _push(`<!--]--></select></div>`);
    };
  }
});
const _sfc_setup$i = _sfc_main$i.setup;
_sfc_main$i.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiSelect.vue");
  return _sfc_setup$i ? _sfc_setup$i(props, ctx) : void 0;
};
const __nuxt_component_6$1 = Object.assign(_sfc_main$i, { __name: "UiSelect" });

const _sfc_main$h = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiInputPIS",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    label: {},
    placeholder: { default: "000.00000.00-0" },
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    error: {}
  },
  emits: ["update:modelValue", "blur"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const id = vueExports.computed(() => `pis-${Math.random().toString(36).substr(2, 9)}`);
    const displayValue = vueExports.computed(() => {
      return formatarPIS(props.modelValue);
    });
    const formatarPIS = (valor) => {
      if (!valor) return "";
      const numeros = valor.replace(/\D/g, "");
      if (numeros.length <= 3) {
        return numeros;
      } else if (numeros.length <= 8) {
        return `${numeros.slice(0, 3)}.${numeros.slice(3)}`;
      } else if (numeros.length <= 10) {
        return `${numeros.slice(0, 3)}.${numeros.slice(3, 8)}.${numeros.slice(8)}`;
      } else {
        return `${numeros.slice(0, 3)}.${numeros.slice(3, 8)}.${numeros.slice(8, 10)}-${numeros.slice(10, 11)}`;
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", vueExports.unref(id))} class="block text-sm font-medium text-gray-600 mb-1">${ssrInterpolate_1(__props.label)} `);
        if (__props.required) {
          _push(`<span class="text-red-500">*</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<input${ssrRenderAttr_1("id", vueExports.unref(id))} type="text"${ssrRenderAttr_1("value", vueExports.unref(displayValue))}${ssrRenderAttr_1("placeholder", __props.placeholder)}${ssrIncludeBooleanAttr(__props.disabled) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""} class="${ssrRenderClass_1([
        "w-full px-4 py-3 text-lg border-2 rounded-xl outline-none transition-colors",
        __props.disabled ? "border-gray-100 bg-gray-50 text-gray-500" : "border-gray-200 focus:border-primary-500"
      ])}" maxlength="14">`);
      if (__props.error) {
        _push(`<p class="mt-1 text-sm text-red-600">${ssrInterpolate_1(__props.error)}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$h = _sfc_main$h.setup;
_sfc_main$h.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiInputPIS.vue");
  return _sfc_setup$h ? _sfc_setup$h(props, ctx) : void 0;
};
const __nuxt_component_1$2 = Object.assign(_sfc_main$h, { __name: "UiInputPIS" });

const _sfc_main$g = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiAlert",
  __ssrInlineRender: true,
  props: {
    variant: { default: "info" },
    title: {},
    icon: {},
    showIcon: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const variantClasses = vueExports.computed(() => {
      const variants = {
        info: "bg-blue-50 border border-blue-200 text-blue-800",
        success: "bg-green-50 border border-green-200 text-green-800",
        warning: "bg-yellow-50 border border-yellow-200 text-yellow-800",
        error: "bg-red-50 border border-red-200 text-red-800"
      };
      return variants[props.variant];
    });
    const iconPath = vueExports.computed(() => {
      const icons = {
        info: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z",
        success: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z",
        warning: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z",
        error: "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
      };
      return icons[props.variant];
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({
        class: ["rounded-xl p-4 flex items-start gap-3", vueExports.unref(variantClasses)]
      }, _attrs))}>`);
      if (__props.showIcon) {
        _push(`<svg class="w-6 h-6 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"${ssrRenderAttr_1("d", vueExports.unref(iconPath))}></path></svg>`);
      } else {
        _push(`<!---->`);
      }
      if (__props.icon) {
        _push(`<span class="text-xl flex-shrink-0">${ssrInterpolate_1(__props.icon)}</span>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex-1">`);
      if (__props.title) {
        _push(`<p class="font-semibold mb-1">${ssrInterpolate_1(__props.title)}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<p>`);
      ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</p></div></div>`);
    };
  }
});
const _sfc_setup$g = _sfc_main$g.setup;
_sfc_main$g.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiAlert.vue");
  return _sfc_setup$g ? _sfc_setup$g(props, ctx) : void 0;
};
const __nuxt_component_1$1 = Object.assign(_sfc_main$g, { __name: "UiAlert" });

const _sfc_main$f = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiNotification",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    title: {},
    message: {},
    variant: { default: "success" },
    duration: { default: 5e3 }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    vueExports.watch(() => props.show, (newShow) => {
      if (newShow && props.duration > 0) {
        setTimeout(() => {
          emit("close");
        }, props.duration);
      }
    });
    const variantClasses = vueExports.computed(() => {
      const variants = {
        success: "border-green-500 text-green-700 bg-green-50",
        error: "border-red-500 text-red-700 bg-red-50",
        warning: "border-yellow-500 text-yellow-700 bg-yellow-50",
        info: "border-blue-500 text-blue-700 bg-blue-50"
      };
      return variants[props.variant];
    });
    const iconPath = vueExports.computed(() => {
      const icons = {
        success: "M5 13l4 4L19 7",
        error: "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z",
        warning: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z",
        info: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
      };
      return icons[props.variant];
    });
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderTeleport_1(_push, (_push2) => {
        if (__props.show) {
          _push2(`<div class="${ssrRenderClass_1([
            "fixed top-4 right-4 z-50 max-w-sm w-full bg-white rounded-xl shadow-lg border-l-4 p-4",
            vueExports.unref(variantClasses)
          ])}" data-v-09772c10><div class="flex items-start gap-3" data-v-09772c10><div class="flex-shrink-0" data-v-09772c10><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-09772c10><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"${ssrRenderAttr_1("d", vueExports.unref(iconPath))} data-v-09772c10></path></svg></div><div class="flex-1" data-v-09772c10><p class="font-semibold" data-v-09772c10>${ssrInterpolate_1(__props.title)}</p>`);
          if (__props.message) {
            _push2(`<p class="text-sm opacity-90 mt-1" data-v-09772c10>${ssrInterpolate_1(__props.message)}</p>`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`</div><button class="flex-shrink-0 p-1 rounded-lg hover:bg-black/10 transition-colors" data-v-09772c10><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-09772c10><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" data-v-09772c10></path></svg></button></div></div>`);
        } else {
          _push2(`<!---->`);
        }
      }, "body", false, _parent);
    };
  }
});
const _sfc_setup$f = _sfc_main$f.setup;
_sfc_main$f.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiNotification.vue");
  return _sfc_setup$f ? _sfc_setup$f(props, ctx) : void 0;
};
const __nuxt_component_7 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$f, [["__scopeId", "data-v-09772c10"]]), { __name: "UiNotification" });

const _sfc_main$3$2 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiInputCPF",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    label: {},
    placeholder: { default: "000.000.000-00" },
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    hint: {},
    error: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const id = vueExports.computed(() => `cpf-input-${Math.random().toString(36).substring(2, 11)}`);
    const displayValue = vueExports.computed(() => {
      return formatarCPF(props.modelValue);
    });
    const cpfValido = vueExports.computed(() => {
      const cpfLimpo = props.modelValue.replace(/[^\d]/g, "");
      return cpfLimpo.length === 11 && validarCPF(cpfLimpo);
    });
    function formatarCPF(cpf) {
      const cpfLimpo = cpf.replace(/[^\d]/g, "");
      if (cpfLimpo.length <= 3) return cpfLimpo;
      if (cpfLimpo.length <= 6) return cpfLimpo.replace(/^(\d{3})(\d+)/, "$1.$2");
      if (cpfLimpo.length <= 9) return cpfLimpo.replace(/^(\d{3})(\d{3})(\d+)/, "$1.$2.$3");
      return cpfLimpo.replace(/^(\d{3})(\d{3})(\d{3})(\d+)/, "$1.$2.$3-$4");
    }
    function validarCPF(cpf) {
      const cpfLimpo = cpf.replace(/[^\d]/g, "");
      if (cpfLimpo.length !== 11) return false;
      if (/^(\d)\1+$/.test(cpfLimpo)) return false;
      let soma = 0;
      for (let i = 0; i < 9; i++) {
        soma += parseInt(cpfLimpo.charAt(i)) * (10 - i);
      }
      let digito1 = 11 - soma % 11;
      if (digito1 > 9) digito1 = 0;
      if (parseInt(cpfLimpo.charAt(9)) !== digito1) return false;
      soma = 0;
      for (let i = 0; i < 10; i++) {
        soma += parseInt(cpfLimpo.charAt(i)) * (11 - i);
      }
      let digito2 = 11 - soma % 11;
      if (digito2 > 9) digito2 = 0;
      return parseInt(cpfLimpo.charAt(10)) === digito2;
    }
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", vueExports.unref(id))} class="block text-sm font-medium text-gray-600 mb-1">${ssrInterpolate_1(__props.label)} `);
        if (__props.required) {
          _push(`<span class="text-red-500">*</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="relative"><input${ssrRenderAttr_1("id", vueExports.unref(id))}${ssrRenderAttr_1("value", vueExports.unref(displayValue))}${ssrRenderAttr_1("placeholder", __props.placeholder)}${ssrIncludeBooleanAttr(__props.disabled) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""} class="${ssrRenderClass_1([
        "w-full px-4 py-3 text-lg border-2 rounded-xl outline-none transition-colors",
        __props.disabled ? "border-gray-100 bg-gray-50 text-gray-500" : "border-gray-200 focus:border-primary-500",
        __props.error ? "border-red-300" : "",
        vueExports.unref(cpfValido) ? "border-green-300" : ""
      ])}">`);
      if (__props.modelValue && !__props.disabled) {
        _push(`<div class="absolute right-4 top-1/2 -translate-y-1/2">`);
        if (vueExports.unref(cpfValido)) {
          _push(`<svg class="w-5 h-5 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`);
        } else if (__props.modelValue.length >= 11) {
          _push(`<svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6m0 0l-6-6m6 6l-6 6"></path></svg>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div class="mt-1 space-y-1">`);
      if (__props.hint && !__props.error) {
        _push(`<p class="text-xs text-gray-400">${ssrInterpolate_1(__props.hint)}</p>`);
      } else {
        _push(`<!---->`);
      }
      if (__props.error) {
        _push(`<p class="text-xs text-red-500">${ssrInterpolate_1(__props.error)}</p>`);
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(cpfValido) && !__props.error) {
        _push(`<p class="text-xs text-green-600">CPF vlido</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$3$2 = _sfc_main$3$2.setup;
_sfc_main$3$2.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiInputCPF.vue");
  return _sfc_setup$3$2 ? _sfc_setup$3$2(props, ctx) : void 0;
};
const __nuxt_component_6 = Object.assign(_sfc_main$3$2, { __name: "UiInputCPF" });
const _sfc_main$2$3 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiInputPhone",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    label: {},
    placeholder: { default: "(11) 99999-9999" },
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    hint: {},
    error: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const id = vueExports.computed(() => `phone-input-${Math.random().toString(36).substring(2, 11)}`);
    const displayValue = vueExports.computed(() => {
      return formatarTelefone(props.modelValue);
    });
    function formatarTelefone(telefone) {
      const telLimpo = telefone.replace(/[^\d]/g, "");
      if (telLimpo.length <= 2) return telLimpo;
      if (telLimpo.length <= 6) return telLimpo.replace(/^(\d{2})(\d+)/, "($1) $2");
      if (telLimpo.length <= 10) return telLimpo.replace(/^(\d{2})(\d{4})(\d+)/, "($1) $2-$3");
      return telLimpo.replace(/^(\d{2})(\d{5})(\d+)/, "($1) $2-$3");
    }
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", vueExports.unref(id))} class="block text-sm font-medium text-gray-600 mb-1">${ssrInterpolate_1(__props.label)} `);
        if (__props.required) {
          _push(`<span class="text-red-500">*</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<input${ssrRenderAttr_1("id", vueExports.unref(id))}${ssrRenderAttr_1("value", vueExports.unref(displayValue))}${ssrRenderAttr_1("placeholder", __props.placeholder)}${ssrIncludeBooleanAttr(__props.disabled) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""} class="${ssrRenderClass_1([
        "w-full px-4 py-3 text-lg border-2 rounded-xl outline-none transition-colors",
        __props.disabled ? "border-gray-100 bg-gray-50 text-gray-500" : "border-gray-200 focus:border-primary-500",
        __props.error ? "border-red-300" : ""
      ])}"><div class="mt-1 space-y-1">`);
      if (__props.hint && !__props.error) {
        _push(`<p class="text-xs text-gray-400">${ssrInterpolate_1(__props.hint)}</p>`);
      } else {
        _push(`<!---->`);
      }
      if (__props.error) {
        _push(`<p class="text-xs text-red-500">${ssrInterpolate_1(__props.error)}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$2$3 = _sfc_main$2$3.setup;
_sfc_main$2$3.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiInputPhone.vue");
  return _sfc_setup$2$3 ? _sfc_setup$2$3(props, ctx) : void 0;
};
const __nuxt_component_8 = Object.assign(_sfc_main$2$3, { __name: "UiInputPhone" });
const _sfc_main$1$6 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiAvatarSelector",
  __ssrInlineRender: true,
  props: {
    show: { type: Boolean },
    userName: {},
    currentAvatar: {}
  },
  emits: ["close", "save"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const selectedAvatar = vueExports.ref(props.currentAvatar || "person-1");
    const saving = vueExports.ref(false);
    const avatarOptions = [
      // Avatares bsicos
      { id: "person-1", name: "Pessoa Padro", emoji: "" },
      // GERENTE - Responsvel por Fiscal, Financeiro, Comercial, RH e Administrativo
      { id: "gerente-1", name: "Gerente", emoji: "" },
      { id: "gerente-2", name: "Gerente", emoji: "" },
      { id: "gerente-3", name: "Gerente Moreno", emoji: "" },
      { id: "gerente-4", name: "Gerente Morena", emoji: "" },
      // ASSISTENTE COMERCIAL
      { id: "ass-comercial-1", name: "Assistente Comercial", emoji: "" },
      { id: "ass-comercial-2", name: "Assistente Comercial", emoji: "" },
      { id: "ass-comercial-3", name: "Assistente Comercial", emoji: "" },
      { id: "ass-comercial-4", name: "Assistente Comercial Moreno", emoji: "" },
      { id: "ass-comercial-5", name: "Assistente Comercial Morena", emoji: "" },
      // REPRESENTANTE COMERCIAL
      { id: "rep-comercial-1", name: "Representante Comercial", emoji: "" },
      { id: "rep-comercial-2", name: "Representante Comercial", emoji: "" },
      { id: "rep-comercial-3", name: "Representante Comercial", emoji: "" },
      // AUXILIAR COMERCIAL
      { id: "aux-comercial-1", name: "Auxiliar Comercial", emoji: "" },
      { id: "aux-comercial-2", name: "Auxiliar Comercial", emoji: "" },
      { id: "aux-comercial-3", name: "Auxiliar Comercial", emoji: "" },
      // ASSISTENTE DE PRODUO
      { id: "ass-producao-1", name: "Assistente de Produo", emoji: "" },
      { id: "ass-producao-2", name: "Assistente de Produo", emoji: "" },
      { id: "ass-producao-3", name: "Assistente de Produo Moreno", emoji: "" },
      { id: "ass-producao-4", name: "Assistente de Produo Morena", emoji: "" },
      // AUXILIAR DE PRODUO
      { id: "aux-producao-1", name: "Auxiliar de Produo", emoji: "" },
      { id: "aux-producao-2", name: "Auxiliar de Produo", emoji: "" },
      { id: "aux-producao-3", name: "Auxiliar de Produo", emoji: "" },
      // SOLDADOR
      { id: "soldador-1", name: "Soldador", emoji: "" },
      { id: "soldador-2", name: "Soldador", emoji: "" },
      { id: "soldador-3", name: "Soldador Moreno", emoji: "" },
      { id: "soldador-4", name: "Soldador Morena", emoji: "" },
      { id: "soldador-5", name: "Soldador", emoji: "" },
      { id: "soldador-6", name: "Soldador", emoji: "" },
      // AUXILIAR ADMINISTRATIVO
      { id: "aux-admin-1", name: "Auxiliar Administrativo", emoji: "" },
      { id: "aux-admin-2", name: "Auxiliar Administrativo", emoji: "" },
      { id: "aux-admin-3", name: "Auxiliar Administrativo", emoji: "" },
      { id: "aux-admin-4", name: "Auxiliar Administrativo", emoji: "" },
      // LDER DE ESTOQUE
      { id: "lider-estoque-1", name: "Lder de Estoque", emoji: "" },
      { id: "lider-estoque-2", name: "Lder de Estoque", emoji: "" },
      { id: "lider-estoque-3", name: "Lder de Estoque Moreno", emoji: "" },
      { id: "lider-estoque-4", name: "Lder de Estoque Morena", emoji: "" },
      // AUXILIAR DE ESTOQUE
      { id: "aux-estoque-1", name: "Auxiliar de Estoque", emoji: "" },
      { id: "aux-estoque-2", name: "Auxiliar de Estoque", emoji: "" },
      { id: "aux-estoque-3", name: "Auxiliar de Estoque", emoji: "" },
      { id: "aux-estoque-4", name: "Auxiliar de Estoque", emoji: "" },
      // AUXILIAR DE EXPEDIO
      { id: "aux-expedicao-1", name: "Auxiliar de Expedio", emoji: "" },
      { id: "aux-expedicao-2", name: "Auxiliar de Expedio", emoji: "" },
      { id: "aux-expedicao-3", name: "Auxiliar de Expedio", emoji: "" },
      { id: "aux-expedicao-4", name: "Auxiliar de Expedio", emoji: "" },
      // AUXILIAR DE SERVIOS GERAIS
      { id: "aux-servicos-1", name: "Auxiliar de Servios Gerais", emoji: "" },
      { id: "aux-servicos-2", name: "Auxiliar de Servios Gerais", emoji: "" },
      { id: "aux-servicos-3", name: "Auxiliar de Servios Gerais", emoji: "" },
      { id: "aux-servicos-4", name: "Auxiliar de Servios Gerais", emoji: "" },
      // TI (Tcnico de Informtica)
      { id: "ti-1", name: "Tcnico de TI", emoji: "" },
      { id: "ti-2", name: "Tcnico de TI", emoji: "" },
      { id: "ti-3", name: "Tcnico de TI Moreno", emoji: "" },
      { id: "ti-4", name: "Tcnico de TI Morena", emoji: "" },
      { id: "ti-5", name: "Tcnico de TI", emoji: "" },
      { id: "ti-6", name: "Tcnico de TI", emoji: "" }
    ];
    const selectAvatar = (avatarId) => {
      selectedAvatar.value = avatarId;
    };
    const saveAvatar = async () => {
      saving.value = true;
      try {
        emit("save", selectedAvatar.value);
      } finally {
        saving.value = false;
      }
    };
    vueExports.watch(() => props.currentAvatar, (newAvatar) => {
      if (newAvatar) {
        selectedAvatar.value = newAvatar;
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiModal = __nuxt_component_3;
      const _component_UiAvatar = __nuxt_component_1$3;
      const _component_UiButton = __nuxt_component_1$4;
      _push(ssrRenderComponent_1(_component_UiModal, vueExports.mergeProps({
        "model-value": __props.show,
        "onUpdate:modelValue": ($event) => _ctx.$emit("close"),
        title: "Escolher Avatar"
      }, _attrs), {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="space-y-6"${_scopeId}><div class="text-center"${_scopeId}><h3 class="text-lg font-semibold text-gray-800 mb-4"${_scopeId}>Avatar Atual</h3>`);
            _push2(ssrRenderComponent_1(_component_UiAvatar, {
              name: __props.userName,
              "avatar-type": __props.currentAvatar,
              size: "xl",
              class: "mx-auto mb-2"
            }, null, _parent2, _scopeId));
            _push2(`<p class="text-sm text-gray-500"${_scopeId}>${ssrInterpolate_1(__props.userName)}</p></div><div${_scopeId}><h3 class="text-lg font-semibold text-gray-800 mb-4"${_scopeId}>Escolha um Avatar</h3><div class="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 gap-4 max-h-96 overflow-y-auto"${_scopeId}><!--[-->`);
            ssrRenderList_1(avatarOptions, (avatar) => {
              _push2(`<button class="${ssrRenderClass_1([
                "p-2 rounded-xl border-2 transition-all hover:scale-105",
                vueExports.unref(selectedAvatar) === avatar.id ? "border-blue-500 bg-blue-50" : "border-gray-200 hover:border-gray-300"
              ])}"${_scopeId}><div class="text-4xl"${_scopeId}>${ssrInterpolate_1(avatar.emoji)}</div><p class="text-xs text-gray-600 mt-1"${_scopeId}>${ssrInterpolate_1(avatar.name)}</p></button>`);
            });
            _push2(`<!--]--></div></div><div class="flex justify-end gap-3 pt-4 border-t"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "ghost",
              onClick: ($event) => _ctx.$emit("close")
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Cancelar `);
                } else {
                  return [
                    vueExports.createTextVNode(" Cancelar ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              onClick: saveAvatar,
              disabled: vueExports.unref(saving)
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${ssrInterpolate_1(vueExports.unref(saving) ? "Salvando..." : "Salvar Avatar")}`);
                } else {
                  return [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(saving) ? "Salvando..." : "Salvar Avatar"), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "space-y-6" }, [
                vueExports.createVNode("div", { class: "text-center" }, [
                  vueExports.createVNode("h3", { class: "text-lg font-semibold text-gray-800 mb-4" }, "Avatar Atual"),
                  vueExports.createVNode(_component_UiAvatar, {
                    name: __props.userName,
                    "avatar-type": __props.currentAvatar,
                    size: "xl",
                    class: "mx-auto mb-2"
                  }, null, 8, ["name", "avatar-type"]),
                  vueExports.createVNode("p", { class: "text-sm text-gray-500" }, vueExports.toDisplayString(__props.userName), 1)
                ]),
                vueExports.createVNode("div", null, [
                  vueExports.createVNode("h3", { class: "text-lg font-semibold text-gray-800 mb-4" }, "Escolha um Avatar"),
                  vueExports.createVNode("div", { class: "grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 gap-4 max-h-96 overflow-y-auto" }, [
                    (vueExports.openBlock(), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(avatarOptions, (avatar) => {
                      return vueExports.createVNode("button", {
                        key: avatar.id,
                        onClick: ($event) => selectAvatar(avatar.id),
                        class: [
                          "p-2 rounded-xl border-2 transition-all hover:scale-105",
                          vueExports.unref(selectedAvatar) === avatar.id ? "border-blue-500 bg-blue-50" : "border-gray-200 hover:border-gray-300"
                        ]
                      }, [
                        vueExports.createVNode("div", { class: "text-4xl" }, vueExports.toDisplayString(avatar.emoji), 1),
                        vueExports.createVNode("p", { class: "text-xs text-gray-600 mt-1" }, vueExports.toDisplayString(avatar.name), 1)
                      ], 10, ["onClick"]);
                    }), 64))
                  ])
                ]),
                vueExports.createVNode("div", { class: "flex justify-end gap-3 pt-4 border-t" }, [
                  vueExports.createVNode(_component_UiButton, {
                    variant: "ghost",
                    onClick: ($event) => _ctx.$emit("close")
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(" Cancelar ")
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  vueExports.createVNode(_component_UiButton, {
                    onClick: saveAvatar,
                    disabled: vueExports.unref(saving)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(saving) ? "Salvando..." : "Salvar Avatar"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _sfc_setup$1$6 = _sfc_main$1$6.setup;
_sfc_main$1$6.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiAvatarSelector.vue");
  return _sfc_setup$1$6 ? _sfc_setup$1$6(props, ctx) : void 0;
};
const __nuxt_component_12 = Object.assign(_sfc_main$1$6, { __name: "UiAvatarSelector" });
const _sfc_main$e = /* @__PURE__ */ vueExports.defineComponent({
  __name: "meus-dados",
  __ssrInlineRender: true,
  setup(__props) {
    const { user, isAdmin, updateUser } = useAuth();
    const editandoDadosPessoais = vueExports.ref(false);
    const editandoDadosProfissionais = vueExports.ref(false);
    const editandoPagamento = vueExports.ref(false);
    const salvando = vueExports.ref(false);
    const carregando = vueExports.ref(true);
    const mostrarNotificacao = vueExports.ref(false);
    const mostrarSeletorAvatar = vueExports.ref(false);
    const mostrarSalario = vueExports.ref(false);
    const notificacao = vueExports.ref({
      title: "",
      message: "",
      variant: "success"
    });
    const dadosOriginais = vueExports.ref(null);
    const dadosPessoais = vueExports.ref({
      nome: "",
      cpf: "",
      rg: "",
      dataNascimento: "",
      sexo: "",
      telefone: "",
      email_pessoal: "",
      pis_pasep: ""
    });
    const dadosProfissionais = vueExports.ref({
      cargo: "",
      departamento: "",
      dataAdmissao: "",
      tipoContrato: "",
      empresa: ""
    });
    const dadosFinanceiros = vueExports.ref({
      salario_base: "",
      banco: "",
      agencia: "",
      conta: "",
      tipo_conta: "",
      forma_pagamento: "deposito",
      chave_pix: ""
    });
    const camposEditadosUmaVez = vueExports.ref({
      sexo: false,
      dataNascimento: false,
      rg: false,
      cpf: false
    });
    const bancosOptions = [
      { value: "001", label: "Banco do Brasil" },
      { value: "104", label: "Caixa Econmica" },
      { value: "237", label: "Bradesco" },
      { value: "341", label: "Ita" },
      { value: "033", label: "Santander" },
      { value: "260", label: "Nubank" }
    ];
    const tipoContaOptions = [
      { value: "corrente", label: "Conta Corrente" },
      { value: "poupanca", label: "Conta Poupana" }
    ];
    const sexoOptions = [
      { value: "masculino", label: "Masculino" },
      { value: "feminino", label: "Feminino" },
      { value: "outro", label: "Outro" },
      { value: "nao_informar", label: "Prefiro no informar" }
    ];
    const formaPagamentoOptions = [
      { value: "deposito", label: "Depsito em Conta" },
      { value: "pix", label: "PIX" },
      { value: "dinheiro", label: "Dinheiro" }
    ];
    const tipoContratoOptions = [
      { value: "CLT", label: "CLT" },
      { value: "PJ", label: "PJ" },
      { value: "Estagio", label: "Estgio" },
      { value: "Temporario", label: "Temporrio" }
    ];
    const cargosOptions = vueExports.ref([]);
    const departamentosOptions = vueExports.ref([]);
    const empresasOptions = vueExports.ref([]);
    const cargosMap = vueExports.ref({});
    const departamentosMap = vueExports.ref({});
    const empresasMap = vueExports.ref({});
    const formatarData = (data) => {
      if (!data) return "--";
      const date = new Date(data);
      return date.toLocaleDateString("pt-BR");
    };
    const formatarDataContratacao = () => {
      if (!dadosProfissionais.value.dataAdmissao) return "Desde --/--";
      try {
        const data = /* @__PURE__ */ new Date(dadosProfissionais.value.dataAdmissao + "T00:00:00");
        if (isNaN(data.getTime())) {
          return "Desde --/--";
        }
        const meses = [
          "Jan",
          "Fev",
          "Mar",
          "Abr",
          "Mai",
          "Jun",
          "Jul",
          "Ago",
          "Set",
          "Out",
          "Nov",
          "Dez"
        ];
        const mes = meses[data.getMonth()];
        const ano = data.getFullYear();
        return `Desde ${mes}/${ano}`;
      } catch (error) {
        console.error("Erro ao formatar data de contratao:", error);
        return "Desde --/--";
      }
    };
    const formatarMoeda = (valor) => {
      const num = typeof valor === "string" ? parseFloat(valor) : valor;
      if (!num) return "R$ 0,00";
      return new Intl.NumberFormat("pt-BR", {
        style: "currency",
        currency: "BRL"
      }).format(num);
    };
    const obterNomeCargo = (id) => {
      const idStr = id?.toString();
      return cargosMap.value[idStr] || idStr || "--";
    };
    const obterNomeDepartamento = (id) => {
      const idStr = id?.toString();
      return departamentosMap.value[idStr] || idStr || "--";
    };
    const obterNomeEmpresa = (id) => {
      const idStr = id?.toString();
      return empresasMap.value[idStr] || idStr || "--";
    };
    const beneficiosAtivos = vueExports.computed(() => {
      if (!dadosOriginais.value?.beneficios) return {};
      let beneficios = {};
      try {
        beneficios = typeof dadosOriginais.value.beneficios === "string" ? JSON.parse(dadosOriginais.value.beneficios) : dadosOriginais.value.beneficios;
      } catch (error) {
        console.error("Erro ao parsear benefcios:", error);
        return {};
      }
      const ativos = {};
      if (beneficios.vale_transporte?.ativo && beneficios.vale_transporte?.valor > 0) {
        ativos.vale_transporte = beneficios.vale_transporte;
      }
      if (beneficios.cesta_basica?.ativo && beneficios.cesta_basica?.valor > 0) {
        ativos.cesta_basica = beneficios.cesta_basica;
      }
      if (beneficios.plano_saude?.ativo && beneficios.plano_saude?.valor_funcionario > 0) {
        ativos.plano_saude = beneficios.plano_saude;
      }
      if (beneficios.plano_odonto?.ativo && beneficios.plano_odonto?.valor_funcionario > 0) {
        ativos.plano_odonto = beneficios.plano_odonto;
      }
      return ativos;
    });
    const beneficiosPersonalizadosAtivos = vueExports.computed(() => {
      if (!dadosOriginais.value?.beneficios) return [];
      let beneficios = {};
      try {
        beneficios = typeof dadosOriginais.value.beneficios === "string" ? JSON.parse(dadosOriginais.value.beneficios) : dadosOriginais.value.beneficios;
      } catch (error) {
        console.error("Erro ao parsear benefcios:", error);
        return [];
      }
      if (!beneficios.personalizados || !Array.isArray(beneficios.personalizados)) {
        return [];
      }
      return beneficios.personalizados.filter((b) => b.ativo && b.valor > 0);
    });
    const temBeneficios = vueExports.computed(() => {
      return Object.keys(beneficiosAtivos.value).length > 0 || beneficiosPersonalizadosAtivos.value.length > 0;
    });
    const carregarDados = async () => {
      if (!user.value?.id) {
        mostrarMensagem("Erro!", "Usurio no autenticado", "error");
        return;
      }
      carregando.value = true;
      try {
        const response = await $fetch(`/api/funcionarios/meus-dados?userId=${user.value.id}`);
        if (response.success && response.data) {
          dadosOriginais.value = response.data;
          dadosPessoais.value = {
            nome: response.data.nome_completo || "",
            cpf: response.data.cpf || "",
            rg: response.data.rg || "",
            dataNascimento: response.data.data_nascimento || "",
            sexo: response.data.sexo || "",
            telefone: response.data.telefone || "",
            email_pessoal: response.data.email_pessoal || "",
            pis_pasep: response.data.pis_pasep || ""
          };
          dadosProfissionais.value = {
            cargo: response.data.cargo_id?.toString() || "",
            departamento: response.data.departamento_id?.toString() || "",
            dataAdmissao: response.data.data_admissao || "",
            tipoContrato: response.data.tipo_contrato || "CLT",
            empresa: response.data.empresa_id?.toString() || ""
          };
          dadosFinanceiros.value = {
            salario_base: response.data.salario_base || 0,
            banco: response.data.banco || "",
            agencia: response.data.agencia || "",
            conta: response.data.conta || "",
            tipo_conta: response.data.tipo_conta || "corrente",
            forma_pagamento: response.data.forma_pagamento || "deposito",
            chave_pix: response.data.chave_pix || ""
          };
          camposEditadosUmaVez.value = {
            sexo: !!response.data.sexo,
            dataNascimento: !!response.data.data_nascimento,
            rg: !!response.data.rg,
            cpf: !!response.data.cpf
          };
        }
      } catch (error) {
        console.error("Erro ao carregar dados:", error);
        mostrarMensagem("Erro!", "No foi possvel carregar seus dados", "error");
      } finally {
        carregando.value = false;
      }
    };
    const salvarDadosPessoais = async () => {
      if (!user.value?.id) {
        mostrarMensagem("Erro!", "Usurio no autenticado", "error");
        return;
      }
      salvando.value = true;
      try {
        const dadosParaEnviar = {
          userId: user.value.id,
          telefone: dadosPessoais.value.telefone,
          email_pessoal: dadosPessoais.value.email_pessoal,
          pis_pasep: dadosPessoais.value.pis_pasep
        };
        if (!camposEditadosUmaVez.value.dataNascimento || isAdmin.value) {
          dadosParaEnviar.data_nascimento = dadosPessoais.value.dataNascimento;
        }
        if (!camposEditadosUmaVez.value.sexo || isAdmin.value) {
          dadosParaEnviar.sexo = dadosPessoais.value.sexo;
        }
        if (!camposEditadosUmaVez.value.rg || isAdmin.value) {
          dadosParaEnviar.rg = dadosPessoais.value.rg;
        }
        if (isAdmin.value) {
          dadosParaEnviar.nome_completo = dadosPessoais.value.nome;
          dadosParaEnviar.cpf = dadosPessoais.value.cpf;
        } else if (!camposEditadosUmaVez.value.cpf) {
          dadosParaEnviar.cpf = dadosPessoais.value.cpf;
        }
        const response = await $fetch("/api/funcionarios/meus-dados", {
          method: "PATCH",
          body: dadosParaEnviar
        });
        if (response.success) {
          if (response.data) {
            dadosPessoais.value.telefone = response.data.telefone || dadosPessoais.value.telefone;
            dadosPessoais.value.email_pessoal = response.data.email_pessoal || dadosPessoais.value.email_pessoal;
            dadosPessoais.value.dataNascimento = response.data.data_nascimento || dadosPessoais.value.dataNascimento;
            if (isAdmin.value && response.data.nome_completo) {
              dadosPessoais.value.nome = response.data.nome_completo;
              updateUser({ nome: response.data.nome_completo });
            }
            if (isAdmin.value && response.data.cpf) {
              dadosPessoais.value.cpf = response.data.cpf;
            }
            if (dadosOriginais.value) {
              dadosOriginais.value.telefone = response.data.telefone || dadosOriginais.value.telefone;
              dadosOriginais.value.email_pessoal = response.data.email_pessoal || dadosOriginais.value.email_pessoal;
              dadosOriginais.value.data_nascimento = response.data.data_nascimento || dadosOriginais.value.data_nascimento;
              if (isAdmin.value && response.data.nome_completo) {
                dadosOriginais.value.nome_completo = response.data.nome_completo;
              }
              if (isAdmin.value && response.data.cpf) {
                dadosOriginais.value.cpf = response.data.cpf;
              }
            }
          }
          mostrarMensagem("Sucesso!", "Dados pessoais atualizados com sucesso!", "success");
          editandoDadosPessoais.value = false;
        }
      } catch (error) {
        console.error("Erro ao salvar dados pessoais:", error);
        mostrarMensagem("Erro!", error.data?.message || "No foi possvel salvar os dados", "error");
      } finally {
        salvando.value = false;
      }
    };
    const salvarDadosProfissionais = async () => {
      if (!user.value?.id) {
        mostrarMensagem("Erro!", "Usurio no autenticado", "error");
        return;
      }
      if (!isAdmin.value) {
        mostrarMensagem("Erro!", "Apenas administradores podem editar dados profissionais", "error");
        return;
      }
      salvando.value = true;
      try {
        const response = await $fetch("/api/funcionarios/meus-dados", {
          method: "PATCH",
          body: {
            userId: user.value.id,
            cargo_id: dadosProfissionais.value.cargo,
            departamento_id: dadosProfissionais.value.departamento,
            data_admissao: dadosProfissionais.value.dataAdmissao,
            tipo_contrato: dadosProfissionais.value.tipoContrato,
            empresa_id: dadosProfissionais.value.empresa
          }
        });
        if (response.success) {
          mostrarMensagem("Sucesso!", "Dados profissionais atualizados com sucesso!", "success");
          editandoDadosProfissionais.value = false;
          await carregarDados();
        }
      } catch (error) {
        console.error("Erro ao salvar dados profissionais:", error);
        mostrarMensagem("Erro!", error.data?.message || "No foi possvel salvar os dados", "error");
      } finally {
        salvando.value = false;
      }
    };
    const salvarDadosFinanceiros = async () => {
      if (!user.value?.id) {
        mostrarMensagem("Erro!", "Usurio no autenticado", "error");
        return;
      }
      salvando.value = true;
      try {
        const response = await $fetch("/api/funcionarios/meus-dados", {
          method: "PATCH",
          body: {
            userId: user.value.id,
            banco: dadosFinanceiros.value.banco,
            agencia: dadosFinanceiros.value.agencia,
            conta: dadosFinanceiros.value.conta,
            tipo_conta: dadosFinanceiros.value.tipo_conta,
            forma_pagamento: dadosFinanceiros.value.forma_pagamento,
            chave_pix: dadosFinanceiros.value.chave_pix
          }
        });
        if (response.success) {
          mostrarMensagem("Sucesso!", "Dados financeiros atualizados com sucesso!", "success");
          editandoPagamento.value = false;
          await carregarDados();
        }
      } catch (error) {
        console.error("Erro ao salvar dados financeiros:", error);
        mostrarMensagem("Erro!", error.data?.message || "No foi possvel salvar os dados", "error");
      } finally {
        salvando.value = false;
      }
    };
    const mostrarMensagem = (title, message, variant) => {
      notificacao.value = { title, message, variant };
      mostrarNotificacao.value = true;
      setTimeout(() => {
        mostrarNotificacao.value = false;
      }, 5e3);
    };
    const salvarAvatar = async (avatarId) => {
      if (!user.value?.id) {
        mostrarMensagem("Erro!", "Usurio no autenticado", "error");
        return;
      }
      try {
        const response = await $fetch("/api/funcionarios/meus-dados", {
          method: "PATCH",
          body: {
            userId: user.value.id,
            avatar: avatarId
          }
        });
        if (response.success) {
          if (dadosOriginais.value) {
            dadosOriginais.value.avatar = avatarId;
          }
          mostrarMensagem("Sucesso!", "Avatar atualizado com sucesso!", "success");
          mostrarSeletorAvatar.value = false;
        }
      } catch (error) {
        console.error("Erro ao salvar avatar:", error);
        mostrarMensagem("Erro!", error.data?.message || "No foi possvel salvar o avatar", "error");
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiPageHeader = __nuxt_component_0$3;
      const _component_UiCard = __nuxt_component_2$1;
      const _component_UiAvatar = __nuxt_component_1$3;
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiBadge = __nuxt_component_2$2;
      const _component_UiInput = __nuxt_component_4;
      const _component_UiInputCPF = __nuxt_component_6;
      const _component_UiSelect = __nuxt_component_6$1;
      const _component_UiInputPhone = __nuxt_component_8;
      const _component_UiInputPIS = __nuxt_component_1$2;
      const _component_UiAlert = __nuxt_component_1$1;
      const _component_UiNotification = __nuxt_component_7;
      const _component_UiAvatarSelector = __nuxt_component_12;
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      _push(ssrRenderComponent_1(_component_UiPageHeader, {
        title: "Meus Dados",
        description: "Visualize e atualize suas informaes pessoais"
      }, null, _parent));
      if (vueExports.unref(carregando)) {
        _push(`<div class="flex items-center justify-center py-12"><div class="text-center"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div><p class="text-gray-600">Carregando seus dados...</p></div></div>`);
      } else {
        _push(`<div>`);
        _push(ssrRenderComponent_1(_component_UiCard, { class: "mb-6" }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="flex flex-col md:flex-row items-start gap-6"${_scopeId}><div class="flex flex-col items-center"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiAvatar, {
                name: vueExports.unref(user)?.nome || "",
                "avatar-type": vueExports.unref(dadosOriginais)?.avatar,
                size: "xl"
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                class: "mt-4",
                onClick: ($event) => mostrarSeletorAvatar.value = true
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Alterar Foto `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Alterar Foto ")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(`</div><div class="flex-1 w-full"${_scopeId}><h2 class="text-2xl font-bold text-gray-800 mb-1"${_scopeId}>${ssrInterpolate_1(vueExports.unref(dadosOriginais)?.nome_completo || vueExports.unref(user)?.nome)}</h2><p class="text-lg text-gray-500 mb-4"${_scopeId}>`);
              if (vueExports.unref(dadosOriginais) && Object.keys(vueExports.unref(cargosMap)).length > 0) {
                _push2(`<!--[-->${ssrInterpolate_1(obterNomeCargo(vueExports.unref(dadosOriginais).cargo_id))} - ${ssrInterpolate_1(obterNomeDepartamento(vueExports.unref(dadosOriginais).departamento_id))}<!--]-->`);
              } else {
                _push2(`<!--[--> Carregando... <!--]-->`);
              }
              _push2(`</p><div class="flex flex-wrap gap-3"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiBadge, { variant: "success" }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(` Funcionrio Ativo`);
                  } else {
                    return [
                      vueExports.createTextVNode(" Funcionrio Ativo")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiBadge, { variant: "info" }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(` ${ssrInterpolate_1(formatarDataContratacao())}`);
                  } else {
                    return [
                      vueExports.createTextVNode(" " + vueExports.toDisplayString(formatarDataContratacao()), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(`</div></div></div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "flex flex-col md:flex-row items-start gap-6" }, [
                  vueExports.createVNode("div", { class: "flex flex-col items-center" }, [
                    vueExports.createVNode(_component_UiAvatar, {
                      name: vueExports.unref(user)?.nome || "",
                      "avatar-type": vueExports.unref(dadosOriginais)?.avatar,
                      size: "xl"
                    }, null, 8, ["name", "avatar-type"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      class: "mt-4",
                      onClick: ($event) => mostrarSeletorAvatar.value = true
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Alterar Foto ")
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  vueExports.createVNode("div", { class: "flex-1 w-full" }, [
                    vueExports.createVNode("h2", { class: "text-2xl font-bold text-gray-800 mb-1" }, vueExports.toDisplayString(vueExports.unref(dadosOriginais)?.nome_completo || vueExports.unref(user)?.nome), 1),
                    vueExports.createVNode("p", { class: "text-lg text-gray-500 mb-4" }, [
                      vueExports.unref(dadosOriginais) && Object.keys(vueExports.unref(cargosMap)).length > 0 ? (vueExports.openBlock(), vueExports.createBlock(vueExports.Fragment, { key: 0 }, [
                        vueExports.createTextVNode(vueExports.toDisplayString(obterNomeCargo(vueExports.unref(dadosOriginais).cargo_id)) + " - " + vueExports.toDisplayString(obterNomeDepartamento(vueExports.unref(dadosOriginais).departamento_id)), 1)
                      ], 64)) : (vueExports.openBlock(), vueExports.createBlock(vueExports.Fragment, { key: 1 }, [
                        vueExports.createTextVNode(" Carregando... ")
                      ], 64))
                    ]),
                    vueExports.createVNode("div", { class: "flex flex-wrap gap-3" }, [
                      vueExports.createVNode(_component_UiBadge, { variant: "success" }, {
                        default: vueExports.withCtx(() => [
                          vueExports.createTextVNode(" Funcionrio Ativo")
                        ]),
                        _: 1
                      }),
                      vueExports.createVNode(_component_UiBadge, { variant: "info" }, {
                        default: vueExports.withCtx(() => [
                          vueExports.createTextVNode(" " + vueExports.toDisplayString(formatarDataContratacao()), 1)
                        ]),
                        _: 1
                      })
                    ])
                  ])
                ])
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_UiCard, {
          title: " Dados Pessoais",
          class: "mb-6"
        }, {
          header: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => editandoDadosPessoais.value = !vueExports.unref(editandoDadosPessoais)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(vueExports.unref(editandoDadosPessoais) ? " Cancelar" : " Editar")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(editandoDadosPessoais) ? " Cancelar" : " Editar"), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
            } else {
              return [
                vueExports.createVNode(_component_UiButton, {
                  variant: "ghost",
                  onClick: ($event) => editandoDadosPessoais.value = !vueExports.unref(editandoDadosPessoais)
                }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(editandoDadosPessoais) ? " Cancelar" : " Editar"), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ];
            }
          }),
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="grid grid-cols-1 md:grid-cols-2 gap-6"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiInput, {
                modelValue: vueExports.unref(dadosPessoais).nome,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).nome = $event,
                label: "Nome Completo",
                disabled: !vueExports.unref(editandoDadosPessoais) || !vueExports.unref(isAdmin),
                hint: !vueExports.unref(isAdmin) ? "Apenas administradores podem alterar o nome" : ""
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInputCPF, {
                modelValue: vueExports.unref(dadosPessoais).cpf,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).cpf = $event,
                label: "CPF",
                disabled: !vueExports.unref(editandoDadosPessoais) || !vueExports.unref(isAdmin) || vueExports.unref(camposEditadosUmaVez).cpf && !vueExports.unref(isAdmin),
                hint: !vueExports.unref(isAdmin) && vueExports.unref(camposEditadosUmaVez).cpf ? "CPF j foi editado uma vez" : !vueExports.unref(isAdmin) ? "Apenas administradores podem alterar o CPF" : ""
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInput, {
                modelValue: vueExports.unref(dadosPessoais).rg,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).rg = $event,
                label: "RG",
                disabled: !vueExports.unref(editandoDadosPessoais) || vueExports.unref(camposEditadosUmaVez).rg && !vueExports.unref(isAdmin),
                hint: vueExports.unref(camposEditadosUmaVez).rg && !vueExports.unref(isAdmin) ? "RG j foi editado uma vez" : ""
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInput, {
                modelValue: vueExports.unref(dadosPessoais).dataNascimento,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).dataNascimento = $event,
                type: "date",
                label: "Data de Nascimento",
                disabled: !vueExports.unref(editandoDadosPessoais) || vueExports.unref(camposEditadosUmaVez).dataNascimento && !vueExports.unref(isAdmin),
                hint: vueExports.unref(camposEditadosUmaVez).dataNascimento && !vueExports.unref(isAdmin) ? "Data de nascimento j foi editada uma vez" : ""
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiSelect, {
                modelValue: vueExports.unref(dadosPessoais).sexo,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).sexo = $event,
                options: sexoOptions,
                label: "Sexo",
                disabled: !vueExports.unref(editandoDadosPessoais) || vueExports.unref(camposEditadosUmaVez).sexo && !vueExports.unref(isAdmin),
                hint: vueExports.unref(camposEditadosUmaVez).sexo && !vueExports.unref(isAdmin) ? "Sexo j foi editado uma vez" : ""
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInputPhone, {
                modelValue: vueExports.unref(dadosPessoais).telefone,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).telefone = $event,
                label: "Telefone",
                disabled: !vueExports.unref(editandoDadosPessoais)
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInput, {
                modelValue: vueExports.unref(dadosPessoais).email_pessoal,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).email_pessoal = $event,
                type: "email",
                label: "Email Pessoal",
                disabled: !vueExports.unref(editandoDadosPessoais)
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInputPIS, {
                modelValue: vueExports.unref(dadosPessoais).pis_pasep,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).pis_pasep = $event,
                label: "PIS/PASEP",
                disabled: !vueExports.unref(editandoDadosPessoais)
              }, null, _parent2, _scopeId));
              _push2(`</div>`);
              if (vueExports.unref(editandoDadosPessoais)) {
                _push2(`<div class="mt-6 flex justify-end"${_scopeId}>`);
                _push2(ssrRenderComponent_1(_component_UiButton, {
                  icon: "",
                  onClick: salvarDadosPessoais,
                  disabled: vueExports.unref(salvando)
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`${ssrInterpolate_1(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes")}`);
                    } else {
                      return [
                        vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes"), 1)
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
                _push2(`</div>`);
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                vueExports.createVNode("div", { class: "grid grid-cols-1 md:grid-cols-2 gap-6" }, [
                  vueExports.createVNode(_component_UiInput, {
                    modelValue: vueExports.unref(dadosPessoais).nome,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).nome = $event,
                    label: "Nome Completo",
                    disabled: !vueExports.unref(editandoDadosPessoais) || !vueExports.unref(isAdmin),
                    hint: !vueExports.unref(isAdmin) ? "Apenas administradores podem alterar o nome" : ""
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled", "hint"]),
                  vueExports.createVNode(_component_UiInputCPF, {
                    modelValue: vueExports.unref(dadosPessoais).cpf,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).cpf = $event,
                    label: "CPF",
                    disabled: !vueExports.unref(editandoDadosPessoais) || !vueExports.unref(isAdmin) || vueExports.unref(camposEditadosUmaVez).cpf && !vueExports.unref(isAdmin),
                    hint: !vueExports.unref(isAdmin) && vueExports.unref(camposEditadosUmaVez).cpf ? "CPF j foi editado uma vez" : !vueExports.unref(isAdmin) ? "Apenas administradores podem alterar o CPF" : ""
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled", "hint"]),
                  vueExports.createVNode(_component_UiInput, {
                    modelValue: vueExports.unref(dadosPessoais).rg,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).rg = $event,
                    label: "RG",
                    disabled: !vueExports.unref(editandoDadosPessoais) || vueExports.unref(camposEditadosUmaVez).rg && !vueExports.unref(isAdmin),
                    hint: vueExports.unref(camposEditadosUmaVez).rg && !vueExports.unref(isAdmin) ? "RG j foi editado uma vez" : ""
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled", "hint"]),
                  vueExports.createVNode(_component_UiInput, {
                    modelValue: vueExports.unref(dadosPessoais).dataNascimento,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).dataNascimento = $event,
                    type: "date",
                    label: "Data de Nascimento",
                    disabled: !vueExports.unref(editandoDadosPessoais) || vueExports.unref(camposEditadosUmaVez).dataNascimento && !vueExports.unref(isAdmin),
                    hint: vueExports.unref(camposEditadosUmaVez).dataNascimento && !vueExports.unref(isAdmin) ? "Data de nascimento j foi editada uma vez" : ""
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled", "hint"]),
                  vueExports.createVNode(_component_UiSelect, {
                    modelValue: vueExports.unref(dadosPessoais).sexo,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).sexo = $event,
                    options: sexoOptions,
                    label: "Sexo",
                    disabled: !vueExports.unref(editandoDadosPessoais) || vueExports.unref(camposEditadosUmaVez).sexo && !vueExports.unref(isAdmin),
                    hint: vueExports.unref(camposEditadosUmaVez).sexo && !vueExports.unref(isAdmin) ? "Sexo j foi editado uma vez" : ""
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled", "hint"]),
                  vueExports.createVNode(_component_UiInputPhone, {
                    modelValue: vueExports.unref(dadosPessoais).telefone,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).telefone = $event,
                    label: "Telefone",
                    disabled: !vueExports.unref(editandoDadosPessoais)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
                  vueExports.createVNode(_component_UiInput, {
                    modelValue: vueExports.unref(dadosPessoais).email_pessoal,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).email_pessoal = $event,
                    type: "email",
                    label: "Email Pessoal",
                    disabled: !vueExports.unref(editandoDadosPessoais)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
                  vueExports.createVNode(_component_UiInputPIS, {
                    modelValue: vueExports.unref(dadosPessoais).pis_pasep,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosPessoais).pis_pasep = $event,
                    label: "PIS/PASEP",
                    disabled: !vueExports.unref(editandoDadosPessoais)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"])
                ]),
                vueExports.unref(editandoDadosPessoais) ? (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 0,
                  class: "mt-6 flex justify-end"
                }, [
                  vueExports.createVNode(_component_UiButton, {
                    icon: "",
                    onClick: salvarDadosPessoais,
                    disabled: vueExports.unref(salvando)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])) : vueExports.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_UiCard, {
          title: " Dados Profissionais",
          class: "mb-6"
        }, {
          header: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="flex items-center gap-2"${_scopeId}>`);
              if (!vueExports.unref(isAdmin)) {
                _push2(`<span class="text-sm text-gray-500"${_scopeId}>(somente visualizao)</span>`);
              } else {
                _push2(`<!---->`);
              }
              if (vueExports.unref(isAdmin)) {
                _push2(ssrRenderComponent_1(_component_UiButton, {
                  variant: "ghost",
                  onClick: ($event) => editandoDadosProfissionais.value = !vueExports.unref(editandoDadosProfissionais)
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`${ssrInterpolate_1(vueExports.unref(editandoDadosProfissionais) ? " Cancelar" : " Editar")}`);
                    } else {
                      return [
                        vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(editandoDadosProfissionais) ? " Cancelar" : " Editar"), 1)
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "flex items-center gap-2" }, [
                  !vueExports.unref(isAdmin) ? (vueExports.openBlock(), vueExports.createBlock("span", {
                    key: 0,
                    class: "text-sm text-gray-500"
                  }, "(somente visualizao)")) : vueExports.createCommentVNode("", true),
                  vueExports.unref(isAdmin) ? (vueExports.openBlock(), vueExports.createBlock(_component_UiButton, {
                    key: 1,
                    variant: "ghost",
                    onClick: ($event) => editandoDadosProfissionais.value = !vueExports.unref(editandoDadosProfissionais)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(editandoDadosProfissionais) ? " Cancelar" : " Editar"), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : vueExports.createCommentVNode("", true)
                ])
              ];
            }
          }),
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              if (!vueExports.unref(isAdmin)) {
                _push2(ssrRenderComponent_1(_component_UiAlert, {
                  variant: "warning",
                  class: "mb-6"
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(` Estes dados so gerenciados pelo RH e no podem ser alterados por voc. `);
                    } else {
                      return [
                        vueExports.createTextVNode(" Estes dados so gerenciados pelo RH e no podem ser alterados por voc. ")
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
              } else {
                _push2(ssrRenderComponent_1(_component_UiAlert, {
                  variant: "info",
                  class: "mb-6"
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(` Como administrador, voc pode editar seus prprios dados profissionais. `);
                    } else {
                      return [
                        vueExports.createTextVNode(" Como administrador, voc pode editar seus prprios dados profissionais. ")
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
              }
              _push2(`<div class="grid grid-cols-1 md:grid-cols-2 gap-6"${_scopeId}>`);
              if (!vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais)) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Cargo</label><p class="text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl"${_scopeId}>${ssrInterpolate_1(obterNomeCargo(vueExports.unref(dadosOriginais)?.cargo_id) || vueExports.unref(user)?.cargo || "--")}</p></div>`);
              } else {
                _push2(ssrRenderComponent_1(_component_UiSelect, {
                  modelValue: vueExports.unref(dadosProfissionais).cargo,
                  "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).cargo = $event,
                  options: vueExports.unref(cargosOptions),
                  label: "Cargo",
                  placeholder: "Selecione um cargo..."
                }, null, _parent2, _scopeId));
              }
              if (!vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais)) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Departamento</label><p class="text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl"${_scopeId}>${ssrInterpolate_1(obterNomeDepartamento(vueExports.unref(dadosOriginais)?.departamento_id) || vueExports.unref(user)?.departamento || "--")}</p></div>`);
              } else {
                _push2(ssrRenderComponent_1(_component_UiSelect, {
                  modelValue: vueExports.unref(dadosProfissionais).departamento,
                  "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).departamento = $event,
                  options: vueExports.unref(departamentosOptions),
                  label: "Departamento",
                  placeholder: "Selecione um departamento..."
                }, null, _parent2, _scopeId));
              }
              if (!vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais)) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Data de Admisso</label><p class="text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl"${_scopeId}>${ssrInterpolate_1(formatarData(vueExports.unref(dadosProfissionais).dataAdmissao))}</p></div>`);
              } else {
                _push2(ssrRenderComponent_1(_component_UiInput, {
                  modelValue: vueExports.unref(dadosProfissionais).dataAdmissao,
                  "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).dataAdmissao = $event,
                  type: "date",
                  label: "Data de Admisso"
                }, null, _parent2, _scopeId));
              }
              if (!vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais)) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Tipo de Contrato</label><p class="text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl"${_scopeId}>${ssrInterpolate_1(vueExports.unref(dadosProfissionais).tipoContrato)}</p></div>`);
              } else {
                _push2(ssrRenderComponent_1(_component_UiSelect, {
                  modelValue: vueExports.unref(dadosProfissionais).tipoContrato,
                  "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).tipoContrato = $event,
                  options: tipoContratoOptions,
                  label: "Tipo de Contrato"
                }, null, _parent2, _scopeId));
              }
              if (!vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais)) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Empresa</label><p class="text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl"${_scopeId}>${ssrInterpolate_1(obterNomeEmpresa(vueExports.unref(dadosOriginais)?.empresa_id) || "--")}</p></div>`);
              } else {
                _push2(ssrRenderComponent_1(_component_UiSelect, {
                  modelValue: vueExports.unref(dadosProfissionais).empresa,
                  "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).empresa = $event,
                  options: vueExports.unref(empresasOptions),
                  label: "Empresa",
                  placeholder: "Selecione uma empresa..."
                }, null, _parent2, _scopeId));
              }
              _push2(`</div>`);
              if (vueExports.unref(isAdmin) && vueExports.unref(editandoDadosProfissionais)) {
                _push2(`<div class="mt-6 flex justify-end"${_scopeId}>`);
                _push2(ssrRenderComponent_1(_component_UiButton, {
                  icon: "",
                  onClick: salvarDadosProfissionais,
                  disabled: vueExports.unref(salvando)
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`${ssrInterpolate_1(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes")}`);
                    } else {
                      return [
                        vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes"), 1)
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
                _push2(`</div>`);
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                !vueExports.unref(isAdmin) ? (vueExports.openBlock(), vueExports.createBlock(_component_UiAlert, {
                  key: 0,
                  variant: "warning",
                  class: "mb-6"
                }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(" Estes dados so gerenciados pelo RH e no podem ser alterados por voc. ")
                  ]),
                  _: 1
                })) : (vueExports.openBlock(), vueExports.createBlock(_component_UiAlert, {
                  key: 1,
                  variant: "info",
                  class: "mb-6"
                }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(" Como administrador, voc pode editar seus prprios dados profissionais. ")
                  ]),
                  _: 1
                })),
                vueExports.createVNode("div", { class: "grid grid-cols-1 md:grid-cols-2 gap-6" }, [
                  !vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais) ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 0 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Cargo"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl" }, vueExports.toDisplayString(obterNomeCargo(vueExports.unref(dadosOriginais)?.cargo_id) || vueExports.unref(user)?.cargo || "--"), 1)
                  ])) : (vueExports.openBlock(), vueExports.createBlock(_component_UiSelect, {
                    key: 1,
                    modelValue: vueExports.unref(dadosProfissionais).cargo,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).cargo = $event,
                    options: vueExports.unref(cargosOptions),
                    label: "Cargo",
                    placeholder: "Selecione um cargo..."
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "options"])),
                  !vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais) ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 2 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Departamento"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl" }, vueExports.toDisplayString(obterNomeDepartamento(vueExports.unref(dadosOriginais)?.departamento_id) || vueExports.unref(user)?.departamento || "--"), 1)
                  ])) : (vueExports.openBlock(), vueExports.createBlock(_component_UiSelect, {
                    key: 3,
                    modelValue: vueExports.unref(dadosProfissionais).departamento,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).departamento = $event,
                    options: vueExports.unref(departamentosOptions),
                    label: "Departamento",
                    placeholder: "Selecione um departamento..."
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "options"])),
                  !vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais) ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 4 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Data de Admisso"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl" }, vueExports.toDisplayString(formatarData(vueExports.unref(dadosProfissionais).dataAdmissao)), 1)
                  ])) : (vueExports.openBlock(), vueExports.createBlock(_component_UiInput, {
                    key: 5,
                    modelValue: vueExports.unref(dadosProfissionais).dataAdmissao,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).dataAdmissao = $event,
                    type: "date",
                    label: "Data de Admisso"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"])),
                  !vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais) ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 6 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Tipo de Contrato"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl" }, vueExports.toDisplayString(vueExports.unref(dadosProfissionais).tipoContrato), 1)
                  ])) : (vueExports.openBlock(), vueExports.createBlock(_component_UiSelect, {
                    key: 7,
                    modelValue: vueExports.unref(dadosProfissionais).tipoContrato,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).tipoContrato = $event,
                    options: tipoContratoOptions,
                    label: "Tipo de Contrato"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"])),
                  !vueExports.unref(isAdmin) || !vueExports.unref(editandoDadosProfissionais) ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 8 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Empresa"),
                    vueExports.createVNode("p", { class: "text-lg font-semibold text-gray-800 p-3 bg-gray-50 rounded-xl" }, vueExports.toDisplayString(obterNomeEmpresa(vueExports.unref(dadosOriginais)?.empresa_id) || "--"), 1)
                  ])) : (vueExports.openBlock(), vueExports.createBlock(_component_UiSelect, {
                    key: 9,
                    modelValue: vueExports.unref(dadosProfissionais).empresa,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosProfissionais).empresa = $event,
                    options: vueExports.unref(empresasOptions),
                    label: "Empresa",
                    placeholder: "Selecione uma empresa..."
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "options"]))
                ]),
                vueExports.unref(isAdmin) && vueExports.unref(editandoDadosProfissionais) ? (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 2,
                  class: "mt-6 flex justify-end"
                }, [
                  vueExports.createVNode(_component_UiButton, {
                    icon: "",
                    onClick: salvarDadosProfissionais,
                    disabled: vueExports.unref(salvando)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])) : vueExports.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_UiCard, {
          title: " Dados Financeiros",
          class: "mb-6"
        }, {
          header: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => editandoPagamento.value = !vueExports.unref(editandoPagamento)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(vueExports.unref(editandoPagamento) ? " Cancelar" : " Editar")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(editandoPagamento) ? " Cancelar" : " Editar"), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
            } else {
              return [
                vueExports.createVNode(_component_UiButton, {
                  variant: "ghost",
                  onClick: ($event) => editandoPagamento.value = !vueExports.unref(editandoPagamento)
                }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(editandoPagamento) ? " Cancelar" : " Editar"), 1)
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ];
            }
          }),
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="grid grid-cols-1 md:grid-cols-2 gap-6"${_scopeId}><div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Salrio Base (R$)</label><div class="p-3 bg-gray-50 rounded-xl border border-gray-200 cursor-pointer hover:bg-gray-100 transition-colors"${_scopeId}><div class="flex items-center justify-between"${_scopeId}><p class="text-lg font-bold text-green-700"${_scopeId}>${ssrInterpolate_1(vueExports.unref(mostrarSalario) ? formatarMoeda(vueExports.unref(dadosFinanceiros).salario_base) : "")}</p><svg class="${ssrRenderClass_1([{ "text-green-600": vueExports.unref(mostrarSalario) }, "w-5 h-5 text-gray-400"])}" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}>`);
              if (!vueExports.unref(mostrarSalario)) {
                _push2(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"${_scopeId}></path>`);
              } else {
                _push2(`<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21"${_scopeId}></path>`);
              }
              _push2(`</svg></div><p class="text-xs text-gray-500 mt-1 flex items-center gap-1"${_scopeId}><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"${_scopeId}></path></svg> ${ssrInterpolate_1(vueExports.unref(mostrarSalario) ? "Clique para ocultar" : "Clique para revelar")}  Campo bloqueado para edio </p></div></div>`);
              _push2(ssrRenderComponent_1(_component_UiSelect, {
                modelValue: vueExports.unref(dadosFinanceiros).forma_pagamento,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).forma_pagamento = $event,
                options: formaPagamentoOptions,
                label: "Forma de Pagamento",
                disabled: !vueExports.unref(editandoPagamento)
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiSelect, {
                modelValue: vueExports.unref(dadosFinanceiros).banco,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).banco = $event,
                options: bancosOptions,
                label: "Banco",
                disabled: !vueExports.unref(editandoPagamento)
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiSelect, {
                modelValue: vueExports.unref(dadosFinanceiros).tipo_conta,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).tipo_conta = $event,
                options: tipoContaOptions,
                label: "Tipo de Conta",
                disabled: !vueExports.unref(editandoPagamento)
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInput, {
                modelValue: vueExports.unref(dadosFinanceiros).agencia,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).agencia = $event,
                label: "Agncia",
                disabled: !vueExports.unref(editandoPagamento)
              }, null, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiInput, {
                modelValue: vueExports.unref(dadosFinanceiros).conta,
                "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).conta = $event,
                label: "Conta",
                disabled: !vueExports.unref(editandoPagamento)
              }, null, _parent2, _scopeId));
              if (vueExports.unref(dadosFinanceiros).forma_pagamento === "pix") {
                _push2(ssrRenderComponent_1(_component_UiInput, {
                  modelValue: vueExports.unref(dadosFinanceiros).chave_pix,
                  "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).chave_pix = $event,
                  label: "Chave PIX",
                  placeholder: "Digite sua chave PIX (CPF, email, telefone ou chave aleatria)",
                  disabled: !vueExports.unref(editandoPagamento)
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div>`);
              if (vueExports.unref(editandoPagamento)) {
                _push2(`<div class="mt-6 flex justify-end"${_scopeId}>`);
                _push2(ssrRenderComponent_1(_component_UiButton, {
                  icon: "",
                  onClick: salvarDadosFinanceiros,
                  disabled: vueExports.unref(salvando)
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`${ssrInterpolate_1(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes")}`);
                    } else {
                      return [
                        vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes"), 1)
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
                _push2(`</div>`);
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                vueExports.createVNode("div", { class: "grid grid-cols-1 md:grid-cols-2 gap-6" }, [
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Salrio Base (R$)"),
                    vueExports.createVNode("div", {
                      class: "p-3 bg-gray-50 rounded-xl border border-gray-200 cursor-pointer hover:bg-gray-100 transition-colors",
                      onClick: ($event) => mostrarSalario.value = !vueExports.unref(mostrarSalario)
                    }, [
                      vueExports.createVNode("div", { class: "flex items-center justify-between" }, [
                        vueExports.createVNode("p", { class: "text-lg font-bold text-green-700" }, vueExports.toDisplayString(vueExports.unref(mostrarSalario) ? formatarMoeda(vueExports.unref(dadosFinanceiros).salario_base) : ""), 1),
                        (vueExports.openBlock(), vueExports.createBlock("svg", {
                          class: ["w-5 h-5 text-gray-400", { "text-green-600": vueExports.unref(mostrarSalario) }],
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          !vueExports.unref(mostrarSalario) ? (vueExports.openBlock(), vueExports.createBlock("path", {
                            key: 0,
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                          })) : (vueExports.openBlock(), vueExports.createBlock("path", {
                            key: 1,
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21"
                          }))
                        ], 2))
                      ]),
                      vueExports.createVNode("p", { class: "text-xs text-gray-500 mt-1 flex items-center gap-1" }, [
                        (vueExports.openBlock(), vueExports.createBlock("svg", {
                          class: "w-3 h-3",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          vueExports.createVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
                          })
                        ])),
                        vueExports.createTextVNode(" " + vueExports.toDisplayString(vueExports.unref(mostrarSalario) ? "Clique para ocultar" : "Clique para revelar") + "  Campo bloqueado para edio ", 1)
                      ])
                    ], 8, ["onClick"])
                  ]),
                  vueExports.createVNode(_component_UiSelect, {
                    modelValue: vueExports.unref(dadosFinanceiros).forma_pagamento,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).forma_pagamento = $event,
                    options: formaPagamentoOptions,
                    label: "Forma de Pagamento",
                    disabled: !vueExports.unref(editandoPagamento)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
                  vueExports.createVNode(_component_UiSelect, {
                    modelValue: vueExports.unref(dadosFinanceiros).banco,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).banco = $event,
                    options: bancosOptions,
                    label: "Banco",
                    disabled: !vueExports.unref(editandoPagamento)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
                  vueExports.createVNode(_component_UiSelect, {
                    modelValue: vueExports.unref(dadosFinanceiros).tipo_conta,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).tipo_conta = $event,
                    options: tipoContaOptions,
                    label: "Tipo de Conta",
                    disabled: !vueExports.unref(editandoPagamento)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
                  vueExports.createVNode(_component_UiInput, {
                    modelValue: vueExports.unref(dadosFinanceiros).agencia,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).agencia = $event,
                    label: "Agncia",
                    disabled: !vueExports.unref(editandoPagamento)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
                  vueExports.createVNode(_component_UiInput, {
                    modelValue: vueExports.unref(dadosFinanceiros).conta,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).conta = $event,
                    label: "Conta",
                    disabled: !vueExports.unref(editandoPagamento)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
                  vueExports.unref(dadosFinanceiros).forma_pagamento === "pix" ? (vueExports.openBlock(), vueExports.createBlock(_component_UiInput, {
                    key: 0,
                    modelValue: vueExports.unref(dadosFinanceiros).chave_pix,
                    "onUpdate:modelValue": ($event) => vueExports.unref(dadosFinanceiros).chave_pix = $event,
                    label: "Chave PIX",
                    placeholder: "Digite sua chave PIX (CPF, email, telefone ou chave aleatria)",
                    disabled: !vueExports.unref(editandoPagamento)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"])) : vueExports.createCommentVNode("", true)
                ]),
                vueExports.unref(editandoPagamento) ? (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 0,
                  class: "mt-6 flex justify-end"
                }, [
                  vueExports.createVNode(_component_UiButton, {
                    icon: "",
                    onClick: salvarDadosFinanceiros,
                    disabled: vueExports.unref(salvando)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar Alteraes"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])) : vueExports.createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_UiCard, {
          title: " Benefcios",
          class: "mb-6"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(ssrRenderComponent_1(_component_UiAlert, {
                variant: "info",
                class: "mb-6"
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(` Estes benefcios so gerenciados pelo RH e no podem ser alterados por voc. `);
                  } else {
                    return [
                      vueExports.createTextVNode(" Estes benefcios so gerenciados pelo RH e no podem ser alterados por voc. ")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(`<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"${_scopeId}>`);
              if (vueExports.unref(beneficiosAtivos).vale_transporte) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Vale Transporte</label><div class="p-3 bg-green-50 rounded-xl border border-green-200"${_scopeId}><p class="text-lg font-semibold text-green-800"${_scopeId}>${ssrInterpolate_1(formatarMoeda(vueExports.unref(beneficiosAtivos).vale_transporte.valor))}</p><p class="text-xs text-green-600 mt-1"${_scopeId}> Ativo  Gerenciado pelo RH</p></div></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (vueExports.unref(beneficiosAtivos).cesta_basica) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Cesta Bsica</label><div class="p-3 bg-blue-50 rounded-xl border border-blue-200"${_scopeId}><p class="text-lg font-semibold text-blue-800"${_scopeId}>${ssrInterpolate_1(formatarMoeda(vueExports.unref(beneficiosAtivos).cesta_basica.valor))}</p><p class="text-xs text-blue-600 mt-1"${_scopeId}> Ativo  Gerenciado pelo RH</p></div></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (vueExports.unref(beneficiosAtivos).plano_saude) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Plano de Sade</label><div class="p-3 bg-purple-50 rounded-xl border border-purple-200"${_scopeId}><p class="text-lg font-semibold text-purple-800"${_scopeId}>${ssrInterpolate_1(formatarMoeda(vueExports.unref(beneficiosAtivos).plano_saude.valor_funcionario))}</p><p class="text-xs text-purple-600 mt-1"${_scopeId}> Ativo  Gerenciado pelo RH</p></div></div>`);
              } else {
                _push2(`<!---->`);
              }
              if (vueExports.unref(beneficiosAtivos).plano_odonto) {
                _push2(`<div${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>Plano Odontolgico</label><div class="p-3 bg-indigo-50 rounded-xl border border-indigo-200"${_scopeId}><p class="text-lg font-semibold text-indigo-800"${_scopeId}>${ssrInterpolate_1(formatarMoeda(vueExports.unref(beneficiosAtivos).plano_odonto.valor_funcionario))}</p><p class="text-xs text-indigo-600 mt-1"${_scopeId}> Ativo  Gerenciado pelo RH</p></div></div>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`<!--[-->`);
              ssrRenderList_1(vueExports.unref(beneficiosPersonalizadosAtivos), (beneficio) => {
                _push2(`<div class="beneficio-personalizado"${_scopeId}><label class="block text-sm font-medium text-gray-500 mb-1"${_scopeId}>${ssrInterpolate_1(beneficio.nome)}</label><div class="p-3 bg-orange-50 rounded-xl border border-orange-200"${_scopeId}><div class="flex items-center gap-2 mb-1"${_scopeId}><span class="text-lg"${_scopeId}>${ssrInterpolate_1(beneficio.icone || "")}</span><p class="text-lg font-semibold text-orange-800"${_scopeId}>${ssrInterpolate_1(formatarMoeda(beneficio.valor))}</p></div><p class="text-xs text-orange-600"${_scopeId}> Ativo  Gerenciado pelo RH</p>`);
                if (beneficio.descricao) {
                  _push2(`<p class="text-xs text-gray-600 mt-1"${_scopeId}>${ssrInterpolate_1(beneficio.descricao)}</p>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</div></div>`);
              });
              _push2(`<!--]-->`);
              if (!vueExports.unref(temBeneficios)) {
                _push2(`<div class="col-span-full"${_scopeId}><div class="text-center py-8 bg-gray-50 rounded-xl border border-gray-200"${_scopeId}><svg class="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"${_scopeId}></path></svg><p class="text-gray-600 font-medium"${_scopeId}>Nenhum benefcio configurado</p><p class="text-sm text-gray-500 mt-1"${_scopeId}>Entre em contato com o RH para mais informaes</p></div></div>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div>`);
            } else {
              return [
                vueExports.createVNode(_component_UiAlert, {
                  variant: "info",
                  class: "mb-6"
                }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(" Estes benefcios so gerenciados pelo RH e no podem ser alterados por voc. ")
                  ]),
                  _: 1
                }),
                vueExports.createVNode("div", { class: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" }, [
                  vueExports.unref(beneficiosAtivos).vale_transporte ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 0 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Vale Transporte"),
                    vueExports.createVNode("div", { class: "p-3 bg-green-50 rounded-xl border border-green-200" }, [
                      vueExports.createVNode("p", { class: "text-lg font-semibold text-green-800" }, vueExports.toDisplayString(formatarMoeda(vueExports.unref(beneficiosAtivos).vale_transporte.valor)), 1),
                      vueExports.createVNode("p", { class: "text-xs text-green-600 mt-1" }, " Ativo  Gerenciado pelo RH")
                    ])
                  ])) : vueExports.createCommentVNode("", true),
                  vueExports.unref(beneficiosAtivos).cesta_basica ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 1 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Cesta Bsica"),
                    vueExports.createVNode("div", { class: "p-3 bg-blue-50 rounded-xl border border-blue-200" }, [
                      vueExports.createVNode("p", { class: "text-lg font-semibold text-blue-800" }, vueExports.toDisplayString(formatarMoeda(vueExports.unref(beneficiosAtivos).cesta_basica.valor)), 1),
                      vueExports.createVNode("p", { class: "text-xs text-blue-600 mt-1" }, " Ativo  Gerenciado pelo RH")
                    ])
                  ])) : vueExports.createCommentVNode("", true),
                  vueExports.unref(beneficiosAtivos).plano_saude ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 2 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Plano de Sade"),
                    vueExports.createVNode("div", { class: "p-3 bg-purple-50 rounded-xl border border-purple-200" }, [
                      vueExports.createVNode("p", { class: "text-lg font-semibold text-purple-800" }, vueExports.toDisplayString(formatarMoeda(vueExports.unref(beneficiosAtivos).plano_saude.valor_funcionario)), 1),
                      vueExports.createVNode("p", { class: "text-xs text-purple-600 mt-1" }, " Ativo  Gerenciado pelo RH")
                    ])
                  ])) : vueExports.createCommentVNode("", true),
                  vueExports.unref(beneficiosAtivos).plano_odonto ? (vueExports.openBlock(), vueExports.createBlock("div", { key: 3 }, [
                    vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, "Plano Odontolgico"),
                    vueExports.createVNode("div", { class: "p-3 bg-indigo-50 rounded-xl border border-indigo-200" }, [
                      vueExports.createVNode("p", { class: "text-lg font-semibold text-indigo-800" }, vueExports.toDisplayString(formatarMoeda(vueExports.unref(beneficiosAtivos).plano_odonto.valor_funcionario)), 1),
                      vueExports.createVNode("p", { class: "text-xs text-indigo-600 mt-1" }, " Ativo  Gerenciado pelo RH")
                    ])
                  ])) : vueExports.createCommentVNode("", true),
                  (vueExports.openBlock(true), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(vueExports.unref(beneficiosPersonalizadosAtivos), (beneficio) => {
                    return vueExports.openBlock(), vueExports.createBlock("div", {
                      key: beneficio.nome,
                      class: "beneficio-personalizado"
                    }, [
                      vueExports.createVNode("label", { class: "block text-sm font-medium text-gray-500 mb-1" }, vueExports.toDisplayString(beneficio.nome), 1),
                      vueExports.createVNode("div", { class: "p-3 bg-orange-50 rounded-xl border border-orange-200" }, [
                        vueExports.createVNode("div", { class: "flex items-center gap-2 mb-1" }, [
                          vueExports.createVNode("span", { class: "text-lg" }, vueExports.toDisplayString(beneficio.icone || ""), 1),
                          vueExports.createVNode("p", { class: "text-lg font-semibold text-orange-800" }, vueExports.toDisplayString(formatarMoeda(beneficio.valor)), 1)
                        ]),
                        vueExports.createVNode("p", { class: "text-xs text-orange-600" }, " Ativo  Gerenciado pelo RH"),
                        beneficio.descricao ? (vueExports.openBlock(), vueExports.createBlock("p", {
                          key: 0,
                          class: "text-xs text-gray-600 mt-1"
                        }, vueExports.toDisplayString(beneficio.descricao), 1)) : vueExports.createCommentVNode("", true)
                      ])
                    ]);
                  }), 128)),
                  !vueExports.unref(temBeneficios) ? (vueExports.openBlock(), vueExports.createBlock("div", {
                    key: 4,
                    class: "col-span-full"
                  }, [
                    vueExports.createVNode("div", { class: "text-center py-8 bg-gray-50 rounded-xl border border-gray-200" }, [
                      (vueExports.openBlock(), vueExports.createBlock("svg", {
                        class: "w-12 h-12 text-gray-400 mx-auto mb-4",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        vueExports.createVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"
                        })
                      ])),
                      vueExports.createVNode("p", { class: "text-gray-600 font-medium" }, "Nenhum benefcio configurado"),
                      vueExports.createVNode("p", { class: "text-sm text-gray-500 mt-1" }, "Entre em contato com o RH para mais informaes")
                    ])
                  ])) : vueExports.createCommentVNode("", true)
                ])
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_UiNotification, {
          show: vueExports.unref(mostrarNotificacao),
          title: vueExports.unref(notificacao).title,
          message: vueExports.unref(notificacao).message,
          variant: vueExports.unref(notificacao).variant,
          onClose: ($event) => mostrarNotificacao.value = false
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiAvatarSelector, {
          show: vueExports.unref(mostrarSeletorAvatar),
          "user-name": vueExports.unref(dadosOriginais)?.nome_completo || vueExports.unref(user)?.nome || "",
          "current-avatar": vueExports.unref(dadosOriginais)?.avatar,
          onClose: ($event) => mostrarSeletorAvatar.value = false,
          onSave: salvarAvatar
        }, null, _parent));
        _push(`</div>`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$e = _sfc_main$e.setup;
_sfc_main$e.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/meus-dados.vue");
  return _sfc_setup$e ? _sfc_setup$e(props, ctx) : void 0;
};

const meusDadosPAa5nP8t = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$e
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$d = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiTextarea",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    label: {},
    placeholder: {},
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    rows: { default: 3 }
  },
  emits: ["update:modelValue"],
  setup(__props) {
    const id = vueExports.computed(() => `textarea-${Math.random().toString(36).substr(2, 9)}`);
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", vueExports.unref(id))} class="block text-sm font-medium text-gray-600 mb-1">${ssrInterpolate_1(__props.label)} `);
        if (__props.required) {
          _push(`<span class="text-red-500">*</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<textarea${ssrRenderAttr_1("id", vueExports.unref(id))}${ssrRenderAttr_1("placeholder", __props.placeholder)}${ssrIncludeBooleanAttr(__props.disabled) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""}${ssrRenderAttr_1("rows", __props.rows)} class="${ssrRenderClass_1([
        "w-full px-4 py-3 text-lg border-2 rounded-xl outline-none transition-colors resize-none",
        __props.disabled ? "border-gray-100 bg-gray-50 text-gray-500" : "border-gray-200 focus:border-primary-500"
      ])}">${ssrInterpolate_1(__props.modelValue)}</textarea></div>`);
    };
  }
});
const _sfc_setup$d = _sfc_main$d.setup;
_sfc_main$d.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiTextarea.vue");
  return _sfc_setup$d ? _sfc_setup$d(props, ctx) : void 0;
};
const __nuxt_component_5$1 = Object.assign(_sfc_main$d, { __name: "UiTextarea" });

const useCargos = () => {
  const cargos = vueExports.ref([]);
  const loading = vueExports.ref(false);
  const error = vueExports.ref("");
  const carregarCargos = async () => {
    loading.value = true;
    error.value = "";
    try {
      const response = await $fetch("/api/cargos");
      if (response.success && response.data) {
        cargos.value = Array.isArray(response.data) ? response.data : [];
      } else {
        cargos.value = [];
      }
    } catch (err) {
      error.value = "Erro ao carregar cargos";
      console.error("Erro ao carregar cargos:", err);
      cargos.value = [];
    } finally {
      loading.value = false;
    }
  };
  const salvarCargo = async (cargo) => {
    loading.value = true;
    try {
      const response = await $fetch("/api/cargos", {
        method: "POST",
        body: cargo
      });
      if (response.success) {
        await carregarCargos();
        return { success: true, message: response.message || "Cargo salvo com sucesso!" };
      }
      return { success: false, message: "Erro ao salvar cargo" };
    } catch (err) {
      console.error("Erro ao salvar cargo:", err);
      return { success: false, message: err.data?.message || "Erro ao salvar cargo" };
    } finally {
      loading.value = false;
    }
  };
  const opcoesCargos = vueExports.computed(() => {
    if (!Array.isArray(cargos.value)) {
      return [];
    }
    return cargos.value.map((c) => ({
      value: c.id.toString(),
      label: c.nome
    }));
  });
  return {
    cargos: vueExports.readonly(cargos),
    loading: vueExports.readonly(loading),
    error: vueExports.readonly(error),
    opcoesCargos,
    carregarCargos,
    salvarCargo
  };
};

const _sfc_main$c = /* @__PURE__ */ vueExports.defineComponent({
  __name: "cargos",
  __ssrInlineRender: true,
  setup(__props) {
    const { cargos, loading, salvarCargo } = useCargos();
    const modalAberto = vueExports.ref(false);
    const editando = vueExports.ref(null);
    const form = vueExports.ref({ nome: "", descricao: "", nivel: "" });
    const mostrarNotificacao = vueExports.ref(false);
    const notificacao = vueExports.ref({
      title: "",
      message: "",
      variant: "success"
    });
    const superioresOptions = vueExports.computed(() => {
      return cargos.value.filter((c) => !editando.value || c.id !== editando.value.id).map((c) => ({
        value: c.id,
        label: c.nome
      }));
    });
    const abrirModal = (cargo) => {
      editando.value = cargo || null;
      form.value = cargo ? { ...cargo } : { nome: "", descricao: "", nivel: "" };
      modalAberto.value = true;
    };
    const salvar = async () => {
      const dadosCargo = editando.value ? { ...form.value, id: editando.value.id } : form.value;
      const resultado = await salvarCargo(dadosCargo);
      notificacao.value = {
        title: resultado.success ? "Sucesso!" : "Erro!",
        message: resultado.message,
        variant: resultado.success ? "success" : "error"
      };
      mostrarNotificacao.value = true;
      if (resultado.success) {
        modalAberto.value = false;
      }
      setTimeout(() => {
        mostrarNotificacao.value = false;
      }, 3e3);
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiPageHeader = __nuxt_component_0$3;
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiCard = __nuxt_component_2$1;
      const _component_UiModal = __nuxt_component_3;
      const _component_UiInput = __nuxt_component_4;
      const _component_UiTextarea = __nuxt_component_5$1;
      const _component_UiSelect = __nuxt_component_6$1;
      const _component_UiNotification = __nuxt_component_7;
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      _push(ssrRenderComponent_1(_component_UiPageHeader, {
        title: "Cargos",
        description: "Defina os cargos e hierarquia da empresa"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent_1(_component_UiButton, {
              size: "lg",
              icon: "",
              onClick: ($event) => abrirModal()
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Novo Cargo `);
                } else {
                  return [
                    vueExports.createTextVNode(" Novo Cargo ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              vueExports.createVNode(_component_UiButton, {
                size: "lg",
                icon: "",
                onClick: ($event) => abrirModal()
              }, {
                default: vueExports.withCtx(() => [
                  vueExports.createTextVNode(" Novo Cargo ")
                ]),
                _: 1
              }, 8, ["onClick"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="space-y-4"><!--[-->`);
      ssrRenderList_1(vueExports.unref(cargos), (cargo) => {
        _push(ssrRenderComponent_1(_component_UiCard, {
          key: cargo.id,
          padding: "p-6"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="flex flex-col sm:flex-row sm:items-center justify-between gap-4"${_scopeId}><div class="flex items-center gap-4"${_scopeId}><div class="w-14 h-14 bg-blue-100 rounded-xl flex items-center justify-center"${_scopeId}><svg class="w-7 h-7 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"${_scopeId}></path></svg></div><div${_scopeId}><h3 class="text-xl font-bold text-gray-800"${_scopeId}>${ssrInterpolate_1(cargo.nome)}</h3><p class="text-gray-500"${_scopeId}>${ssrInterpolate_1(cargo.descricao)}</p>`);
              if (cargo.nivel) {
                _push2(`<p class="text-sm text-gray-400 mt-1"${_scopeId}> Nvel: ${ssrInterpolate_1(cargo.nivel)}</p>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div></div>`);
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => abrirModal(cargo)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(` Editar`);
                  } else {
                    return [
                      vueExports.createTextVNode(" Editar")
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(`</div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "flex flex-col sm:flex-row sm:items-center justify-between gap-4" }, [
                  vueExports.createVNode("div", { class: "flex items-center gap-4" }, [
                    vueExports.createVNode("div", { class: "w-14 h-14 bg-blue-100 rounded-xl flex items-center justify-center" }, [
                      (vueExports.openBlock(), vueExports.createBlock("svg", {
                        class: "w-7 h-7 text-blue-600",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        vueExports.createVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
                        })
                      ]))
                    ]),
                    vueExports.createVNode("div", null, [
                      vueExports.createVNode("h3", { class: "text-xl font-bold text-gray-800" }, vueExports.toDisplayString(cargo.nome), 1),
                      vueExports.createVNode("p", { class: "text-gray-500" }, vueExports.toDisplayString(cargo.descricao), 1),
                      cargo.nivel ? (vueExports.openBlock(), vueExports.createBlock("p", {
                        key: 0,
                        class: "text-sm text-gray-400 mt-1"
                      }, " Nvel: " + vueExports.toDisplayString(cargo.nivel), 1)) : vueExports.createCommentVNode("", true)
                    ])
                  ]),
                  vueExports.createVNode(_component_UiButton, {
                    variant: "ghost",
                    onClick: ($event) => abrirModal(cargo)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(" Editar")
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ];
            }
          }),
          _: 2
        }, _parent));
      });
      _push(`<!--]--></div>`);
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalAberto),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalAberto) ? modalAberto.value = $event : null,
        title: vueExports.unref(editando) ? "Editar Cargo" : "Novo Cargo"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<form class="space-y-4"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).nome,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).nome = $event,
              label: "Nome do Cargo",
              required: ""
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiTextarea, {
              modelValue: vueExports.unref(form).descricao,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).descricao = $event,
              label: "Descrio"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiSelect, {
              modelValue: vueExports.unref(form).nivel,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).nivel = $event,
              options: vueExports.unref(superioresOptions),
              label: "Cargo Superior (Reporta a)",
              placeholder: "Nenhum (cargo mais alto)"
            }, null, _parent2, _scopeId));
            _push2(`<div class="flex justify-end gap-3 pt-4"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "secondary",
              onClick: ($event) => modalAberto.value = false
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Cancelar`);
                } else {
                  return [
                    vueExports.createTextVNode("Cancelar")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              type: "submit",
              icon: "",
              disabled: vueExports.unref(loading)
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Salvar`);
                } else {
                  return [
                    vueExports.createTextVNode("Salvar")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></form>`);
          } else {
            return [
              vueExports.createVNode("form", {
                onSubmit: vueExports.withModifiers(salvar, ["prevent"]),
                class: "space-y-4"
              }, [
                vueExports.createVNode(_component_UiInput, {
                  modelValue: vueExports.unref(form).nome,
                  "onUpdate:modelValue": ($event) => vueExports.unref(form).nome = $event,
                  label: "Nome do Cargo",
                  required: ""
                }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                vueExports.createVNode(_component_UiTextarea, {
                  modelValue: vueExports.unref(form).descricao,
                  "onUpdate:modelValue": ($event) => vueExports.unref(form).descricao = $event,
                  label: "Descrio"
                }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                vueExports.createVNode(_component_UiSelect, {
                  modelValue: vueExports.unref(form).nivel,
                  "onUpdate:modelValue": ($event) => vueExports.unref(form).nivel = $event,
                  options: vueExports.unref(superioresOptions),
                  label: "Cargo Superior (Reporta a)",
                  placeholder: "Nenhum (cargo mais alto)"
                }, null, 8, ["modelValue", "onUpdate:modelValue", "options"]),
                vueExports.createVNode("div", { class: "flex justify-end gap-3 pt-4" }, [
                  vueExports.createVNode(_component_UiButton, {
                    variant: "secondary",
                    onClick: ($event) => modalAberto.value = false
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode("Cancelar")
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  vueExports.createVNode(_component_UiButton, {
                    type: "submit",
                    icon: "",
                    disabled: vueExports.unref(loading)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode("Salvar")
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ], 32)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiNotification, {
        show: vueExports.unref(mostrarNotificacao),
        title: vueExports.unref(notificacao).title,
        message: vueExports.unref(notificacao).message,
        variant: vueExports.unref(notificacao).variant,
        onClose: ($event) => mostrarNotificacao.value = false
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$c = _sfc_main$c.setup;
_sfc_main$c.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/cargos.vue");
  return _sfc_setup$c ? _sfc_setup$c(props, ctx) : void 0;
};

const cargosBp2cKJr1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$c
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$b = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiCheckbox",
  __ssrInlineRender: true,
  props: {
    modelValue: { type: Boolean },
    label: {}
  },
  emits: ["update:modelValue"],
  setup(__props) {
    const inputId = `checkbox-${Math.random().toString(36).substr(2, 9)}`;
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "flex items-center" }, _attrs))}><input${ssrRenderAttr_1("id", inputId)} type="checkbox"${ssrIncludeBooleanAttr(__props.modelValue) ? " checked" : ""} class="h-4 w-4 text-primary-600 focus:ring-primary-500 border-gray-300 rounded">`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", inputId)} class="ml-2 block text-sm text-gray-900">${ssrInterpolate_1(__props.label)}</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$b = _sfc_main$b.setup;
_sfc_main$b.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiCheckbox.vue");
  return _sfc_setup$b ? _sfc_setup$b(props, ctx) : void 0;
};
const __nuxt_component_0$2 = Object.assign(_sfc_main$b, { __name: "UiCheckbox" });

const useEmpresas = () => {
  const empresas = vueExports.ref([]);
  const loading = vueExports.ref(false);
  const error = vueExports.ref("");
  const empresasExemplo = [
    {
      id: "550e8400-e29b-41d4-a716-446655440000",
      nome: "Empresa Exemplo LTDA",
      nome_fantasia: "Exemplo Corp",
      cnpj: "12.345.678/0001-90",
      inscricao_estadual: "123.456.789.012",
      logradouro: "Rua Exemplo",
      numero: "123",
      bairro: "Centro",
      municipio: "So Paulo",
      uf: "SP",
      cep: "01234-567",
      endereco_completo: "Rua Exemplo, 123 - Centro - So Paulo/SP - CEP: 01234-567",
      telefone: "(11) 3333-4444",
      email_holerites: "rh@empresa.com",
      situacao_cadastral: "ATIVA",
      atividade_principal: "Atividades de consultoria em gesto empresarial",
      porte: "DEMAIS",
      logo_url: "",
      funcionarios_count: 12,
      ativo: true
    },
    {
      id: "550e8400-e29b-41d4-a716-446655440001",
      nome: "Tech Solutions S.A.",
      nome_fantasia: "TechSol",
      cnpj: "98.765.432/0001-10",
      inscricao_estadual: "987.654.321.098",
      logradouro: "Av. Tecnologia",
      numero: "456",
      bairro: "Copacabana",
      municipio: "Rio de Janeiro",
      uf: "RJ",
      cep: "22070-900",
      endereco_completo: "Av. Tecnologia, 456 - Copacabana - Rio de Janeiro/RJ - CEP: 22070-900",
      telefone: "(21) 2222-3333",
      email_holerites: "rh@techsolutions.com",
      situacao_cadastral: "ATIVA",
      atividade_principal: "Desenvolvimento de programas de computador sob encomenda",
      porte: "DEMAIS",
      logo_url: "",
      funcionarios_count: 25,
      ativo: true
    },
    {
      id: "550e8400-e29b-41d4-a716-446655440002",
      nome: "Consultoria ABC LTDA",
      nome_fantasia: "ABC Consultoria",
      cnpj: "11.222.333/0001-44",
      inscricao_estadual: "111.222.333.444",
      logradouro: "Rua Consultoria",
      numero: "789",
      bairro: "Savassi",
      municipio: "Belo Horizonte",
      uf: "MG",
      cep: "30112-000",
      endereco_completo: "Rua Consultoria, 789 - Savassi - Belo Horizonte/MG - CEP: 30112-000",
      telefone: "(31) 1111-2222",
      email_holerites: "rh@consultoriaabc.com",
      situacao_cadastral: "BAIXADA",
      atividade_principal: "Atividades de consultoria em gesto empresarial",
      porte: "ME",
      logo_url: "",
      funcionarios_count: 8,
      ativo: false
    }
  ];
  const carregarEmpresas = async () => {
    loading.value = true;
    error.value = "";
    try {
      const response = await $fetch("/api/empresas");
      if (response.success && response.data) {
        empresas.value = response.data;
      }
    } catch (err) {
      error.value = "Erro ao carregar empresas";
      console.error("Erro ao carregar empresas:", err);
      empresas.value = empresasExemplo;
    } finally {
      loading.value = false;
    }
  };
  const salvarEmpresa = async (empresa) => {
    loading.value = true;
    try {
      const response = await $fetch("/api/empresas", {
        method: "POST",
        body: empresa
      });
      if (response.success) {
        await carregarEmpresas();
        return { success: true, message: response.message || "Empresa salva com sucesso!" };
      }
      return { success: false, message: "Erro ao salvar empresa" };
    } catch (err) {
      console.error("Erro ao salvar empresa:", err);
      return { success: false, message: err.data?.message || "Erro ao salvar empresa" };
    } finally {
      loading.value = false;
    }
  };
  const deletarEmpresa = async (empresaId) => {
    try {
      const response = await $fetch(`/api/empresas/${empresaId}`, {
        method: "DELETE"
      });
      if (response.success) {
        const index = empresas.value.findIndex((e) => e.id === empresaId);
        if (index !== -1) {
          empresas.value.splice(index, 1);
        }
        return { success: true, message: "Empresa excluda com sucesso!" };
      }
      return { success: false, message: "Erro ao excluir empresa" };
    } catch (err) {
      console.error("Erro ao excluir empresa:", err);
      return { success: false, message: err.data?.message || "Erro ao excluir empresa" };
    }
  };
  const obterEmpresaPorId = (id) => {
    return empresas.value.find((e) => e.id === id);
  };
  const obterEmpresasAtivas = vueExports.computed(() => {
    return empresas.value;
  });
  const obterOpcoesEmpresas = vueExports.computed(() => {
    return empresas.value.map((e) => ({
      value: e.id,
      label: e.nome
    }));
  });
  return {
    empresas: vueExports.readonly(empresas),
    loading: vueExports.readonly(loading),
    error: vueExports.readonly(error),
    obterEmpresasAtivas,
    obterOpcoesEmpresas,
    carregarEmpresas,
    salvarEmpresa,
    deletarEmpresa,
    obterEmpresaPorId
  };
};

const useCNPJ = () => {
  const loading = vueExports.ref(false);
  const error = vueExports.ref("");
  const consultarCNPJ = async (cnpj) => {
    loading.value = true;
    error.value = "";
    try {
      const cnpjLimpo = cnpj.replace(/[^\d]/g, "");
      if (!cnpjLimpo) {
        throw new Error("CNPJ  obrigatrio");
      }
      if (cnpjLimpo.length !== 14) {
        throw new Error("CNPJ deve ter 14 dgitos");
      }
      if (!validarCNPJ(cnpjLimpo)) {
        throw new Error("CNPJ invlido");
      }
      console.log(" Consultando CNPJ:", cnpjLimpo);
      const response = await $fetch("/api/consulta-cnpj", {
        method: "POST",
        body: { cnpj: cnpjLimpo },
        headers: {
          "Content-Type": "application/json"
        },
        // Adicionar retry em caso de falha
        retry: 1,
        retryDelay: 1e3
      });
      console.log(" Resposta recebida:", response);
      if (response.success) {
        console.log(" Inscrio Estadual:", response.data?.inscricao_estadual || "No informada");
        return {
          success: true,
          data: response.data,
          message: "Dados da empresa encontrados com sucesso!"
        };
      } else {
        throw new Error("Erro na consulta");
      }
    } catch (err) {
      console.error(" Erro na consulta CNPJ:", err);
      let mensagem = "Erro ao consultar CNPJ";
      if (err.statusCode === 404) {
        mensagem = "CNPJ no encontrado na Receita Federal";
      } else if (err.statusCode === 400) {
        mensagem = err.data?.message || err.message || "CNPJ invlido";
      } else if (err.statusCode === 429) {
        mensagem = "Muitas consultas realizadas. Aguarde alguns minutos e tente novamente.";
      } else if (err.statusCode === 503) {
        mensagem = "Servio temporariamente indisponvel. Tente novamente em alguns minutos.";
      } else if (err.name === "FetchError") {
        mensagem = "Erro de conexo. Verifique sua internet e tente novamente.";
      } else {
        mensagem = err.data?.message || err.message || "Erro interno do servidor";
      }
      error.value = mensagem;
      return {
        success: false,
        message: mensagem
      };
    } finally {
      loading.value = false;
    }
  };
  const formatarCNPJ = (cnpj) => {
    const cnpjLimpo = cnpj.replace(/[^\d]/g, "");
    if (cnpjLimpo.length === 14) {
      return cnpjLimpo.replace(/^(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})$/, "$1.$2.$3/$4-$5");
    }
    return cnpj;
  };
  const validarCNPJ = (cnpj) => {
    const cnpjLimpo = cnpj.replace(/[^\d]/g, "");
    if (cnpjLimpo.length !== 14) return false;
    if (/^(\d)\1+$/.test(cnpjLimpo)) return false;
    let soma = 0;
    let peso = 2;
    for (let i = 11; i >= 0; i--) {
      soma += parseInt(cnpjLimpo.charAt(i)) * peso;
      peso = peso === 9 ? 2 : peso + 1;
    }
    let digito1 = soma % 11 < 2 ? 0 : 11 - soma % 11;
    if (parseInt(cnpjLimpo.charAt(12)) !== digito1) return false;
    soma = 0;
    peso = 2;
    for (let i = 12; i >= 0; i--) {
      soma += parseInt(cnpjLimpo.charAt(i)) * peso;
      peso = peso === 9 ? 2 : peso + 1;
    }
    let digito2 = soma % 11 < 2 ? 0 : 11 - soma % 11;
    return parseInt(cnpjLimpo.charAt(13)) === digito2;
  };
  return {
    loading: vueExports.readonly(loading),
    error: vueExports.readonly(error),
    consultarCNPJ,
    formatarCNPJ,
    validarCNPJ
  };
};
const _sfc_main$1$5 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "UiInputCNPJ",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    label: {},
    placeholder: { default: "00.000.000/0000-00" },
    disabled: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    hint: {},
    error: {},
    autoConsulta: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", "dados-encontrados"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { formatarCNPJ, validarCNPJ, loading: consultando, error: consultaError } = useCNPJ();
    const id = vueExports.computed(() => `cnpj-input-${Math.random().toString(36).substring(2, 11)}`);
    const consultaSucesso = vueExports.ref("");
    const debounceTimer = vueExports.ref(null);
    const displayValue = vueExports.computed(() => {
      return formatarCNPJ(props.modelValue);
    });
    const cnpjValido = vueExports.computed(() => {
      const cnpjLimpo = props.modelValue.replace(/[^\d]/g, "");
      return cnpjLimpo.length === 14 && validarCNPJ(cnpjLimpo);
    });
    vueExports.watch(() => props.modelValue, () => {
      consultaSucesso.value = "";
      if (debounceTimer.value) {
        clearTimeout(debounceTimer.value);
      }
    }, { immediate: false });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      if (__props.label) {
        _push(`<label${ssrRenderAttr_1("for", vueExports.unref(id))} class="block text-sm font-medium text-gray-600 mb-1">${ssrInterpolate_1(__props.label)} `);
        if (__props.required) {
          _push(`<span class="text-red-500">*</span>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</label>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="relative"><input${ssrRenderAttr_1("id", vueExports.unref(id))}${ssrRenderAttr_1("value", vueExports.unref(displayValue))}${ssrRenderAttr_1("placeholder", __props.placeholder)}${ssrIncludeBooleanAttr(__props.disabled) ? " disabled" : ""}${ssrIncludeBooleanAttr(__props.required) ? " required" : ""} class="${ssrRenderClass_1([
        "w-full px-4 py-3 text-lg border-2 rounded-xl outline-none transition-colors pr-20",
        __props.disabled ? "border-gray-100 bg-gray-50 text-gray-500" : "border-gray-200 focus:border-primary-500",
        __props.error ? "border-red-300" : "",
        vueExports.unref(consultando) ? "bg-blue-50" : ""
      ])}">`);
      if (vueExports.unref(cnpjValido) && !vueExports.unref(consultando)) {
        _push(`<button type="button" class="absolute right-2 top-1/2 -translate-y-1/2 px-3 py-1 text-sm font-medium text-primary-600 bg-primary-50 rounded-lg hover:bg-primary-100 transition-colors">  Buscar </button>`);
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(consultando)) {
        _push(`<div class="absolute right-4 top-1/2 -translate-y-1/2"><svg class="w-5 h-5 animate-spin text-primary-600" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div class="mt-1 space-y-1">`);
      if (__props.hint && !__props.error && !vueExports.unref(consultaError)) {
        _push(`<p class="text-xs text-gray-400">${ssrInterpolate_1(__props.hint)}</p>`);
      } else {
        _push(`<!---->`);
      }
      if (__props.error) {
        _push(`<p class="text-xs text-red-500">${ssrInterpolate_1(__props.error)}</p>`);
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(consultaError)) {
        _push(`<p class="text-xs text-red-500">${ssrInterpolate_1(vueExports.unref(consultaError))}</p>`);
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(consultaSucesso)) {
        _push(`<p class="text-xs text-green-600 flex items-center gap-1"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg> ${ssrInterpolate_1(vueExports.unref(consultaSucesso))}</p>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$1$5 = _sfc_main$1$5.setup;
_sfc_main$1$5.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/UiInputCNPJ.vue");
  return _sfc_setup$1$5 ? _sfc_setup$1$5(props, ctx) : void 0;
};
const __nuxt_component_5 = Object.assign(_sfc_main$1$5, { __name: "UiInputCNPJ" });
const _sfc_main$a = /* @__PURE__ */ vueExports.defineComponent({
  __name: "empresas",
  __ssrInlineRender: true,
  setup(__props) {
    const { empresas, salvarEmpresa, deletarEmpresa } = useEmpresas();
    const modalAberto = vueExports.ref(false);
    const modalTabelasAberto = vueExports.ref(false);
    const empresaEditando = vueExports.ref(null);
    const mostrarNotificacao = vueExports.ref(false);
    const notificacao = vueExports.ref({
      title: "",
      message: "",
      variant: "success"
    });
    const form = vueExports.ref({
      // Dados principais
      nome: "",
      nome_fantasia: "",
      cnpj: "",
      inscricao_estadual: "",
      // Endereo detalhado
      logradouro: "",
      numero: "",
      complemento: "",
      bairro: "",
      municipio: "",
      uf: "",
      cep: "",
      // Contatos
      telefone: "",
      email_holerites: "",
      // Informaes cadastrais
      situacao_cadastral: "",
      atividade_principal: "",
      natureza_juridica: "",
      porte: "",
      capital_social: "",
      data_abertura: "",
      // Sistema
      logo_url: "",
      mostrar_logo: true,
      mostrar_endereco: true,
      mostrar_cnpj: true,
      mostrar_detalhes_inss: false,
      mostrar_detalhes_irrf: false
    });
    const tabelaINSS = [
      { id: 1, faixa: "At R$ 1.518,00", aliquota: 7.5 },
      { id: 2, faixa: "R$ 1.518,01 a R$ 2.793,88", aliquota: 9 },
      { id: 3, faixa: "R$ 2.793,89 a R$ 4.190,83", aliquota: 12 },
      { id: 4, faixa: "R$ 4.190,84 a R$ 8.157,41", aliquota: 14 }
    ];
    const tabelaIRRF = [
      { id: 1, faixa: "At R$ 2.428,80", aliquota: "Isento" },
      { id: 2, faixa: "R$ 2.428,81 a R$ 3.051,00", aliquota: "7,5%" },
      { id: 3, faixa: "R$ 3.051,01 a R$ 4.052,00", aliquota: "15%" },
      { id: 4, faixa: "R$ 4.052,01 a R$ 5.050,00", aliquota: "22,5%" },
      { id: 5, faixa: "Acima de R$ 5.050,00", aliquota: "27,5%" },
      { id: 6, faixa: "Lei 15.270/2025", aliquota: "Reduo at R$ 7.350" }
    ];
    const ufOptions = [
      { value: "AC", label: "Acre" },
      { value: "AL", label: "Alagoas" },
      { value: "AP", label: "Amap" },
      { value: "AM", label: "Amazonas" },
      { value: "BA", label: "Bahia" },
      { value: "CE", label: "Cear" },
      { value: "DF", label: "Distrito Federal" },
      { value: "ES", label: "Esprito Santo" },
      { value: "GO", label: "Gois" },
      { value: "MA", label: "Maranho" },
      { value: "MT", label: "Mato Grosso" },
      { value: "MS", label: "Mato Grosso do Sul" },
      { value: "MG", label: "Minas Gerais" },
      { value: "PA", label: "Par" },
      { value: "PB", label: "Paraba" },
      { value: "PR", label: "Paran" },
      { value: "PE", label: "Pernambuco" },
      { value: "PI", label: "Piau" },
      { value: "RJ", label: "Rio de Janeiro" },
      { value: "RN", label: "Rio Grande do Norte" },
      { value: "RS", label: "Rio Grande do Sul" },
      { value: "RO", label: "Rondnia" },
      { value: "RR", label: "Roraima" },
      { value: "SC", label: "Santa Catarina" },
      { value: "SP", label: "So Paulo" },
      { value: "SE", label: "Sergipe" },
      { value: "TO", label: "Tocantins" }
    ];
    const abrirModal = (empresa) => {
      if (empresa) {
        empresaEditando.value = empresa;
        Object.assign(form.value, empresa);
      } else {
        empresaEditando.value = null;
        form.value = {
          // Dados principais
          nome: "",
          nome_fantasia: "",
          cnpj: "",
          inscricao_estadual: "",
          // Endereo
          logradouro: "",
          numero: "",
          complemento: "",
          bairro: "",
          municipio: "",
          uf: "",
          cep: "",
          // Contatos
          telefone: "",
          email_holerites: "",
          // Informaes cadastrais
          situacao_cadastral: "",
          atividade_principal: "",
          natureza_juridica: "",
          porte: "",
          capital_social: "",
          data_abertura: "",
          // Sistema
          logo_url: "",
          mostrar_logo: true,
          mostrar_endereco: true,
          mostrar_cnpj: true,
          mostrar_detalhes_inss: false,
          mostrar_detalhes_irrf: false
        };
      }
      modalAberto.value = true;
    };
    const salvarEmpresaForm = async () => {
      const dadosEmpresa = empresaEditando.value ? { ...form.value, id: empresaEditando.value.id } : form.value;
      const resultado = await salvarEmpresa(dadosEmpresa);
      notificacao.value = {
        title: resultado.success ? "Sucesso!" : "Erro!",
        message: resultado.message,
        variant: resultado.success ? "success" : "error"
      };
      mostrarNotificacao.value = true;
      if (resultado.success) {
        modalAberto.value = false;
      }
    };
    const deletar = async (empresa) => {
      if (!confirm(`Tem certeza que deseja excluir a empresa "${empresa.nome}"? Esta ao no pode ser desfeita.`)) {
        return;
      }
      const resultado = await deletarEmpresa(empresa.id);
      notificacao.value = {
        title: resultado.success ? "Sucesso!" : "Erro!",
        message: resultado.message,
        variant: resultado.success ? "success" : "error"
      };
      mostrarNotificacao.value = true;
    };
    const verFuncionarios = (empresa) => {
      navigateTo(`/admin/funcionarios?empresa=${empresa.id}`);
    };
    const formatarEnderecoCompleto = (empresa) => {
      const partes = [];
      if (empresa.logradouro) partes.push(empresa.logradouro);
      if (empresa.numero) partes.push(empresa.numero);
      if (empresa.complemento) partes.push(empresa.complemento);
      if (empresa.bairro) partes.push(empresa.bairro);
      if (empresa.municipio) partes.push(empresa.municipio);
      if (empresa.uf) partes.push(empresa.uf);
      if (empresa.cep) partes.push(`CEP: ${empresa.cep}`);
      return partes.join(", ") || empresa.endereco || "Endereo no informado";
    };
    const preencherDadosEmpresa = (dados) => {
      if (dados.nome && !form.value.nome) {
        form.value.nome = dados.nome;
      }
      if (dados.nome_fantasia && !form.value.nome_fantasia) {
        form.value.nome_fantasia = dados.nome_fantasia;
      }
      if (dados.inscricao_estadual && !form.value.inscricao_estadual) {
        form.value.inscricao_estadual = dados.inscricao_estadual;
      }
      if (dados.logradouro && !form.value.logradouro) {
        form.value.logradouro = dados.logradouro;
      }
      if (dados.numero && !form.value.numero) {
        form.value.numero = dados.numero;
      }
      if (dados.complemento && !form.value.complemento) {
        form.value.complemento = dados.complemento;
      }
      if (dados.bairro && !form.value.bairro) {
        form.value.bairro = dados.bairro;
      }
      if (dados.municipio && !form.value.municipio) {
        form.value.municipio = dados.municipio;
      }
      if (dados.uf && !form.value.uf) {
        form.value.uf = dados.uf;
      }
      if (dados.cep && !form.value.cep) {
        form.value.cep = dados.cep;
      }
      if (dados.telefone && !form.value.telefone) {
        form.value.telefone = dados.telefone;
      }
      if (dados.email && !form.value.email_holerites) {
        form.value.email_holerites = dados.email;
      }
      if (dados.situacao_cadastral) {
        form.value.situacao_cadastral = dados.situacao_cadastral;
      }
      if (dados.atividade_principal && !form.value.atividade_principal) {
        form.value.atividade_principal = dados.atividade_principal;
      }
      if (dados.natureza_juridica && !form.value.natureza_juridica) {
        form.value.natureza_juridica = dados.natureza_juridica;
      }
      if (dados.porte && !form.value.porte) {
        form.value.porte = dados.porte;
      }
      if (dados.capital_social && !form.value.capital_social) {
        form.value.capital_social = dados.capital_social;
      }
      if (dados.data_abertura && !form.value.data_abertura) {
        form.value.data_abertura = dados.data_abertura;
      }
      form.value.cnpj = dados.cnpj;
      notificacao.value = {
        title: "Dados encontrados!",
        message: `Empresa: ${dados.nome} - ${dados.situacao_cadastral}`,
        variant: "success"
      };
      mostrarNotificacao.value = true;
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiPageHeader = __nuxt_component_0$3;
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiCard = __nuxt_component_2$1;
      const _component_UiBadge = __nuxt_component_2$2;
      const _component_UiModal = __nuxt_component_3;
      const _component_UiInputCNPJ = __nuxt_component_5;
      const _component_UiInput = __nuxt_component_4;
      const _component_UiSelect = __nuxt_component_6$1;
      const _component_UiCheckbox = __nuxt_component_0$2;
      const _component_UiAlert = __nuxt_component_1$1;
      const _component_UiNotification = __nuxt_component_7;
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      _push(ssrRenderComponent_1(_component_UiPageHeader, {
        title: "Empresas",
        description: "Gerencie todas as empresas do sistema"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="flex gap-3"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "ghost",
              icon: "",
              onClick: ($event) => modalTabelasAberto.value = true
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Ver Tabelas INSS/IRRF `);
                } else {
                  return [
                    vueExports.createTextVNode(" Ver Tabelas INSS/IRRF ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              size: "lg",
              icon: "",
              onClick: ($event) => abrirModal()
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Nova Empresa `);
                } else {
                  return [
                    vueExports.createTextVNode(" Nova Empresa ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "flex gap-3" }, [
                vueExports.createVNode(_component_UiButton, {
                  variant: "ghost",
                  icon: "",
                  onClick: ($event) => modalTabelasAberto.value = true
                }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(" Ver Tabelas INSS/IRRF ")
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                vueExports.createVNode(_component_UiButton, {
                  size: "lg",
                  icon: "",
                  onClick: ($event) => abrirModal()
                }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(" Nova Empresa ")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="space-y-4"><!--[-->`);
      ssrRenderList_1(vueExports.unref(empresas), (empresa) => {
        _push(ssrRenderComponent_1(_component_UiCard, {
          key: empresa.id,
          padding: "p-6"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="flex flex-col lg:flex-row lg:items-center justify-between gap-4"${_scopeId}><div class="flex items-center gap-4"${_scopeId}><div class="w-16 h-16 bg-primary-100 rounded-xl flex items-center justify-center"${_scopeId}>`);
              if (empresa.logo_url) {
                _push2(`<img${ssrRenderAttr_1("src", empresa.logo_url)}${ssrRenderAttr_1("alt", empresa.nome)} class="w-full h-full object-cover rounded-xl"${_scopeId}>`);
              } else {
                _push2(`<span class="text-primary-700 font-bold text-2xl"${_scopeId}>${ssrInterpolate_1(empresa.nome.charAt(0))}</span>`);
              }
              _push2(`</div><div${_scopeId}><h3 class="text-xl font-bold text-gray-800"${_scopeId}>${ssrInterpolate_1(empresa.nome)}</h3>`);
              if (empresa.nome_fantasia) {
                _push2(`<p class="text-lg text-gray-600"${_scopeId}>${ssrInterpolate_1(empresa.nome_fantasia)}</p>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`<p class="text-gray-500"${_scopeId}>CNPJ: ${ssrInterpolate_1(empresa.cnpj)}</p>`);
              if (empresa.inscricao_estadual) {
                _push2(`<p class="text-sm text-gray-400"${_scopeId}>IE: ${ssrInterpolate_1(empresa.inscricao_estadual)}</p>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`<p class="text-sm text-gray-400"${_scopeId}>${ssrInterpolate_1(empresa.endereco_completo || formatarEnderecoCompleto(empresa))}</p><div class="flex gap-2 mt-2"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiBadge, { variant: "info" }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(empresa.funcionarios_count)} funcionrios`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(empresa.funcionarios_count) + " funcionrios", 1)
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              if (empresa.situacao_cadastral) {
                _push2(ssrRenderComponent_1(_component_UiBadge, {
                  variant: empresa.situacao_cadastral === "ATIVA" ? "success" : "warning"
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`${ssrInterpolate_1(empresa.situacao_cadastral)}`);
                    } else {
                      return [
                        vueExports.createTextVNode(vueExports.toDisplayString(empresa.situacao_cadastral), 1)
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div></div></div><div class="flex gap-2"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => abrirModal(empresa)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(` Editar`);
                  } else {
                    return [
                      vueExports.createTextVNode(" Editar")
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => verFuncionarios(empresa)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(` Funcionrios`);
                  } else {
                    return [
                      vueExports.createTextVNode(" Funcionrios")
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "danger",
                onClick: ($event) => deletar(empresa)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Excluir `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Excluir ")
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(`</div></div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "flex flex-col lg:flex-row lg:items-center justify-between gap-4" }, [
                  vueExports.createVNode("div", { class: "flex items-center gap-4" }, [
                    vueExports.createVNode("div", { class: "w-16 h-16 bg-primary-100 rounded-xl flex items-center justify-center" }, [
                      empresa.logo_url ? (vueExports.openBlock(), vueExports.createBlock("img", {
                        key: 0,
                        src: empresa.logo_url,
                        alt: empresa.nome,
                        class: "w-full h-full object-cover rounded-xl"
                      }, null, 8, ["src", "alt"])) : (vueExports.openBlock(), vueExports.createBlock("span", {
                        key: 1,
                        class: "text-primary-700 font-bold text-2xl"
                      }, vueExports.toDisplayString(empresa.nome.charAt(0)), 1))
                    ]),
                    vueExports.createVNode("div", null, [
                      vueExports.createVNode("h3", { class: "text-xl font-bold text-gray-800" }, vueExports.toDisplayString(empresa.nome), 1),
                      empresa.nome_fantasia ? (vueExports.openBlock(), vueExports.createBlock("p", {
                        key: 0,
                        class: "text-lg text-gray-600"
                      }, vueExports.toDisplayString(empresa.nome_fantasia), 1)) : vueExports.createCommentVNode("", true),
                      vueExports.createVNode("p", { class: "text-gray-500" }, "CNPJ: " + vueExports.toDisplayString(empresa.cnpj), 1),
                      empresa.inscricao_estadual ? (vueExports.openBlock(), vueExports.createBlock("p", {
                        key: 1,
                        class: "text-sm text-gray-400"
                      }, "IE: " + vueExports.toDisplayString(empresa.inscricao_estadual), 1)) : vueExports.createCommentVNode("", true),
                      vueExports.createVNode("p", { class: "text-sm text-gray-400" }, vueExports.toDisplayString(empresa.endereco_completo || formatarEnderecoCompleto(empresa)), 1),
                      vueExports.createVNode("div", { class: "flex gap-2 mt-2" }, [
                        vueExports.createVNode(_component_UiBadge, { variant: "info" }, {
                          default: vueExports.withCtx(() => [
                            vueExports.createTextVNode(vueExports.toDisplayString(empresa.funcionarios_count) + " funcionrios", 1)
                          ]),
                          _: 2
                        }, 1024),
                        empresa.situacao_cadastral ? (vueExports.openBlock(), vueExports.createBlock(_component_UiBadge, {
                          key: 0,
                          variant: empresa.situacao_cadastral === "ATIVA" ? "success" : "warning"
                        }, {
                          default: vueExports.withCtx(() => [
                            vueExports.createTextVNode(vueExports.toDisplayString(empresa.situacao_cadastral), 1)
                          ]),
                          _: 2
                        }, 1032, ["variant"])) : vueExports.createCommentVNode("", true)
                      ])
                    ])
                  ]),
                  vueExports.createVNode("div", { class: "flex gap-2" }, [
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: ($event) => abrirModal(empresa)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode(" Editar")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: ($event) => verFuncionarios(empresa)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode(" Funcionrios")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "danger",
                      onClick: ($event) => deletar(empresa)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Excluir ")
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ])
                ])
              ];
            }
          }),
          _: 2
        }, _parent));
      });
      _push(`<!--]--></div>`);
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalAberto),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalAberto) ? modalAberto.value = $event : null,
        title: vueExports.unref(empresaEditando) ? "Editar Empresa" : "Nova Empresa",
        "max-width": "max-w-4xl"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<form class="space-y-6"${_scopeId}><div${_scopeId}><h3 class="text-lg font-bold text-gray-800 mb-4"${_scopeId}> Dados da Empresa</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"${_scopeId}><div class="md:col-span-2"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiInputCNPJ, {
              modelValue: vueExports.unref(form).cnpj,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).cnpj = $event,
              label: "CNPJ",
              required: "",
              onDadosEncontrados: preencherDadosEmpresa
            }, null, _parent2, _scopeId));
            _push2(`</div>`);
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).nome,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).nome = $event,
              label: "Nome Empresarial (Razo Social)",
              required: ""
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).nome_fantasia,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).nome_fantasia = $event,
              label: "Nome Fantasia"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).inscricao_estadual,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).inscricao_estadual = $event,
              label: "Inscrio Estadual"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).situacao_cadastral,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).situacao_cadastral = $event,
              label: "Situao Cadastral",
              disabled: ""
            }, null, _parent2, _scopeId));
            _push2(`<div class="md:col-span-2"${_scopeId}><h4 class="text-md font-semibold text-gray-700 mb-3 mt-4"${_scopeId}> Endereo</h4></div>`);
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).logradouro,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).logradouro = $event,
              label: "Logradouro",
              placeholder: "Rua, Avenida, etc."
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).numero,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).numero = $event,
              label: "Nmero",
              placeholder: "123"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).complemento,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).complemento = $event,
              label: "Complemento",
              placeholder: "Sala, Andar, etc."
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).bairro,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).bairro = $event,
              label: "Bairro"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).municipio,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).municipio = $event,
              label: "Municpio"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiSelect, {
              modelValue: vueExports.unref(form).uf,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).uf = $event,
              options: ufOptions,
              label: "UF",
              placeholder: "Selecione..."
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).cep,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).cep = $event,
              label: "CEP",
              placeholder: "00000-000"
            }, null, _parent2, _scopeId));
            _push2(`<div class="md:col-span-2"${_scopeId}><h4 class="text-md font-semibold text-gray-700 mb-3 mt-4"${_scopeId}> Contatos</h4></div>`);
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).telefone,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).telefone = $event,
              label: "Telefone",
              placeholder: "(11) 3333-4444"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).email_holerites,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).email_holerites = $event,
              type: "email",
              label: "Email para Holerites",
              placeholder: "rh@empresa.com"
            }, null, _parent2, _scopeId));
            _push2(`<div class="md:col-span-2"${_scopeId}><h4 class="text-md font-semibold text-gray-700 mb-3 mt-4"${_scopeId}> Logo da Empresa</h4><div class="flex items-center gap-4"${_scopeId}><div class="w-16 h-16 bg-gray-100 rounded-xl flex items-center justify-center"${_scopeId}>`);
            if (vueExports.unref(form).logo_url) {
              _push2(`<img${ssrRenderAttr_1("src", vueExports.unref(form).logo_url)}${ssrRenderAttr_1("alt", vueExports.unref(form).nome)} class="w-full h-full object-cover rounded-xl"${_scopeId}>`);
            } else {
              _push2(`<span class="text-gray-400 text-2xl"${_scopeId}></span>`);
            }
            _push2(`</div><div class="flex-1"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).logo_url,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).logo_url = $event,
              label: "URL da Logo",
              placeholder: "https://exemplo.com/logo.png"
            }, null, _parent2, _scopeId));
            _push2(`</div></div></div></div></div><div${_scopeId}><h3 class="text-lg font-bold text-gray-800 mb-4"${_scopeId}> Configuraes de Holerites</h3><div class="space-y-4"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: vueExports.unref(form).mostrar_logo,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_logo = $event,
              label: "Mostrar logo nos holerites"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: vueExports.unref(form).mostrar_endereco,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_endereco = $event,
              label: "Mostrar endereo nos holerites"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: vueExports.unref(form).mostrar_cnpj,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_cnpj = $event,
              label: "Mostrar CNPJ nos holerites"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: vueExports.unref(form).mostrar_detalhes_inss,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_detalhes_inss = $event,
              label: "Mostrar detalhamento do clculo de INSS"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: vueExports.unref(form).mostrar_detalhes_irrf,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_detalhes_irrf = $event,
              label: "Mostrar detalhamento do clculo de IRRF"
            }, null, _parent2, _scopeId));
            _push2(`</div></div><div class="flex justify-end gap-3 pt-4 border-t"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "secondary",
              onClick: ($event) => modalAberto.value = false
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Cancelar`);
                } else {
                  return [
                    vueExports.createTextVNode("Cancelar")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              type: "submit",
              icon: ""
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Salvar Empresa`);
                } else {
                  return [
                    vueExports.createTextVNode("Salvar Empresa")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></form>`);
          } else {
            return [
              vueExports.createVNode("form", {
                onSubmit: vueExports.withModifiers(salvarEmpresaForm, ["prevent"]),
                class: "space-y-6"
              }, [
                vueExports.createVNode("div", null, [
                  vueExports.createVNode("h3", { class: "text-lg font-bold text-gray-800 mb-4" }, " Dados da Empresa"),
                  vueExports.createVNode("div", { class: "grid grid-cols-1 md:grid-cols-2 gap-4" }, [
                    vueExports.createVNode("div", { class: "md:col-span-2" }, [
                      vueExports.createVNode(_component_UiInputCNPJ, {
                        modelValue: vueExports.unref(form).cnpj,
                        "onUpdate:modelValue": ($event) => vueExports.unref(form).cnpj = $event,
                        label: "CNPJ",
                        required: "",
                        onDadosEncontrados: preencherDadosEmpresa
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).nome,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).nome = $event,
                      label: "Nome Empresarial (Razo Social)",
                      required: ""
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).nome_fantasia,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).nome_fantasia = $event,
                      label: "Nome Fantasia"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).inscricao_estadual,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).inscricao_estadual = $event,
                      label: "Inscrio Estadual"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).situacao_cadastral,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).situacao_cadastral = $event,
                      label: "Situao Cadastral",
                      disabled: ""
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode("div", { class: "md:col-span-2" }, [
                      vueExports.createVNode("h4", { class: "text-md font-semibold text-gray-700 mb-3 mt-4" }, " Endereo")
                    ]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).logradouro,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).logradouro = $event,
                      label: "Logradouro",
                      placeholder: "Rua, Avenida, etc."
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).numero,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).numero = $event,
                      label: "Nmero",
                      placeholder: "123"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).complemento,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).complemento = $event,
                      label: "Complemento",
                      placeholder: "Sala, Andar, etc."
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).bairro,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).bairro = $event,
                      label: "Bairro"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).municipio,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).municipio = $event,
                      label: "Municpio"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiSelect, {
                      modelValue: vueExports.unref(form).uf,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).uf = $event,
                      options: ufOptions,
                      label: "UF",
                      placeholder: "Selecione..."
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).cep,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).cep = $event,
                      label: "CEP",
                      placeholder: "00000-000"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode("div", { class: "md:col-span-2" }, [
                      vueExports.createVNode("h4", { class: "text-md font-semibold text-gray-700 mb-3 mt-4" }, " Contatos")
                    ]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).telefone,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).telefone = $event,
                      label: "Telefone",
                      placeholder: "(11) 3333-4444"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiInput, {
                      modelValue: vueExports.unref(form).email_holerites,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).email_holerites = $event,
                      type: "email",
                      label: "Email para Holerites",
                      placeholder: "rh@empresa.com"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode("div", { class: "md:col-span-2" }, [
                      vueExports.createVNode("h4", { class: "text-md font-semibold text-gray-700 mb-3 mt-4" }, " Logo da Empresa"),
                      vueExports.createVNode("div", { class: "flex items-center gap-4" }, [
                        vueExports.createVNode("div", { class: "w-16 h-16 bg-gray-100 rounded-xl flex items-center justify-center" }, [
                          vueExports.unref(form).logo_url ? (vueExports.openBlock(), vueExports.createBlock("img", {
                            key: 0,
                            src: vueExports.unref(form).logo_url,
                            alt: vueExports.unref(form).nome,
                            class: "w-full h-full object-cover rounded-xl"
                          }, null, 8, ["src", "alt"])) : (vueExports.openBlock(), vueExports.createBlock("span", {
                            key: 1,
                            class: "text-gray-400 text-2xl"
                          }, ""))
                        ]),
                        vueExports.createVNode("div", { class: "flex-1" }, [
                          vueExports.createVNode(_component_UiInput, {
                            modelValue: vueExports.unref(form).logo_url,
                            "onUpdate:modelValue": ($event) => vueExports.unref(form).logo_url = $event,
                            label: "URL da Logo",
                            placeholder: "https://exemplo.com/logo.png"
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ])
                      ])
                    ])
                  ])
                ]),
                vueExports.createVNode("div", null, [
                  vueExports.createVNode("h3", { class: "text-lg font-bold text-gray-800 mb-4" }, " Configuraes de Holerites"),
                  vueExports.createVNode("div", { class: "space-y-4" }, [
                    vueExports.createVNode(_component_UiCheckbox, {
                      modelValue: vueExports.unref(form).mostrar_logo,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_logo = $event,
                      label: "Mostrar logo nos holerites"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiCheckbox, {
                      modelValue: vueExports.unref(form).mostrar_endereco,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_endereco = $event,
                      label: "Mostrar endereo nos holerites"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiCheckbox, {
                      modelValue: vueExports.unref(form).mostrar_cnpj,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_cnpj = $event,
                      label: "Mostrar CNPJ nos holerites"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiCheckbox, {
                      modelValue: vueExports.unref(form).mostrar_detalhes_inss,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_detalhes_inss = $event,
                      label: "Mostrar detalhamento do clculo de INSS"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                    vueExports.createVNode(_component_UiCheckbox, {
                      modelValue: vueExports.unref(form).mostrar_detalhes_irrf,
                      "onUpdate:modelValue": ($event) => vueExports.unref(form).mostrar_detalhes_irrf = $event,
                      label: "Mostrar detalhamento do clculo de IRRF"
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ])
                ]),
                vueExports.createVNode("div", { class: "flex justify-end gap-3 pt-4 border-t" }, [
                  vueExports.createVNode(_component_UiButton, {
                    variant: "secondary",
                    onClick: ($event) => modalAberto.value = false
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode("Cancelar")
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  vueExports.createVNode(_component_UiButton, {
                    type: "submit",
                    icon: ""
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode("Salvar Empresa")
                    ]),
                    _: 1
                  })
                ])
              ], 32)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalTabelasAberto),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalTabelasAberto) ? modalTabelasAberto.value = $event : null,
        title: " Tabelas de INSS e IRRF (2026)",
        "max-width": "max-w-4xl"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="space-y-6"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiAlert, { variant: "info" }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` As tabelas de INSS e IRRF so atualizadas anualmente pelo governo. O sistema permite atualizao fcil sem necessidade de alterao no cdigo. `);
                } else {
                  return [
                    vueExports.createTextVNode(" As tabelas de INSS e IRRF so atualizadas anualmente pelo governo. O sistema permite atualizao fcil sem necessidade de alterao no cdigo. ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`<div class="grid grid-cols-1 lg:grid-cols-2 gap-6"${_scopeId}><div${_scopeId}><h3 class="text-lg font-bold text-gray-800 mb-4"${_scopeId}>INSS - Tabela Progressiva</h3><div class="border rounded-xl overflow-hidden"${_scopeId}><table class="w-full text-sm"${_scopeId}><thead class="bg-gray-50"${_scopeId}><tr${_scopeId}><th class="px-4 py-3 text-left font-semibold text-gray-600"${_scopeId}>Faixa Salarial</th><th class="px-4 py-3 text-right font-semibold text-gray-600"${_scopeId}>Alquota</th></tr></thead><tbody class="divide-y"${_scopeId}><!--[-->`);
            ssrRenderList_1(tabelaINSS, (faixa) => {
              _push2(`<tr${_scopeId}><td class="px-4 py-3"${_scopeId}>${ssrInterpolate_1(faixa.faixa)}</td><td class="px-4 py-3 text-right font-semibold"${_scopeId}>${ssrInterpolate_1(faixa.aliquota)}%</td></tr>`);
            });
            _push2(`<!--]--></tbody></table></div></div><div${_scopeId}><h3 class="text-lg font-bold text-gray-800 mb-4"${_scopeId}>IRRF - Tabela Progressiva</h3><div class="border rounded-xl overflow-hidden"${_scopeId}><table class="w-full text-sm"${_scopeId}><thead class="bg-gray-50"${_scopeId}><tr${_scopeId}><th class="px-4 py-3 text-left font-semibold text-gray-600"${_scopeId}>Base de Clculo</th><th class="px-4 py-3 text-right font-semibold text-gray-600"${_scopeId}>Alquota</th></tr></thead><tbody class="divide-y"${_scopeId}><!--[-->`);
            ssrRenderList_1(tabelaIRRF, (faixa) => {
              _push2(`<tr${_scopeId}><td class="px-4 py-3"${_scopeId}>${ssrInterpolate_1(faixa.faixa)}</td><td class="px-4 py-3 text-right font-semibold"${_scopeId}>${ssrInterpolate_1(faixa.aliquota)}</td></tr>`);
            });
            _push2(`<!--]--></tbody></table></div></div></div><div class="flex justify-between pt-4 border-t"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiBadge, { variant: "success" }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Tabelas Atualizadas para 2026`);
                } else {
                  return [
                    vueExports.createTextVNode(" Tabelas Atualizadas para 2026")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "ghost",
              onClick: ($event) => modalTabelasAberto.value = false
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Fechar`);
                } else {
                  return [
                    vueExports.createTextVNode("Fechar")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "space-y-6" }, [
                vueExports.createVNode(_component_UiAlert, { variant: "info" }, {
                  default: vueExports.withCtx(() => [
                    vueExports.createTextVNode(" As tabelas de INSS e IRRF so atualizadas anualmente pelo governo. O sistema permite atualizao fcil sem necessidade de alterao no cdigo. ")
                  ]),
                  _: 1
                }),
                vueExports.createVNode("div", { class: "grid grid-cols-1 lg:grid-cols-2 gap-6" }, [
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("h3", { class: "text-lg font-bold text-gray-800 mb-4" }, "INSS - Tabela Progressiva"),
                    vueExports.createVNode("div", { class: "border rounded-xl overflow-hidden" }, [
                      vueExports.createVNode("table", { class: "w-full text-sm" }, [
                        vueExports.createVNode("thead", { class: "bg-gray-50" }, [
                          vueExports.createVNode("tr", null, [
                            vueExports.createVNode("th", { class: "px-4 py-3 text-left font-semibold text-gray-600" }, "Faixa Salarial"),
                            vueExports.createVNode("th", { class: "px-4 py-3 text-right font-semibold text-gray-600" }, "Alquota")
                          ])
                        ]),
                        vueExports.createVNode("tbody", { class: "divide-y" }, [
                          (vueExports.openBlock(), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(tabelaINSS, (faixa) => {
                            return vueExports.createVNode("tr", {
                              key: faixa.id
                            }, [
                              vueExports.createVNode("td", { class: "px-4 py-3" }, vueExports.toDisplayString(faixa.faixa), 1),
                              vueExports.createVNode("td", { class: "px-4 py-3 text-right font-semibold" }, vueExports.toDisplayString(faixa.aliquota) + "%", 1)
                            ]);
                          }), 64))
                        ])
                      ])
                    ])
                  ]),
                  vueExports.createVNode("div", null, [
                    vueExports.createVNode("h3", { class: "text-lg font-bold text-gray-800 mb-4" }, "IRRF - Tabela Progressiva"),
                    vueExports.createVNode("div", { class: "border rounded-xl overflow-hidden" }, [
                      vueExports.createVNode("table", { class: "w-full text-sm" }, [
                        vueExports.createVNode("thead", { class: "bg-gray-50" }, [
                          vueExports.createVNode("tr", null, [
                            vueExports.createVNode("th", { class: "px-4 py-3 text-left font-semibold text-gray-600" }, "Base de Clculo"),
                            vueExports.createVNode("th", { class: "px-4 py-3 text-right font-semibold text-gray-600" }, "Alquota")
                          ])
                        ]),
                        vueExports.createVNode("tbody", { class: "divide-y" }, [
                          (vueExports.openBlock(), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(tabelaIRRF, (faixa) => {
                            return vueExports.createVNode("tr", {
                              key: faixa.id
                            }, [
                              vueExports.createVNode("td", { class: "px-4 py-3" }, vueExports.toDisplayString(faixa.faixa), 1),
                              vueExports.createVNode("td", { class: "px-4 py-3 text-right font-semibold" }, vueExports.toDisplayString(faixa.aliquota), 1)
                            ]);
                          }), 64))
                        ])
                      ])
                    ])
                  ])
                ]),
                vueExports.createVNode("div", { class: "flex justify-between pt-4 border-t" }, [
                  vueExports.createVNode(_component_UiBadge, { variant: "success" }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(" Tabelas Atualizadas para 2026")
                    ]),
                    _: 1
                  }),
                  vueExports.createVNode(_component_UiButton, {
                    variant: "ghost",
                    onClick: ($event) => modalTabelasAberto.value = false
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode("Fechar")
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiNotification, {
        show: vueExports.unref(mostrarNotificacao),
        title: vueExports.unref(notificacao).title,
        message: vueExports.unref(notificacao).message,
        variant: vueExports.unref(notificacao).variant,
        onClose: ($event) => mostrarNotificacao.value = false
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$a = _sfc_main$a.setup;
_sfc_main$a.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/empresas.vue");
  return _sfc_setup$a ? _sfc_setup$a(props, ctx) : void 0;
};

const empresasBLadY5Os = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$a
}, Symbol.toStringTag, { value: 'Module' }));

const useJornadas = () => {
  const jornadas = vueExports.ref([]);
  const loading = vueExports.ref(false);
  const error = vueExports.ref("");
  const diasSemana = [
    { id: 1, nome: "Segunda-feira", abrev: "Seg" },
    { id: 2, nome: "Tera-feira", abrev: "Ter" },
    { id: 3, nome: "Quarta-feira", abrev: "Qua" },
    { id: 4, nome: "Quinta-feira", abrev: "Qui" },
    { id: 5, nome: "Sexta-feira", abrev: "Sex" },
    { id: 6, nome: "Sbado", abrev: "Sb" },
    { id: 7, nome: "Domingo", abrev: "Dom" }
  ];
  const carregarJornadas = async () => {
    console.log(" [useJornadas] Carregando jornadas...");
    loading.value = true;
    error.value = "";
    try {
      const response = await $fetch("/api/jornadas");
      console.log(" [useJornadas] Resposta recebida:", response);
      if (response.success && response.data) {
        jornadas.value = response.data;
        console.log(" [useJornadas] Jornadas carregadas:", jornadas.value.length);
        return { success: true, message: "Jornadas carregadas com sucesso!" };
      }
      console.log(" [useJornadas] Resposta sem sucesso");
      return { success: false, message: "Erro ao carregar jornadas" };
    } catch (err) {
      error.value = err.data?.message || "Erro ao carregar jornadas";
      console.error(" [useJornadas] Erro ao carregar jornadas:", err);
      jornadas.value = [
        {
          id: "1",
          nome: "Jornada 42h45min",
          descricao: "Jornada personalizada: Segunda a quinta 8h45min, sexta 7h45min",
          horas_semanais: 42.75,
          horas_mensais: 185.25,
          ativa: true,
          padrao: true,
          created_at: "2026-01-13T10:00:00Z",
          updated_at: "2026-01-13T10:00:00Z",
          horarios: []
        }
      ];
      console.log(" [useJornadas] Usando dados de fallback");
      return { success: false, message: error.value };
    } finally {
      loading.value = false;
    }
  };
  const salvarJornada = async (jornada) => {
    loading.value = true;
    try {
      const response = await $fetch("/api/jornadas", {
        method: "POST",
        body: jornada
      });
      if (response.success) {
        await carregarJornadas();
        return { success: true, message: response.message || "Jornada salva com sucesso!" };
      }
      return { success: false, message: "Erro ao salvar jornada" };
    } catch (err) {
      console.error("Erro ao salvar jornada:", err);
      return { success: false, message: err.data?.message || "Erro ao salvar jornada" };
    } finally {
      loading.value = false;
    }
  };
  const obterJornada = (id) => {
    return jornadas.value.find((j) => j.id === id);
  };
  const obterJornadaPadrao = () => {
    return jornadas.value.find((j) => j.padrao && j.ativa);
  };
  const opcoesJornadas = vueExports.computed(() => {
    return jornadas.value.filter((j) => j.ativa).map((j) => ({
      value: j.id,
      label: `${j.nome} (${j.horas_semanais}h semanais)`
    }));
  });
  const formatarHorario = (horario) => {
    if (!horario || horario === "00:00") return "--";
    return horario.substring(0, 5);
  };
  const formatarHorasDecimais = (horas) => {
    if (horas === 0) return "0h";
    const horasInteiras = Math.floor(horas);
    const minutos = Math.round((horas - horasInteiras) * 60);
    if (minutos === 0) {
      return `${horasInteiras}h`;
    }
    return `${horasInteiras}h${minutos.toString().padStart(2, "0")}min`;
  };
  const calcularHorasSemanais = (horarios) => {
    return horarios.filter((h) => h.trabalha).reduce((total, h) => total + h.horas_liquidas, 0);
  };
  const calcularHorasMensais = (horasSemanais) => {
    return horasSemanais * 4.33;
  };
  const obterNomeDia = (diaSemana) => {
    const dia = diasSemana.find((d) => d.id === diaSemana);
    return dia ? dia.nome : "Desconhecido";
  };
  const obterAbrevDia = (diaSemana) => {
    const dia = diasSemana.find((d) => d.id === diaSemana);
    return dia ? dia.abrev : "?";
  };
  const validarJornada = (horarios) => {
    const erros = [];
    horarios.forEach((horario) => {
      if (!horario.trabalha) return;
      if (horario.entrada >= horario.saida) {
        erros.push(`${obterNomeDia(horario.dia_semana)}: Horrio de entrada deve ser anterior ao de sada`);
      }
      if (horario.intervalo_inicio && horario.intervalo_fim) {
        if (horario.intervalo_inicio >= horario.intervalo_fim) {
          erros.push(`${obterNomeDia(horario.dia_semana)}: Incio do intervalo deve ser anterior ao fim`);
        }
        if (horario.intervalo_inicio <= horario.entrada || horario.intervalo_fim >= horario.saida) {
          erros.push(`${obterNomeDia(horario.dia_semana)}: Intervalo deve estar dentro do horrio de trabalho`);
        }
      }
    });
    return {
      valida: erros.length === 0,
      erros
    };
  };
  return {
    // Estado
    jornadas: vueExports.readonly(jornadas),
    loading: vueExports.readonly(loading),
    error: vueExports.readonly(error),
    // Dados auxiliares
    diasSemana,
    opcoesJornadas,
    // Mtodos
    carregarJornadas,
    salvarJornada,
    obterJornada,
    obterJornadaPadrao,
    formatarHorario,
    formatarHorasDecimais,
    calcularHorasSemanais,
    calcularHorasMensais,
    obterNomeDia,
    obterAbrevDia,
    validarJornada
  };
};

const _sfc_main$2$2 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "JornadaVisualizacao",
  __ssrInlineRender: true,
  props: {
    jornada: {},
    mostrarObservacoes: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const {
      formatarHorario,
      formatarHorasDecimais,
      obterNomeDia,
      obterAbrevDia
    } = useJornadas();
    const horariosOrdenados = vueExports.computed(() => {
      if (!props.jornada.horarios) return [];
      return [...props.jornada.horarios].sort((a, b) => a.dia_semana - b.dia_semana);
    });
    const diasTrabalhados = vueExports.computed(() => {
      if (!props.jornada.horarios) return 0;
      return props.jornada.horarios.filter((h) => h.trabalha).length;
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiBadge = __nuxt_component_2$2;
      const _component_UiCard = __nuxt_component_2$1;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-xl border border-blue-200"><div class="flex items-center justify-between"><div><h3 class="text-xl font-bold text-gray-800 flex items-center gap-2">  ${ssrInterpolate_1(__props.jornada.nome)} `);
      if (__props.jornada.padrao) {
        _push(ssrRenderComponent_1(_component_UiBadge, { variant: "primary" }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Padro`);
            } else {
              return [
                vueExports.createTextVNode("Padro")
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</h3><p class="text-gray-600 mt-1">${ssrInterpolate_1(__props.jornada.descricao)}</p></div><div class="text-right"><div class="text-2xl font-bold text-blue-600">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(__props.jornada.horas_semanais))}</div><div class="text-sm text-gray-500">por semana</div></div></div><div class="mt-4 pt-4 border-t border-blue-200"><div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center"><div><div class="text-lg font-semibold text-gray-800">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(__props.jornada.horas_semanais))}</div><div class="text-sm text-gray-500">Horas Semanais</div></div><div><div class="text-lg font-semibold text-gray-800">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(__props.jornada.horas_mensais))}</div><div class="text-sm text-gray-500">Horas Mensais</div></div><div><div class="text-lg font-semibold text-gray-800">${ssrInterpolate_1(vueExports.unref(diasTrabalhados))}/7 </div><div class="text-sm text-gray-500">Dias por Semana</div></div></div></div></div>`);
      _push(ssrRenderComponent_1(_component_UiCard, null, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="p-6"${_scopeId}><h4 class="text-lg font-bold text-gray-800 mb-4"${_scopeId}> Horrios Detalhados</h4><div class="space-y-3"${_scopeId}><!--[-->`);
            ssrRenderList_1(vueExports.unref(horariosOrdenados), (horario) => {
              _push2(`<div class="${ssrRenderClass_1([
                "flex items-center justify-between p-4 rounded-xl border-2 transition-colors",
                horario.trabalha ? "border-green-200 bg-green-50" : "border-gray-200 bg-gray-50"
              ])}"${_scopeId}><div class="flex items-center gap-3"${_scopeId}><div class="${ssrRenderClass_1([
                "w-12 h-12 rounded-full flex items-center justify-center font-bold text-sm",
                horario.trabalha ? "bg-green-500 text-white" : "bg-gray-400 text-white"
              ])}"${_scopeId}>${ssrInterpolate_1(vueExports.unref(obterAbrevDia)(horario.dia_semana))}</div><div${_scopeId}><div class="font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(vueExports.unref(obterNomeDia)(horario.dia_semana))}</div>`);
              if (!horario.trabalha) {
                _push2(`<div class="text-sm text-gray-500"${_scopeId}> No trabalha </div>`);
              } else {
                _push2(`<div class="text-sm text-gray-600"${_scopeId}>${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(horario.horas_liquidas))} lquidas </div>`);
              }
              _push2(`</div></div>`);
              if (horario.trabalha) {
                _push2(`<div class="flex items-center gap-6 text-sm"${_scopeId}><div class="text-center"${_scopeId}><div class="font-semibold text-gray-800"${_scopeId}>${ssrInterpolate_1(vueExports.unref(formatarHorario)(horario.entrada))} - ${ssrInterpolate_1(vueExports.unref(formatarHorario)(horario.saida))}</div><div class="text-gray-500"${_scopeId}>Expediente</div></div>`);
                if (horario.intervalo_inicio && horario.intervalo_fim) {
                  _push2(`<div class="text-center"${_scopeId}><div class="font-semibold text-orange-600"${_scopeId}>${ssrInterpolate_1(vueExports.unref(formatarHorario)(horario.intervalo_inicio))} - ${ssrInterpolate_1(vueExports.unref(formatarHorario)(horario.intervalo_fim))}</div><div class="text-gray-500"${_scopeId}> Intervalo (${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(horario.horas_intervalo))}) </div></div>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`<div class="text-center"${_scopeId}><div class="font-semibold text-blue-600"${_scopeId}>${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(horario.horas_brutas))}</div><div class="text-gray-500"${_scopeId}>Total</div></div></div>`);
              } else {
                _push2(`<div class="flex items-center gap-2 text-gray-500"${_scopeId}><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"${_scopeId}></path></svg><span${_scopeId}>Folga</span></div>`);
              }
              _push2(`</div>`);
            });
            _push2(`<!--]--></div></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "p-6" }, [
                vueExports.createVNode("h4", { class: "text-lg font-bold text-gray-800 mb-4" }, " Horrios Detalhados"),
                vueExports.createVNode("div", { class: "space-y-3" }, [
                  (vueExports.openBlock(true), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(vueExports.unref(horariosOrdenados), (horario) => {
                    return vueExports.openBlock(), vueExports.createBlock("div", {
                      key: horario.dia_semana,
                      class: [
                        "flex items-center justify-between p-4 rounded-xl border-2 transition-colors",
                        horario.trabalha ? "border-green-200 bg-green-50" : "border-gray-200 bg-gray-50"
                      ]
                    }, [
                      vueExports.createVNode("div", { class: "flex items-center gap-3" }, [
                        vueExports.createVNode("div", {
                          class: [
                            "w-12 h-12 rounded-full flex items-center justify-center font-bold text-sm",
                            horario.trabalha ? "bg-green-500 text-white" : "bg-gray-400 text-white"
                          ]
                        }, vueExports.toDisplayString(vueExports.unref(obterAbrevDia)(horario.dia_semana)), 3),
                        vueExports.createVNode("div", null, [
                          vueExports.createVNode("div", { class: "font-semibold text-gray-800" }, vueExports.toDisplayString(vueExports.unref(obterNomeDia)(horario.dia_semana)), 1),
                          !horario.trabalha ? (vueExports.openBlock(), vueExports.createBlock("div", {
                            key: 0,
                            class: "text-sm text-gray-500"
                          }, " No trabalha ")) : (vueExports.openBlock(), vueExports.createBlock("div", {
                            key: 1,
                            class: "text-sm text-gray-600"
                          }, vueExports.toDisplayString(vueExports.unref(formatarHorasDecimais)(horario.horas_liquidas)) + " lquidas ", 1))
                        ])
                      ]),
                      horario.trabalha ? (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 0,
                        class: "flex items-center gap-6 text-sm"
                      }, [
                        vueExports.createVNode("div", { class: "text-center" }, [
                          vueExports.createVNode("div", { class: "font-semibold text-gray-800" }, vueExports.toDisplayString(vueExports.unref(formatarHorario)(horario.entrada)) + " - " + vueExports.toDisplayString(vueExports.unref(formatarHorario)(horario.saida)), 1),
                          vueExports.createVNode("div", { class: "text-gray-500" }, "Expediente")
                        ]),
                        horario.intervalo_inicio && horario.intervalo_fim ? (vueExports.openBlock(), vueExports.createBlock("div", {
                          key: 0,
                          class: "text-center"
                        }, [
                          vueExports.createVNode("div", { class: "font-semibold text-orange-600" }, vueExports.toDisplayString(vueExports.unref(formatarHorario)(horario.intervalo_inicio)) + " - " + vueExports.toDisplayString(vueExports.unref(formatarHorario)(horario.intervalo_fim)), 1),
                          vueExports.createVNode("div", { class: "text-gray-500" }, " Intervalo (" + vueExports.toDisplayString(vueExports.unref(formatarHorasDecimais)(horario.horas_intervalo)) + ") ", 1)
                        ])) : vueExports.createCommentVNode("", true),
                        vueExports.createVNode("div", { class: "text-center" }, [
                          vueExports.createVNode("div", { class: "font-semibold text-blue-600" }, vueExports.toDisplayString(vueExports.unref(formatarHorasDecimais)(horario.horas_brutas)), 1),
                          vueExports.createVNode("div", { class: "text-gray-500" }, "Total")
                        ])
                      ])) : (vueExports.openBlock(), vueExports.createBlock("div", {
                        key: 1,
                        class: "flex items-center gap-2 text-gray-500"
                      }, [
                        (vueExports.openBlock(), vueExports.createBlock("svg", {
                          class: "w-5 h-5",
                          fill: "none",
                          stroke: "currentColor",
                          viewBox: "0 0 24 24"
                        }, [
                          vueExports.createVNode("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            "stroke-width": "2",
                            d: "M20 12H4"
                          })
                        ])),
                        vueExports.createVNode("span", null, "Folga")
                      ]))
                    ], 2);
                  }), 128))
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      if (__props.mostrarObservacoes) {
        _push(ssrRenderComponent_1(_component_UiCard, null, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="p-6"${_scopeId}><h4 class="text-lg font-bold text-gray-800 mb-4"${_scopeId}> Observaes</h4><div class="space-y-3 text-sm"${_scopeId}><div class="flex items-start gap-2"${_scopeId}><span class="text-blue-500"${_scopeId}></span><span${_scopeId}>O intervalo de almoo no  contabilizado na carga horria.</span></div><div class="flex items-start gap-2"${_scopeId}><span class="text-green-500"${_scopeId}></span><span${_scopeId}>Sexta-feira possui jornada reduzida conforme configurao.</span></div><div class="flex items-start gap-2"${_scopeId}><span class="text-orange-500"${_scopeId}></span><span${_scopeId}>Esta jornada  configurada pelo RH e no pode ser alterada pelo funcionrio.</span></div><div class="flex items-start gap-2"${_scopeId}><span class="text-purple-500"${_scopeId}></span><span${_scopeId}>O clculo mensal considera 4,33 semanas por ms em mdia.</span></div></div></div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "p-6" }, [
                  vueExports.createVNode("h4", { class: "text-lg font-bold text-gray-800 mb-4" }, " Observaes"),
                  vueExports.createVNode("div", { class: "space-y-3 text-sm" }, [
                    vueExports.createVNode("div", { class: "flex items-start gap-2" }, [
                      vueExports.createVNode("span", { class: "text-blue-500" }, ""),
                      vueExports.createVNode("span", null, "O intervalo de almoo no  contabilizado na carga horria.")
                    ]),
                    vueExports.createVNode("div", { class: "flex items-start gap-2" }, [
                      vueExports.createVNode("span", { class: "text-green-500" }, ""),
                      vueExports.createVNode("span", null, "Sexta-feira possui jornada reduzida conforme configurao.")
                    ]),
                    vueExports.createVNode("div", { class: "flex items-start gap-2" }, [
                      vueExports.createVNode("span", { class: "text-orange-500" }, ""),
                      vueExports.createVNode("span", null, "Esta jornada  configurada pelo RH e no pode ser alterada pelo funcionrio.")
                    ]),
                    vueExports.createVNode("div", { class: "flex items-start gap-2" }, [
                      vueExports.createVNode("span", { class: "text-purple-500" }, ""),
                      vueExports.createVNode("span", null, "O clculo mensal considera 4,33 semanas por ms em mdia.")
                    ])
                  ])
                ])
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$2$2 = _sfc_main$2$2.setup;
_sfc_main$2$2.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/jornadas/JornadaVisualizacao.vue");
  return _sfc_setup$2$2 ? _sfc_setup$2$2(props, ctx) : void 0;
};
const JornadaVisualizacao = Object.assign(_sfc_main$2$2, { __name: "JornadasJornadaVisualizacao" });
const _sfc_main$1$4 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "JornadaForm",
  __ssrInlineRender: true,
  props: {
    jornada: {}
  },
  emits: ["salvar", "cancelar"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const {
      diasSemana,
      formatarHorasDecimais,
      obterNomeDia,
      obterAbrevDia,
      validarJornada
    } = useJornadas();
    const form = vueExports.ref({
      nome: "",
      descricao: "",
      ativa: true,
      padrao: false,
      horarios: []
    });
    const inicializarForm = () => {
      if (props.jornada) {
        form.value = {
          nome: props.jornada.nome,
          descricao: props.jornada.descricao || "",
          ativa: props.jornada.ativa,
          padrao: props.jornada.padrao,
          horarios: props.jornada.horarios ? [...props.jornada.horarios] : criarHorariosVazios()
        };
      } else {
        form.value = {
          nome: "",
          descricao: "",
          ativa: true,
          padrao: false,
          horarios: criarHorariosVazios()
        };
      }
    };
    const criarHorariosVazios = () => {
      return diasSemana.map((dia) => ({
        id: "",
        jornada_id: "",
        dia_semana: dia.id,
        entrada: "08:00",
        saida: "17:00",
        intervalo_inicio: "12:00",
        intervalo_fim: "13:00",
        horas_brutas: 0,
        horas_intervalo: 0,
        horas_liquidas: 0,
        trabalha: dia.id <= 5
        // Segunda a sexta por padro
      }));
    };
    const recalcularHoras = (index) => {
      const horario = form.value.horarios[index];
      if (!horario) return;
      if (!horario.trabalha) {
        horario.horas_brutas = 0;
        horario.horas_intervalo = 0;
        horario.horas_liquidas = 0;
        return;
      }
      const entrada = /* @__PURE__ */ new Date(`2000-01-01T${horario.entrada}:00`);
      const saida = /* @__PURE__ */ new Date(`2000-01-01T${horario.saida}:00`);
      horario.horas_brutas = (saida.getTime() - entrada.getTime()) / (1e3 * 60 * 60);
      if (horario.intervalo_inicio && horario.intervalo_fim) {
        const inicioIntervalo = /* @__PURE__ */ new Date(`2000-01-01T${horario.intervalo_inicio}:00`);
        const fimIntervalo = /* @__PURE__ */ new Date(`2000-01-01T${horario.intervalo_fim}:00`);
        horario.horas_intervalo = (fimIntervalo.getTime() - inicioIntervalo.getTime()) / (1e3 * 60 * 60);
      } else {
        horario.horas_intervalo = 0;
      }
      horario.horas_liquidas = Math.max(0, horario.horas_brutas - horario.horas_intervalo);
    };
    const totalSemanal = vueExports.computed(() => {
      return form.value.horarios.filter((h) => h.trabalha).reduce((total, h) => total + h.horas_liquidas, 0);
    });
    const totalMensal = vueExports.computed(() => {
      return totalSemanal.value * 4.33;
    });
    const diasTrabalhados = vueExports.computed(() => {
      return form.value.horarios.filter((h) => h.trabalha).length;
    });
    const errosValidacao = vueExports.computed(() => {
      const validacao = validarJornada(form.value.horarios);
      const erros = [...validacao.erros];
      if (!form.value.nome.trim()) {
        erros.push("Nome da jornada  obrigatrio");
      }
      if (totalSemanal.value === 0) {
        erros.push("A jornada deve ter pelo menos um dia de trabalho");
      }
      return erros;
    });
    vueExports.watch(() => props.jornada, inicializarForm);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiInput = __nuxt_component_4;
      const _component_UiCheckbox = __nuxt_component_0$2;
      const _component_UiAlert = __nuxt_component_1$1;
      const _component_UiButton = __nuxt_component_1$4;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-6" }, _attrs))}><form><div class="space-y-4"><h3 class="text-lg font-bold text-gray-800 mb-4"> Informaes Bsicas</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4">`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: vueExports.unref(form).nome,
        "onUpdate:modelValue": ($event) => vueExports.unref(form).nome = $event,
        label: "Nome da Jornada",
        required: "",
        placeholder: "Ex: Jornada 42h45min"
      }, null, _parent));
      _push(`<div class="flex gap-4">`);
      _push(ssrRenderComponent_1(_component_UiCheckbox, {
        modelValue: vueExports.unref(form).ativa,
        "onUpdate:modelValue": ($event) => vueExports.unref(form).ativa = $event,
        label: "Jornada Ativa"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiCheckbox, {
        modelValue: vueExports.unref(form).padrao,
        "onUpdate:modelValue": ($event) => vueExports.unref(form).padrao = $event,
        label: "Jornada Padro"
      }, null, _parent));
      _push(`</div></div>`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: vueExports.unref(form).descricao,
        "onUpdate:modelValue": ($event) => vueExports.unref(form).descricao = $event,
        label: "Descrio",
        placeholder: "Descreva as caractersticas desta jornada"
      }, null, _parent));
      _push(`</div><div class="space-y-4 mt-8"><h3 class="text-lg font-bold text-gray-800 mb-4"> Horrios por Dia da Semana</h3><div class="space-y-4"><!--[-->`);
      ssrRenderList_1(vueExports.unref(form).horarios, (horario, index) => {
        _push(`<div class="p-4 border border-gray-200 rounded-xl"><div class="flex items-center justify-between mb-4"><div class="flex items-center gap-3"><div class="${ssrRenderClass_1([
          "w-10 h-10 rounded-full flex items-center justify-center font-bold text-sm",
          horario.trabalha ? "bg-green-500 text-white" : "bg-gray-400 text-white"
        ])}">${ssrInterpolate_1(vueExports.unref(obterAbrevDia)(horario.dia_semana))}</div><div><h4 class="font-semibold text-gray-800">${ssrInterpolate_1(vueExports.unref(obterNomeDia)(horario.dia_semana))}</h4>`);
        if (horario.trabalha) {
          _push(`<p class="text-sm text-gray-600">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(horario.horas_liquidas))} lquidas </p>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div></div>`);
        _push(ssrRenderComponent_1(_component_UiCheckbox, {
          modelValue: horario.trabalha,
          "onUpdate:modelValue": ($event) => horario.trabalha = $event,
          label: "Trabalha neste dia",
          onChange: ($event) => recalcularHoras(index)
        }, null, _parent));
        _push(`</div>`);
        if (horario.trabalha) {
          _push(`<div class="grid grid-cols-1 md:grid-cols-4 gap-4">`);
          _push(ssrRenderComponent_1(_component_UiInput, {
            modelValue: horario.entrada,
            "onUpdate:modelValue": ($event) => horario.entrada = $event,
            type: "time",
            label: "Entrada",
            required: "",
            onChange: ($event) => recalcularHoras(index)
          }, null, _parent));
          _push(ssrRenderComponent_1(_component_UiInput, {
            modelValue: horario.saida,
            "onUpdate:modelValue": ($event) => horario.saida = $event,
            type: "time",
            label: "Sada",
            required: "",
            onChange: ($event) => recalcularHoras(index)
          }, null, _parent));
          _push(ssrRenderComponent_1(_component_UiInput, {
            "model-value": horario.intervalo_inicio || "",
            "onUpdate:modelValue": ($event) => horario.intervalo_inicio = $event || void 0,
            type: "time",
            label: "Incio Intervalo",
            onChange: ($event) => recalcularHoras(index)
          }, null, _parent));
          _push(ssrRenderComponent_1(_component_UiInput, {
            "model-value": horario.intervalo_fim || "",
            "onUpdate:modelValue": ($event) => horario.intervalo_fim = $event || void 0,
            type: "time",
            label: "Fim Intervalo",
            onChange: ($event) => recalcularHoras(index)
          }, null, _parent));
          _push(`</div>`);
        } else {
          _push(`<!---->`);
        }
        if (horario.trabalha) {
          _push(`<div class="mt-4 p-3 bg-gray-50 rounded-lg"><div class="grid grid-cols-3 gap-4 text-center text-sm"><div><div class="font-semibold text-blue-600">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(horario.horas_brutas))}</div><div class="text-gray-500">Horas Brutas</div></div><div><div class="font-semibold text-orange-600">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(horario.horas_intervalo))}</div><div class="text-gray-500">Intervalo</div></div><div><div class="font-semibold text-green-600">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(horario.horas_liquidas))}</div><div class="text-gray-500">Horas Lquidas</div></div></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      });
      _push(`<!--]--></div></div><div class="mt-8 p-6 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl border border-blue-200"><h3 class="text-lg font-bold text-gray-800 mb-4"> Resumo Total</h3><div class="grid grid-cols-1 md:grid-cols-3 gap-6 text-center"><div><div class="text-2xl font-bold text-blue-600">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(vueExports.unref(totalSemanal)))}</div><div class="text-sm text-gray-600">Horas Semanais</div></div><div><div class="text-2xl font-bold text-green-600">${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(vueExports.unref(totalMensal)))}</div><div class="text-sm text-gray-600">Horas Mensais</div></div><div><div class="text-2xl font-bold text-purple-600">${ssrInterpolate_1(vueExports.unref(diasTrabalhados))}/7 </div><div class="text-sm text-gray-600">Dias por Semana</div></div></div></div>`);
      if (vueExports.unref(errosValidacao).length > 0) {
        _push(`<div class="mt-6">`);
        _push(ssrRenderComponent_1(_component_UiAlert, {
          variant: "error",
          title: "Erros de Validao"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<ul class="list-disc list-inside space-y-1"${_scopeId}><!--[-->`);
              ssrRenderList_1(vueExports.unref(errosValidacao), (erro) => {
                _push2(`<li${_scopeId}>${ssrInterpolate_1(erro)}</li>`);
              });
              _push2(`<!--]--></ul>`);
            } else {
              return [
                vueExports.createVNode("ul", { class: "list-disc list-inside space-y-1" }, [
                  (vueExports.openBlock(true), vueExports.createBlock(vueExports.Fragment, null, vueExports.renderList(vueExports.unref(errosValidacao), (erro) => {
                    return vueExports.openBlock(), vueExports.createBlock("li", { key: erro }, vueExports.toDisplayString(erro), 1);
                  }), 128))
                ])
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="flex justify-end gap-3 pt-6 border-t mt-8">`);
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "secondary",
        onClick: ($event) => _ctx.$emit("cancelar")
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(` Cancelar `);
          } else {
            return [
              vueExports.createTextVNode(" Cancelar ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiButton, {
        type: "submit",
        disabled: vueExports.unref(errosValidacao).length > 0
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  ${ssrInterpolate_1(__props.jornada ? "Atualizar" : "Criar")} Jornada `);
          } else {
            return [
              vueExports.createTextVNode("  " + vueExports.toDisplayString(__props.jornada ? "Atualizar" : "Criar") + " Jornada ", 1)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></form></div>`);
    };
  }
});
const _sfc_setup$1$4 = _sfc_main$1$4.setup;
_sfc_main$1$4.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/jornadas/JornadaForm.vue");
  return _sfc_setup$1$4 ? _sfc_setup$1$4(props, ctx) : void 0;
};
const JornadaForm = Object.assign(_sfc_main$1$4, { __name: "JornadasJornadaForm" });
const _sfc_main$9 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "jornadas",
  __ssrInlineRender: true,
  setup(__props) {
    const {
      jornadas,
      salvarJornada: salvarJornadaComposable,
      formatarHorasDecimais
    } = useJornadas();
    const modalVisualizacao = vueExports.ref(false);
    const modalEdicao = vueExports.ref(false);
    const jornadaSelecionada = vueExports.ref(null);
    const jornadaEditando = vueExports.ref(null);
    const mostrarNotificacao = vueExports.ref(false);
    const notificacao = vueExports.ref({
      title: "",
      message: "",
      variant: "success"
    });
    const visualizarJornada = (jornada) => {
      jornadaSelecionada.value = jornada;
      modalVisualizacao.value = true;
    };
    const abrirModal = () => {
      jornadaEditando.value = null;
      modalEdicao.value = true;
    };
    const editarJornada = (jornada) => {
      jornadaEditando.value = jornada;
      modalEdicao.value = true;
    };
    const salvarJornada = async (dadosJornada) => {
      const resultado = await salvarJornadaComposable(dadosJornada);
      notificacao.value = {
        title: resultado.success ? "Sucesso!" : "Erro!",
        message: resultado.message,
        variant: resultado.success ? "success" : "error"
      };
      mostrarNotificacao.value = true;
      if (resultado.success) {
        modalEdicao.value = false;
      }
    };
    const toggleStatus = async (jornada) => {
      try {
        jornada.ativa = !jornada.ativa;
        notificacao.value = {
          title: "Status Atualizado!",
          message: `Jornada ${jornada.nome} ${jornada.ativa ? "ativada" : "inativada"} com sucesso!`,
          variant: "success"
        };
        mostrarNotificacao.value = true;
      } catch (error) {
        notificacao.value = {
          title: "Erro!",
          message: "Erro ao atualizar status da jornada.",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      }
    };
    const contarFuncionarios = (jornadaId) => {
      const mock = {
        "1": 15,
        // Jornada 42h45min
        "2": 8,
        // Jornada 44h
        "3": 3
        // Jornada 40h
      };
      return mock[jornadaId] || 0;
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiPageHeader = __nuxt_component_0$3;
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiCard = __nuxt_component_2$1;
      const _component_UiBadge = __nuxt_component_2$2;
      const _component_UiModal = __nuxt_component_3;
      const _component_UiNotification = __nuxt_component_7;
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      _push(ssrRenderComponent_1(_component_UiPageHeader, {
        title: "Jornadas de Trabalho",
        description: "Gerencie as jornadas e cargas horrias dos funcionrios"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent_1(_component_UiButton, {
              size: "lg",
              icon: "",
              onClick: ($event) => abrirModal()
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Nova Jornada `);
                } else {
                  return [
                    vueExports.createTextVNode(" Nova Jornada ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              vueExports.createVNode(_component_UiButton, {
                size: "lg",
                icon: "",
                onClick: ($event) => abrirModal()
              }, {
                default: vueExports.withCtx(() => [
                  vueExports.createTextVNode(" Nova Jornada ")
                ]),
                _: 1
              }, 8, ["onClick"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="space-y-4"><!--[-->`);
      ssrRenderList_1(vueExports.unref(jornadas), (jornada) => {
        _push(ssrRenderComponent_1(_component_UiCard, {
          key: jornada.id,
          padding: "p-6"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="flex flex-col lg:flex-row lg:items-center justify-between gap-4"${_scopeId}><div class="flex items-center gap-4"${_scopeId}><div class="w-16 h-16 bg-blue-100 rounded-xl flex items-center justify-center"${_scopeId}><span class="text-blue-700 font-bold text-2xl"${_scopeId}></span></div><div${_scopeId}><div class="flex items-center gap-2"${_scopeId}><h3 class="text-xl font-bold text-gray-800"${_scopeId}>${ssrInterpolate_1(jornada.nome)}</h3>`);
              if (jornada.padrao) {
                _push2(ssrRenderComponent_1(_component_UiBadge, { variant: "primary" }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(`Padro`);
                    } else {
                      return [
                        vueExports.createTextVNode("Padro")
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              _push2(ssrRenderComponent_1(_component_UiBadge, {
                variant: jornada.ativa ? "success" : "gray"
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(jornada.ativa ? "Ativa" : "Inativa")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(jornada.ativa ? "Ativa" : "Inativa"), 1)
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(`</div><p class="text-gray-600 mt-1"${_scopeId}>${ssrInterpolate_1(jornada.descricao)}</p><div class="flex gap-4 mt-2 text-sm text-gray-500"${_scopeId}><span${_scopeId}> ${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(jornada.horas_semanais))} semanais</span><span${_scopeId}> ${ssrInterpolate_1(vueExports.unref(formatarHorasDecimais)(jornada.horas_mensais))} mensais</span><span${_scopeId}> ${ssrInterpolate_1(contarFuncionarios(jornada.id))} funcionrios</span></div></div></div><div class="flex gap-2"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => visualizarJornada(jornada)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Visualizar `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Visualizar ")
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => editarJornada(jornada)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Editar `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Editar ")
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: jornada.ativa ? "danger" : "success",
                onClick: ($event) => toggleStatus(jornada)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(jornada.ativa ? " Inativar" : " Ativar")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(jornada.ativa ? " Inativar" : " Ativar"), 1)
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
              _push2(`</div></div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "flex flex-col lg:flex-row lg:items-center justify-between gap-4" }, [
                  vueExports.createVNode("div", { class: "flex items-center gap-4" }, [
                    vueExports.createVNode("div", { class: "w-16 h-16 bg-blue-100 rounded-xl flex items-center justify-center" }, [
                      vueExports.createVNode("span", { class: "text-blue-700 font-bold text-2xl" }, "")
                    ]),
                    vueExports.createVNode("div", null, [
                      vueExports.createVNode("div", { class: "flex items-center gap-2" }, [
                        vueExports.createVNode("h3", { class: "text-xl font-bold text-gray-800" }, vueExports.toDisplayString(jornada.nome), 1),
                        jornada.padrao ? (vueExports.openBlock(), vueExports.createBlock(_component_UiBadge, {
                          key: 0,
                          variant: "primary"
                        }, {
                          default: vueExports.withCtx(() => [
                            vueExports.createTextVNode("Padro")
                          ]),
                          _: 1
                        })) : vueExports.createCommentVNode("", true),
                        vueExports.createVNode(_component_UiBadge, {
                          variant: jornada.ativa ? "success" : "gray"
                        }, {
                          default: vueExports.withCtx(() => [
                            vueExports.createTextVNode(vueExports.toDisplayString(jornada.ativa ? "Ativa" : "Inativa"), 1)
                          ]),
                          _: 2
                        }, 1032, ["variant"])
                      ]),
                      vueExports.createVNode("p", { class: "text-gray-600 mt-1" }, vueExports.toDisplayString(jornada.descricao), 1),
                      vueExports.createVNode("div", { class: "flex gap-4 mt-2 text-sm text-gray-500" }, [
                        vueExports.createVNode("span", null, " " + vueExports.toDisplayString(vueExports.unref(formatarHorasDecimais)(jornada.horas_semanais)) + " semanais", 1),
                        vueExports.createVNode("span", null, " " + vueExports.toDisplayString(vueExports.unref(formatarHorasDecimais)(jornada.horas_mensais)) + " mensais", 1),
                        vueExports.createVNode("span", null, " " + vueExports.toDisplayString(contarFuncionarios(jornada.id)) + " funcionrios", 1)
                      ])
                    ])
                  ]),
                  vueExports.createVNode("div", { class: "flex gap-2" }, [
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: ($event) => visualizarJornada(jornada)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Visualizar ")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: ($event) => editarJornada(jornada)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Editar ")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: jornada.ativa ? "danger" : "success",
                      onClick: ($event) => toggleStatus(jornada)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode(vueExports.toDisplayString(jornada.ativa ? " Inativar" : " Ativar"), 1)
                      ]),
                      _: 2
                    }, 1032, ["variant", "onClick"])
                  ])
                ])
              ];
            }
          }),
          _: 2
        }, _parent));
      });
      _push(`<!--]--></div>`);
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalVisualizacao),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalVisualizacao) ? modalVisualizacao.value = $event : null,
        title: `Jornada: ${vueExports.unref(jornadaSelecionada)?.nome || ""}`,
        "max-width": "max-w-4xl"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (vueExports.unref(jornadaSelecionada)) {
              _push2(ssrRenderComponent_1(JornadaVisualizacao, { jornada: vueExports.unref(jornadaSelecionada) }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              vueExports.unref(jornadaSelecionada) ? (vueExports.openBlock(), vueExports.createBlock(JornadaVisualizacao, {
                key: 0,
                jornada: vueExports.unref(jornadaSelecionada)
              }, null, 8, ["jornada"])) : vueExports.createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalEdicao),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalEdicao) ? modalEdicao.value = $event : null,
        title: vueExports.unref(jornadaEditando) ? "Editar Jornada" : "Nova Jornada",
        "max-width": "max-w-5xl"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent_1(JornadaForm, {
              jornada: vueExports.unref(jornadaEditando),
              onSalvar: salvarJornada,
              onCancelar: ($event) => modalEdicao.value = false
            }, null, _parent2, _scopeId));
          } else {
            return [
              vueExports.createVNode(JornadaForm, {
                jornada: vueExports.unref(jornadaEditando),
                onSalvar: salvarJornada,
                onCancelar: ($event) => modalEdicao.value = false
              }, null, 8, ["jornada", "onCancelar"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiNotification, {
        show: vueExports.unref(mostrarNotificacao),
        title: vueExports.unref(notificacao).title,
        message: vueExports.unref(notificacao).message,
        variant: vueExports.unref(notificacao).variant,
        onClose: ($event) => mostrarNotificacao.value = false
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$9 = _sfc_main$9.setup;
_sfc_main$9.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/jornadas.vue");
  return _sfc_setup$9 ? _sfc_setup$9(props, ctx) : void 0;
};

const jornadasDRvczXH_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$9
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$1$3 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "HoleriteEditForm",
  __ssrInlineRender: true,
  props: {
    holerite: {}
  },
  emits: ["save", "cancel"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const abaAtiva = vueExports.ref("basicos");
    const empresaInfo = vueExports.ref(null);
    const horasPadrao = vueExports.ref(0);
    const carregandoDados = vueExports.ref(true);
    const itensPersonalizados = vueExports.ref([]);
    const mostrarFormNovoItem = vueExports.ref(false);
    const tabs = [
      { id: "basicos", label: "Dados Bsicos", icon: "" },
      { id: "proventos", label: "Proventos", icon: "" },
      { id: "descontos", label: "Descontos", icon: "" },
      { id: "personalizados", label: "Itens Personalizados", icon: "" }
    ];
    const form = vueExports.ref({
      salario_base: props.holerite.salario_base || 0,
      horas_trabalhadas: props.holerite.horas_trabalhadas || 0,
      data_pagamento: props.holerite.data_pagamento || "",
      observacoes: props.holerite.observacoes || "",
      bonus: props.holerite.bonus || 0,
      horas_extras: props.holerite.horas_extras || 0,
      adicional_noturno: props.holerite.adicional_noturno || 0,
      adicional_periculosidade: props.holerite.adicional_periculosidade || 0,
      adicional_insalubridade: props.holerite.adicional_insalubridade || 0,
      comissoes: props.holerite.comissoes || 0,
      inss: props.holerite.inss || 0,
      irrf: props.holerite.irrf || 0,
      vale_transporte: props.holerite.vale_transporte || 0,
      vale_refeicao_desconto: props.holerite.vale_refeicao_desconto || 0,
      plano_saude: props.holerite.plano_saude || 0,
      plano_odontologico: props.holerite.plano_odontologico || 0,
      adiantamento: props.holerite.adiantamento || 0,
      faltas: props.holerite.faltas || 0
    });
    const novoItem = vueExports.ref({
      tipo: "beneficio",
      descricao: "",
      valor: 0,
      vigencia_tipo: "unico",
      data_inicio: "",
      data_fim: "",
      observacoes: ""
    });
    const carregarItensPersonalizados = async (funcId) => {
      try {
        const response = await $fetch(`/api/holerites/itens-personalizados/${funcId}`);
        if (response.warning) {
          console.warn("", response.warning);
        }
        itensPersonalizados.value = response.data || [];
      } catch (error) {
        console.error("Erro ao carregar itens personalizados:", error);
        itensPersonalizados.value = [];
        if (error.message?.includes("PGRST205") || error.message?.includes("not exist")) {
          console.error(" A tabela holerite_itens_personalizados no existe!");
          console.error(" Execute o arquivo: EXECUTAR-ITENS-PERSONALIZADOS.sql no Supabase SQL Editor");
        }
      }
    };
    const adicionarItem = async () => {
      try {
        const funcId = props.holerite.funcionario_id || props.holerite.funcionario?.id;
        if (!novoItem.value.descricao || !novoItem.value.valor || !novoItem.value.data_inicio) {
          alert(" Preencha todos os campos obrigatrios");
          return;
        }
        const dataFim = novoItem.value.vigencia_tipo === "unico" ? novoItem.value.data_inicio : novoItem.value.data_fim || null;
        await $fetch("/api/holerites/itens-personalizados", {
          method: "POST",
          body: {
            funcionario_id: funcId,
            tipo: novoItem.value.tipo,
            descricao: novoItem.value.descricao,
            valor: Number(novoItem.value.valor),
            vigencia_tipo: novoItem.value.vigencia_tipo,
            data_inicio: novoItem.value.data_inicio,
            data_fim: dataFim,
            observacoes: novoItem.value.observacoes
          }
        });
        await carregarItensPersonalizados(funcId);
        cancelarNovoItem();
        alert(" Item adicionado com sucesso!");
      } catch (error) {
        console.error("Erro ao adicionar item:", error);
        if (error.message?.includes("no existe") || error.message?.includes("EXECUTAR-ITENS-PERSONALIZADOS")) {
          alert(" Erro: A tabela no existe no banco de dados.\n\n Execute o arquivo EXECUTAR-ITENS-PERSONALIZADOS.sql no Supabase SQL Editor.\n\nVeja a documentao em: docs/CORRECAO-ITENS-PERSONALIZADOS.md");
        } else {
          alert(" Erro ao adicionar item: " + error.message);
        }
      }
    };
    const cancelarNovoItem = () => {
      mostrarFormNovoItem.value = false;
      novoItem.value = {
        tipo: "beneficio",
        descricao: "",
        valor: 0,
        vigencia_tipo: "unico",
        data_inicio: "",
        data_fim: "",
        observacoes: ""
      };
    };
    const calcularTotalProventos = () => {
      return Number(form.value.salario_base) + Number(form.value.bonus) + Number(form.value.horas_extras) + Number(form.value.adicional_noturno) + Number(form.value.adicional_periculosidade) + Number(form.value.adicional_insalubridade) + Number(form.value.comissoes);
    };
    const calcularTotalDescontos = () => {
      return Number(form.value.inss) + Number(form.value.irrf) + Number(form.value.vale_transporte) + Number(form.value.vale_refeicao_desconto) + Number(form.value.plano_saude) + Number(form.value.plano_odontologico) + Number(form.value.adiantamento) + Number(form.value.faltas);
    };
    const calcularSalarioLiquido = () => {
      return calcularTotalProventos() - calcularTotalDescontos();
    };
    const formatarMoeda = (valor) => {
      return new Intl.NumberFormat("pt-BR", {
        style: "currency",
        currency: "BRL"
      }).format(valor);
    };
    const formatarCNPJ = (cnpj) => {
      const numeros = cnpj.replace(/\D/g, "");
      return numeros.replace(/^(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})$/, "$1.$2.$3/$4-$5");
    };
    const formatarData = (data) => {
      if (!data) return "";
      return (/* @__PURE__ */ new Date(data + "T00:00:00")).toLocaleDateString("pt-BR");
    };
    const salvar = () => {
      emit("save", form.value);
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiInput = __nuxt_component_4;
      const _component_UiAlert = __nuxt_component_1$1;
      const _component_UiButton = __nuxt_component_1$4;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-6" }, _attrs))}><div class="bg-gray-50 rounded-xl p-4"><h3 class="font-semibold text-gray-900 mb-2">${ssrInterpolate_1(__props.holerite.funcionario.nome_completo)}</h3>`);
      if (vueExports.unref(carregandoDados)) {
        _push(`<div class="text-sm text-gray-500">  Carregando informaes... </div>`);
      } else {
        _push(`<div class="grid grid-cols-2 gap-2 text-sm"><div><span class="text-gray-600">Cargo:</span><span class="ml-2 font-medium">${ssrInterpolate_1(__props.holerite.funcionario.cargo)}</span></div><div><span class="text-gray-600">Empresa:</span><span class="ml-2 font-medium">${ssrInterpolate_1(vueExports.unref(empresaInfo) ? vueExports.unref(empresaInfo).nome_fantasia || vueExports.unref(empresaInfo).nome || "No definida" : "No encontrada")}</span></div>`);
        if (vueExports.unref(empresaInfo)?.cnpj) {
          _push(`<div class="col-span-2"><span class="text-gray-600">CNPJ:</span><span class="ml-2 font-medium">${ssrInterpolate_1(formatarCNPJ(vueExports.unref(empresaInfo).cnpj))}</span></div>`);
        } else {
          _push(`<!---->`);
        }
        if (vueExports.unref(horasPadrao) > 0) {
          _push(`<div class="col-span-2"><span class="text-gray-600">Horas Padro do Ms:</span><span class="ml-2 font-medium">${ssrInterpolate_1(vueExports.unref(horasPadrao))}h</span></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      }
      _push(`</div><div class="border-b border-gray-200"><nav class="-mb-px flex space-x-8"><!--[-->`);
      ssrRenderList_1(tabs, (tab) => {
        _push(`<button class="${ssrRenderClass_1([
          "py-2 px-1 border-b-2 font-medium text-sm transition-colors",
          vueExports.unref(abaAtiva) === tab.id ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"
        ])}">${ssrInterpolate_1(tab.icon)} ${ssrInterpolate_1(tab.label)}</button>`);
      });
      _push(`<!--]--></nav></div>`);
      if (vueExports.unref(abaAtiva) === "basicos") {
        _push(`<div class="space-y-4"><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).salario_base,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).salario_base = $event,
          type: "number",
          label: "Salrio Base",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).horas_trabalhadas,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).horas_trabalhadas = $event,
          type: "number",
          label: "Horas Trabalhadas no Ms",
          placeholder: `Padro: ${vueExports.unref(horasPadrao)}h`,
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).data_pagamento,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).data_pagamento = $event,
          type: "date",
          label: "Data de Pagamento"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).observacoes,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).observacoes = $event,
          label: "Observaes",
          placeholder: "Observaes sobre este holerite"
        }, null, _parent));
        _push(`</div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(abaAtiva) === "proventos") {
        _push(`<div class="space-y-4"><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).bonus,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).bonus = $event,
          type: "number",
          label: "Bnus",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).horas_extras,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).horas_extras = $event,
          type: "number",
          label: "Horas Extras",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).adicional_noturno,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).adicional_noturno = $event,
          type: "number",
          label: "Adicional Noturno",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).adicional_periculosidade,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).adicional_periculosidade = $event,
          type: "number",
          label: "Adicional de Periculosidade",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).adicional_insalubridade,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).adicional_insalubridade = $event,
          type: "number",
          label: "Adicional de Insalubridade",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).comissoes,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).comissoes = $event,
          type: "number",
          label: "Comisses",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="bg-green-50 p-4 rounded-lg"><div class="flex justify-between items-center"><span class="font-semibold text-green-700">Total de Proventos:</span><span class="text-xl font-bold text-green-700">${ssrInterpolate_1(formatarMoeda(calcularTotalProventos()))}</span></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(abaAtiva) === "descontos") {
        _push(`<div class="space-y-4"><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).inss,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).inss = $event,
          type: "number",
          label: "INSS",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).irrf,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).irrf = $event,
          type: "number",
          label: "IRRF",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).vale_transporte,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).vale_transporte = $event,
          type: "number",
          label: "Vale Transporte",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).vale_refeicao_desconto,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).vale_refeicao_desconto = $event,
          type: "number",
          label: "Vale Refeio",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).plano_saude,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).plano_saude = $event,
          type: "number",
          label: "Plano de Sade",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).plano_odontologico,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).plano_odontologico = $event,
          type: "number",
          label: "Plano Odontolgico",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="grid grid-cols-2 gap-4">`);
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).adiantamento,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).adiantamento = $event,
          type: "number",
          label: "Adiantamento",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(ssrRenderComponent_1(_component_UiInput, {
          modelValue: vueExports.unref(form).faltas,
          "onUpdate:modelValue": ($event) => vueExports.unref(form).faltas = $event,
          type: "number",
          label: "Faltas",
          placeholder: "0.00",
          step: "0.01"
        }, null, _parent));
        _push(`</div><div class="bg-red-50 p-4 rounded-lg"><div class="flex justify-between items-center"><span class="font-semibold text-red-700">Total de Descontos:</span><span class="text-xl font-bold text-red-700">${ssrInterpolate_1(formatarMoeda(calcularTotalDescontos()))}</span></div></div></div>`);
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(abaAtiva) === "personalizados") {
        _push(`<div class="space-y-4">`);
        _push(ssrRenderComponent_1(_component_UiAlert, {
          variant: "info",
          class: "mb-4"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(` Adicione benefcios ou descontos personalizados que sero aplicados automaticamente nos holerites do funcionrio durante o perodo definido. `);
            } else {
              return [
                vueExports.createTextVNode(" Adicione benefcios ou descontos personalizados que sero aplicados automaticamente nos holerites do funcionrio durante o perodo definido. ")
              ];
            }
          }),
          _: 1
        }, _parent));
        if (vueExports.unref(itensPersonalizados).length > 0) {
          _push(`<div class="space-y-3 mb-6"><h4 class="font-semibold text-gray-700">Itens Ativos</h4><!--[-->`);
          ssrRenderList_1(vueExports.unref(itensPersonalizados), (item) => {
            _push(`<div class="bg-white border rounded-lg p-4"><div class="flex justify-between items-start"><div class="flex-1"><div class="flex items-center gap-2 mb-2"><span class="${ssrRenderClass_1([
              "px-2 py-1 rounded text-xs font-semibold",
              item.tipo === "beneficio" ? "bg-green-100 text-green-700" : "bg-red-100 text-red-700"
            ])}">${ssrInterpolate_1(item.tipo === "beneficio" ? " Benefcio" : " Desconto")}</span><span class="${ssrRenderClass_1([
              "px-2 py-1 rounded text-xs font-semibold",
              item.vigencia_tipo === "unico" ? "bg-blue-100 text-blue-700" : "bg-purple-100 text-purple-700"
            ])}">${ssrInterpolate_1(item.vigencia_tipo === "unico" ? " nico" : " Recorrente")}</span></div><p class="font-semibold text-gray-900">${ssrInterpolate_1(item.descricao)}</p><p class="${ssrRenderClass_1([item.tipo === "beneficio" ? "text-green-600" : "text-red-600", "text-lg font-bold"])}">${ssrInterpolate_1(formatarMoeda(item.valor))}</p><p class="text-sm text-gray-500 mt-1"> Vigncia: ${ssrInterpolate_1(formatarData(item.data_inicio))} ${ssrInterpolate_1(item.data_fim ? `at ${formatarData(item.data_fim)}` : "(sem data fim)")}</p>`);
            if (item.observacoes) {
              _push(`<p class="text-sm text-gray-400 mt-1">${ssrInterpolate_1(item.observacoes)}</p>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div><button class="text-red-500 hover:text-red-700 p-2" title="Remover item">  </button></div></div>`);
          });
          _push(`<!--]--></div>`);
        } else {
          _push(`<div class="text-center py-8 text-gray-500"> Nenhum item personalizado cadastrado </div>`);
        }
        if (!vueExports.unref(mostrarFormNovoItem)) {
          _push(ssrRenderComponent_1(_component_UiButton, {
            onClick: ($event) => mostrarFormNovoItem.value = true,
            variant: "secondary",
            class: "w-full"
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Adicionar Novo Item `);
              } else {
                return [
                  vueExports.createTextVNode("  Adicionar Novo Item ")
                ];
              }
            }),
            _: 1
          }, _parent));
        } else {
          _push(`<!---->`);
        }
        if (vueExports.unref(mostrarFormNovoItem)) {
          _push(`<div class="bg-gray-50 rounded-lg p-4 space-y-4"><h4 class="font-semibold text-gray-700">Novo Item Personalizado</h4><div class="grid grid-cols-2 gap-4"><div><label class="block text-sm font-medium text-gray-700 mb-1">Tipo</label><select class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"><option value="beneficio"${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(novoItem).tipo) ? ssrLooseContain_1(vueExports.unref(novoItem).tipo, "beneficio") : ssrLooseEqual_1(vueExports.unref(novoItem).tipo, "beneficio")) ? " selected" : ""}> Benefcio (Provento)</option><option value="desconto"${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(novoItem).tipo) ? ssrLooseContain_1(vueExports.unref(novoItem).tipo, "desconto") : ssrLooseEqual_1(vueExports.unref(novoItem).tipo, "desconto")) ? " selected" : ""}> Desconto</option></select></div><div><label class="block text-sm font-medium text-gray-700 mb-1">Vigncia</label><select class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"><option value="unico"${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(novoItem).vigencia_tipo) ? ssrLooseContain_1(vueExports.unref(novoItem).vigencia_tipo, "unico") : ssrLooseEqual_1(vueExports.unref(novoItem).vigencia_tipo, "unico")) ? " selected" : ""}> nico (apenas este ms)</option><option value="recorrente"${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(novoItem).vigencia_tipo) ? ssrLooseContain_1(vueExports.unref(novoItem).vigencia_tipo, "recorrente") : ssrLooseEqual_1(vueExports.unref(novoItem).vigencia_tipo, "recorrente")) ? " selected" : ""}> Recorrente (vrios meses)</option></select></div></div>`);
          _push(ssrRenderComponent_1(_component_UiInput, {
            modelValue: vueExports.unref(novoItem).descricao,
            "onUpdate:modelValue": ($event) => vueExports.unref(novoItem).descricao = $event,
            label: "Descrio",
            placeholder: "Ex: Bnus de produtividade, Desconto de uniforme..."
          }, null, _parent));
          _push(ssrRenderComponent_1(_component_UiInput, {
            modelValue: vueExports.unref(novoItem).valor,
            "onUpdate:modelValue": ($event) => vueExports.unref(novoItem).valor = $event,
            type: "number",
            label: "Valor",
            placeholder: "0.00",
            step: "0.01"
          }, null, _parent));
          _push(`<div class="grid grid-cols-2 gap-4">`);
          _push(ssrRenderComponent_1(_component_UiInput, {
            modelValue: vueExports.unref(novoItem).data_inicio,
            "onUpdate:modelValue": ($event) => vueExports.unref(novoItem).data_inicio = $event,
            type: "date",
            label: "Data Incio"
          }, null, _parent));
          _push(ssrRenderComponent_1(_component_UiInput, {
            modelValue: vueExports.unref(novoItem).data_fim,
            "onUpdate:modelValue": ($event) => vueExports.unref(novoItem).data_fim = $event,
            type: "date",
            label: "Data Fim (opcional)",
            disabled: vueExports.unref(novoItem).vigencia_tipo === "unico"
          }, null, _parent));
          _push(`</div>`);
          _push(ssrRenderComponent_1(_component_UiInput, {
            modelValue: vueExports.unref(novoItem).observacoes,
            "onUpdate:modelValue": ($event) => vueExports.unref(novoItem).observacoes = $event,
            label: "Observaes (opcional)",
            placeholder: "Informaes adicionais..."
          }, null, _parent));
          _push(`<div class="flex gap-3">`);
          _push(ssrRenderComponent_1(_component_UiButton, {
            onClick: adicionarItem,
            class: "flex-1"
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Adicionar `);
              } else {
                return [
                  vueExports.createTextVNode("  Adicionar ")
                ];
              }
            }),
            _: 1
          }, _parent));
          _push(ssrRenderComponent_1(_component_UiButton, {
            variant: "secondary",
            onClick: cancelarNovoItem,
            class: "flex-1"
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Cancelar `);
              } else {
                return [
                  vueExports.createTextVNode("  Cancelar ")
                ];
              }
            }),
            _: 1
          }, _parent));
          _push(`</div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`<div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-200"><div class="space-y-2"><div class="flex justify-between text-sm"><span class="text-gray-700">Total Proventos:</span><span class="font-semibold text-green-600">${ssrInterpolate_1(formatarMoeda(calcularTotalProventos()))}</span></div><div class="flex justify-between text-sm"><span class="text-gray-700">Total Descontos:</span><span class="font-semibold text-red-600">- ${ssrInterpolate_1(formatarMoeda(calcularTotalDescontos()))}</span></div><div class="border-t border-blue-300 pt-2 flex justify-between"><span class="font-bold text-blue-900">Salrio Lquido:</span><span class="text-2xl font-bold text-blue-900">${ssrInterpolate_1(formatarMoeda(calcularSalarioLiquido()))}</span></div></div></div><div class="flex justify-end gap-3 pt-4 border-t">`);
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "secondary",
        onClick: ($event) => _ctx.$emit("cancel")
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(` Cancelar `);
          } else {
            return [
              vueExports.createTextVNode(" Cancelar ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiButton, { onClick: salvar }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  Salvar Alteraes `);
          } else {
            return [
              vueExports.createTextVNode("  Salvar Alteraes ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$1$3 = _sfc_main$1$3.setup;
_sfc_main$1$3.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/holerites/HoleriteEditForm.vue");
  return _sfc_setup$1$3 ? _sfc_setup$1$3(props, ctx) : void 0;
};
const HoleriteEditForm = Object.assign(_sfc_main$1$3, { __name: "HoleritesHoleriteEditForm" });
const _sfc_main$8 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "holerites",
  __ssrInlineRender: true,
  setup(__props) {
    const loading = vueExports.ref(false);
    const holerites = vueExports.ref([]);
    const modalVisualizacao = vueExports.ref(false);
    const modalEdicao = vueExports.ref(false);
    const mostrarModalGerar = vueExports.ref(false);
    const mostrarModalEnvio = vueExports.ref(false);
    const mostrarModalDisponibilizar = vueExports.ref(false);
    const tipoGeracao = vueExports.ref("mensal");
    const tipoEnvio = vueExports.ref("todos");
    const tipoDisponibilizar = vueExports.ref("todos");
    const holeriteSelecionado = vueExports.ref(null);
    const mostrarNotificacao = vueExports.ref(false);
    const notificacao = vueExports.ref({ title: "", message: "", variant: "info" });
    const empresas = vueExports.ref([]);
    const opcoesGeracao = vueExports.ref({
      recriar: false
    });
    const filtros = vueExports.ref({
      empresa: "",
      mes: "",
      status: ""
    });
    const empresasOptions = vueExports.computed(() => [
      { value: "", label: "Todas as empresas" },
      ...empresas.value.map((e) => ({
        value: e.id.toString(),
        label: e.nome_fantasia
      }))
    ]);
    const mesesOptions = vueExports.computed(() => {
      const opcoes = [{ value: "", label: "Todos os perodos" }];
      const hoje = /* @__PURE__ */ new Date();
      for (let i = 0; i < 12; i++) {
        const data = new Date(hoje.getFullYear(), hoje.getMonth() - i, 1);
        const valor = `${data.getFullYear()}-${String(data.getMonth() + 1).padStart(2, "0")}`;
        const label = data.toLocaleDateString("pt-BR", { month: "long", year: "numeric" });
        opcoes.push({ value: valor, label });
      }
      return opcoes;
    });
    const statusOptions = vueExports.computed(() => [
      { value: "", label: "Todos os status" },
      { value: "gerado", label: "Gerado" },
      { value: "enviado", label: "Enviado" },
      { value: "visualizado", label: "Visualizado" }
    ]);
    const abrirModalGerar = (tipo) => {
      tipoGeracao.value = tipo;
      mostrarModalGerar.value = true;
    };
    const abrirModalEnvio = () => {
      tipoEnvio.value = "todos";
      mostrarModalEnvio.value = true;
    };
    const abrirModalDisponibilizar = () => {
      tipoDisponibilizar.value = "todos";
      mostrarModalDisponibilizar.value = true;
    };
    const contarHoleritesPorTipo = () => {
      if (tipoEnvio.value === "todos") {
        return holerites.value.filter((h) => h.status !== "enviado").length;
      } else if (tipoEnvio.value === "adiantamento") {
        return holerites.value.filter((h) => {
          const diaFim = new Date(h.periodo_fim).getDate();
          return diaFim <= 15 && h.status !== "enviado";
        }).length;
      } else {
        return holerites.value.filter((h) => {
          const diaFim = new Date(h.periodo_fim).getDate();
          return diaFim > 15 && h.status !== "enviado";
        }).length;
      }
    };
    const contarHoleritesPorTipoDisp = () => {
      if (tipoDisponibilizar.value === "todos") {
        return holerites.value.length;
      } else if (tipoDisponibilizar.value === "adiantamento") {
        return holerites.value.filter((h) => {
          const diaFim = new Date(h.periodo_fim).getDate();
          return diaFim <= 15;
        }).length;
      } else {
        return holerites.value.filter((h) => {
          const diaFim = new Date(h.periodo_fim).getDate();
          return diaFim > 15;
        }).length;
      }
    };
    const confirmarDisponibilizacao = async () => {
      mostrarModalDisponibilizar.value = false;
      await disponibilizarHolerites();
    };
    const disponibilizarHolerites = async () => {
      loading.value = true;
      try {
        let holeritesFiltrados = [];
        if (tipoDisponibilizar.value === "todos") {
          holeritesFiltrados = holerites.value;
        } else if (tipoDisponibilizar.value === "adiantamento") {
          holeritesFiltrados = holerites.value.filter((h) => {
            const diaFim = new Date(h.periodo_fim).getDate();
            return diaFim <= 15;
          });
        } else {
          holeritesFiltrados = holerites.value.filter((h) => {
            const diaFim = new Date(h.periodo_fim).getDate();
            return diaFim > 15;
          });
        }
        if (holeritesFiltrados.length === 0) {
          notificacao.value = {
            title: "Aviso",
            message: "Nenhum holerite para disponibilizar",
            variant: "warning"
          };
          mostrarNotificacao.value = true;
          loading.value = false;
          return;
        }
        let disponibilizados = 0;
        let erros = 0;
        for (const holerite of holeritesFiltrados) {
          try {
            await $fetch(`/api/holerites/${holerite.id}`, {
              method: "PATCH",
              body: {
                status: "visualizado"
                // Status que indica disponvel no perfil
              }
            });
            disponibilizados++;
          } catch (error) {
            console.error(`Erro ao disponibilizar holerite ${holerite.id}:`, error);
            erros++;
          }
        }
        const tipoTexto = tipoDisponibilizar.value === "adiantamento" ? "adiantamentos" : tipoDisponibilizar.value === "mensal" ? "folhas mensais" : "holerites";
        notificacao.value = {
          title: "Disponibilizao Concluda!",
          message: `${disponibilizados} ${tipoTexto} disponibilizado(s) no perfil${erros > 0 ? ` (${erros} erro(s))` : ""}`,
          variant: erros > 0 ? "warning" : "success"
        };
        mostrarNotificacao.value = true;
        await carregarHolerites();
      } catch (error) {
        notificacao.value = {
          title: "Erro!",
          message: error.data?.message || "Erro ao disponibilizar holerites",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const carregarHolerites = async () => {
      loading.value = true;
      try {
        const params = {};
        if (filtros.value.empresa) params.empresa = filtros.value.empresa;
        if (filtros.value.mes) params.mes = filtros.value.mes;
        if (filtros.value.status) params.status = filtros.value.status;
        const data = await $fetch("/api/holerites", { params });
        holerites.value = data;
      } catch (error) {
        console.error("Erro ao carregar holerites:", error);
        notificacao.value = {
          title: "Erro!",
          message: "Erro ao carregar holerites do banco de dados",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const gerarHoleritesAutomaticos = async () => {
      loading.value = true;
      try {
        const hoje = /* @__PURE__ */ new Date();
        const ano = hoje.getFullYear();
        const mes = String(hoje.getMonth() + 1).padStart(2, "0");
        let periodo_inicio, periodo_fim;
        if (tipoGeracao.value === "adiantamento") {
          periodo_inicio = `${ano}-${mes}-01`;
          periodo_fim = `${ano}-${mes}-15`;
        } else {
          periodo_inicio = `${ano}-${mes}-01`;
          const ultimoDia = new Date(ano, hoje.getMonth() + 1, 0).getDate();
          periodo_fim = `${ano}-${mes}-${String(ultimoDia).padStart(2, "0")}`;
        }
        const resultado = await $fetch("/api/holerites/gerar", {
          method: "POST",
          body: {
            periodo_inicio,
            periodo_fim,
            tipo: tipoGeracao.value,
            recriar: opcoesGeracao.value.recriar
          }
        });
        notificacao.value = {
          title: "Sucesso!",
          message: resultado.message || `${tipoGeracao.value === "adiantamento" ? "Adiantamentos" : "Holerites"} gerados com sucesso`,
          variant: "success"
        };
        mostrarNotificacao.value = true;
        await carregarHolerites();
      } catch (error) {
        notificacao.value = {
          title: "Erro!",
          message: error.data?.message || "Erro ao gerar holerites automaticamente",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const confirmarGeracaoHolerites = async () => {
      mostrarModalGerar.value = false;
      await gerarHoleritesAutomaticos();
    };
    const confirmarEnvioHolerites = async () => {
      mostrarModalEnvio.value = false;
      await enviarHoleritesPorTipo();
    };
    const enviarHoleritesPorTipo = async () => {
      loading.value = true;
      try {
        let holeritesFiltrados = [];
        if (tipoEnvio.value === "todos") {
          holeritesFiltrados = holerites.value.filter((h) => h.status !== "enviado");
        } else if (tipoEnvio.value === "adiantamento") {
          holeritesFiltrados = holerites.value.filter((h) => {
            const diaFim = new Date(h.periodo_fim).getDate();
            return diaFim <= 15 && h.status !== "enviado";
          });
        } else {
          holeritesFiltrados = holerites.value.filter((h) => {
            const diaFim = new Date(h.periodo_fim).getDate();
            return diaFim > 15 && h.status !== "enviado";
          });
        }
        if (holeritesFiltrados.length === 0) {
          notificacao.value = {
            title: "Aviso",
            message: "Nenhum holerite para enviar",
            variant: "warning"
          };
          mostrarNotificacao.value = true;
          loading.value = false;
          return;
        }
        let enviados = 0;
        let erros = 0;
        for (const holerite of holeritesFiltrados) {
          try {
            await $fetch(`/api/holerites/${holerite.id}/enviar-email`, {
              method: "POST"
            });
            enviados++;
          } catch (error) {
            console.error(`Erro ao enviar holerite ${holerite.id}:`, error);
            erros++;
          }
        }
        const tipoTexto = tipoEnvio.value === "adiantamento" ? "adiantamentos" : tipoEnvio.value === "mensal" ? "folhas mensais" : "holerites";
        notificacao.value = {
          title: "Envio Concludo!",
          message: `${enviados} ${tipoTexto} enviado(s) com sucesso${erros > 0 ? ` (${erros} erro(s))` : ""}`,
          variant: erros > 0 ? "warning" : "success"
        };
        mostrarNotificacao.value = true;
        await carregarHolerites();
      } catch (error) {
        notificacao.value = {
          title: "Erro!",
          message: error.data?.message || "Erro ao enviar holerites",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const visualizarHolerite = (holerite) => {
      holeriteSelecionado.value = holerite;
      modalVisualizacao.value = true;
    };
    const editarHolerite = (holerite) => {
      holeriteSelecionado.value = { ...holerite };
      modalEdicao.value = true;
    };
    const enviarHolerite = async (holerite) => {
      try {
        loading.value = true;
        const resultado = await $fetch(`/api/holerites/${holerite.id}/enviar-email`, {
          method: "POST"
        });
        holerite.status = "enviado";
        notificacao.value = {
          title: "Enviado!",
          message: `Holerite enviado para ${holerite.funcionario?.nome_completo || "funcionrio"} (${resultado.email})`,
          variant: "success"
        };
        mostrarNotificacao.value = true;
        await carregarHolerites();
      } catch (error) {
        notificacao.value = {
          title: "Erro!",
          message: error.data?.message || "Erro ao enviar holerite",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const salvarEdicaoHolerite = async (dadosAtualizados) => {
      if (!holeriteSelecionado.value) return;
      try {
        loading.value = true;
        const resultado = await $fetch(`/api/holerites/${holeriteSelecionado.value.id}`, {
          method: "PATCH",
          body: dadosAtualizados
        });
        modalEdicao.value = false;
        notificacao.value = {
          title: "Salvo!",
          message: "Holerite atualizado com sucesso",
          variant: "success"
        };
        mostrarNotificacao.value = true;
        await carregarHolerites();
      } catch (error) {
        notificacao.value = {
          title: "Erro!",
          message: error.data?.message || "Erro ao salvar alteraes",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const aplicarFiltros = () => {
      carregarHolerites();
    };
    const excluirHolerite = async (holerite) => {
      if (!confirm(`Tem certeza que deseja excluir o holerite de ${holerite.funcionario?.nome_completo || "funcionrio"}?

Esta ao no pode ser desfeita.`)) {
        return;
      }
      try {
        loading.value = true;
        await $fetch(`/api/holerites/${holerite.id}`, {
          method: "DELETE"
        });
        notificacao.value = {
          title: "Excludo!",
          message: `Holerite de ${holerite.funcionario?.nome_completo || "funcionrio"} excludo com sucesso`,
          variant: "success"
        };
        mostrarNotificacao.value = true;
        await carregarHolerites();
      } catch (error) {
        notificacao.value = {
          title: "Erro!",
          message: error.data?.message || "Erro ao excluir holerite",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const formatarMoeda = (valor) => {
      return new Intl.NumberFormat("pt-BR", {
        style: "currency",
        currency: "BRL"
      }).format(valor);
    };
    const formatarPeriodo = (inicio, fim) => {
      const dataInicio = new Date(inicio).toLocaleDateString("pt-BR");
      const dataFim = new Date(fim).toLocaleDateString("pt-BR");
      return `${dataInicio} - ${dataFim}`;
    };
    const getStatusLabel = (status) => {
      const labels = {
        gerado: "Gerado",
        enviado: "Enviado",
        visualizado: "Visualizado"
      };
      return labels[status] || status;
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiSelect = __nuxt_component_6$1;
      const _component_UiEmptyState = __nuxt_component_2;
      const _component_UiModal = __nuxt_component_3;
      const _component_UiNotification = __nuxt_component_7;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-6" }, _attrs))}><div class="flex items-center justify-between"><div><h1 class="text-2xl font-bold text-gray-900"> Gesto de Holerites</h1><p class="text-gray-600">Gerencie e envie holerites para os funcionrios</p></div><div class="flex gap-3">`);
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "secondary",
        onClick: ($event) => abrirModalGerar("adiantamento"),
        disabled: vueExports.unref(loading)
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  Gerar Adiantamento (40%) `);
          } else {
            return [
              vueExports.createTextVNode("  Gerar Adiantamento (40%) ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiButton, {
        onClick: ($event) => abrirModalGerar("mensal"),
        disabled: vueExports.unref(loading)
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  Gerar Folha Mensal `);
          } else {
            return [
              vueExports.createTextVNode("  Gerar Folha Mensal ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "ghost",
        onClick: abrirModalDisponibilizar,
        disabled: vueExports.unref(loading) || vueExports.unref(holerites).length === 0
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  Disponibilizar no Perfil `);
          } else {
            return [
              vueExports.createTextVNode("  Disponibilizar no Perfil ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "ghost",
        onClick: abrirModalEnvio,
        disabled: vueExports.unref(loading) || vueExports.unref(holerites).length === 0
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  Enviar por Email `);
          } else {
            return [
              vueExports.createTextVNode("  Enviar por Email ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div><div class="bg-white p-4 rounded-xl border border-gray-200"><div class="grid grid-cols-1 md:grid-cols-4 gap-4">`);
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: vueExports.unref(filtros).empresa,
        "onUpdate:modelValue": ($event) => vueExports.unref(filtros).empresa = $event,
        options: vueExports.unref(empresasOptions),
        label: "Empresa",
        placeholder: "Todas as empresas"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: vueExports.unref(filtros).mes,
        "onUpdate:modelValue": ($event) => vueExports.unref(filtros).mes = $event,
        options: vueExports.unref(mesesOptions),
        label: "Ms/Ano",
        placeholder: "Selecione o perodo"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: vueExports.unref(filtros).status,
        "onUpdate:modelValue": ($event) => vueExports.unref(filtros).status = $event,
        options: vueExports.unref(statusOptions),
        label: "Status",
        placeholder: "Todos os status"
      }, null, _parent));
      _push(`<div class="flex items-end">`);
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "secondary",
        onClick: aplicarFiltros,
        class: "w-full"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  Filtrar `);
          } else {
            return [
              vueExports.createTextVNode("  Filtrar ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div><div class="bg-white rounded-xl border border-gray-200"><div class="p-6 border-b border-gray-200"><h2 class="text-lg font-semibold text-gray-900">Holerites Gerados</h2><p class="text-sm text-gray-600">${ssrInterpolate_1(vueExports.unref(holerites).length)} holerite(s) encontrado(s)</p></div>`);
      if (vueExports.unref(loading)) {
        _push(`<div class="p-8 text-center"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div><p class="mt-2 text-gray-600">Carregando holerites...</p></div>`);
      } else if (vueExports.unref(holerites).length === 0) {
        _push(`<div class="p-8">`);
        _push(ssrRenderComponent_1(_component_UiEmptyState, {
          title: "Nenhum holerite encontrado",
          description: "Gere holerites automticos ou ajuste os filtros",
          icon: "document"
        }, null, _parent));
        _push(`</div>`);
      } else {
        _push(`<div class="divide-y divide-gray-200"><!--[-->`);
        ssrRenderList_1(vueExports.unref(holerites), (holerite) => {
          _push(`<div class="p-6 hover:bg-gray-50 transition-colors"><div class="flex items-center justify-between"><div class="flex items-center gap-4"><div class="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center"><span class="text-blue-600 font-semibold">${ssrInterpolate_1(holerite.funcionario?.nome_completo?.charAt(0) || "?")}</span></div><div><h3 class="font-semibold text-gray-900">${ssrInterpolate_1(holerite.funcionario?.nome_completo || "Nome no disponvel")}</h3><p class="text-sm text-gray-600">${ssrInterpolate_1(holerite.funcionario?.cargo || "Cargo no definido")}</p><p class="text-xs text-gray-500">${ssrInterpolate_1(holerite.funcionario?.empresa || "Empresa no definida")}</p></div></div><div class="flex items-center gap-4"><div class="text-right"><p class="font-semibold text-gray-900">${ssrInterpolate_1(formatarMoeda(holerite.salario_liquido))}</p><p class="text-sm text-gray-600">${ssrInterpolate_1(formatarPeriodo(holerite.periodo_inicio, holerite.periodo_fim))}</p><span class="${ssrRenderClass_1([
            "inline-flex items-center px-2 py-1 rounded-full text-xs font-medium",
            holerite.status === "enviado" ? "bg-green-100 text-green-800" : holerite.status === "gerado" ? "bg-yellow-100 text-yellow-800" : "bg-gray-100 text-gray-800"
          ])}">${ssrInterpolate_1(getStatusLabel(holerite.status))}</span></div><div class="flex gap-2">`);
          _push(ssrRenderComponent_1(_component_UiButton, {
            variant: "secondary",
            size: "sm",
            onClick: ($event) => visualizarHolerite(holerite)
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Ver `);
              } else {
                return [
                  vueExports.createTextVNode("  Ver ")
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(ssrRenderComponent_1(_component_UiButton, {
            variant: "secondary",
            size: "sm",
            onClick: ($event) => editarHolerite(holerite)
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Editar `);
              } else {
                return [
                  vueExports.createTextVNode("  Editar ")
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(ssrRenderComponent_1(_component_UiButton, {
            size: "sm",
            onClick: ($event) => enviarHolerite(holerite),
            disabled: holerite.status === "enviado"
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Enviar `);
              } else {
                return [
                  vueExports.createTextVNode("  Enviar ")
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(ssrRenderComponent_1(_component_UiButton, {
            variant: "danger",
            size: "sm",
            onClick: ($event) => excluirHolerite(holerite)
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Excluir `);
              } else {
                return [
                  vueExports.createTextVNode("  Excluir ")
                ];
              }
            }),
            _: 2
          }, _parent));
          _push(`</div></div></div></div>`);
        });
        _push(`<!--]--></div>`);
      }
      _push(`</div>`);
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalVisualizacao),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalVisualizacao) ? modalVisualizacao.value = $event : null,
        title: "Visualizar Holerite",
        "max-width": "max-w-3xl"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (vueExports.unref(holeriteSelecionado)) {
              _push2(ssrRenderComponent_1(HoleriteModal, {
                holerite: vueExports.unref(holeriteSelecionado),
                onClose: ($event) => modalVisualizacao.value = false
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              vueExports.unref(holeriteSelecionado) ? (vueExports.openBlock(), vueExports.createBlock(HoleriteModal, {
                key: 0,
                holerite: vueExports.unref(holeriteSelecionado),
                onClose: ($event) => modalVisualizacao.value = false
              }, null, 8, ["holerite", "onClose"])) : vueExports.createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalEdicao),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalEdicao) ? modalEdicao.value = $event : null,
        title: "Editar Holerite",
        "max-width": "max-w-4xl"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (vueExports.unref(holeriteSelecionado)) {
              _push2(ssrRenderComponent_1(HoleriteEditForm, {
                holerite: vueExports.unref(holeriteSelecionado),
                onSave: salvarEdicaoHolerite,
                onCancel: ($event) => modalEdicao.value = false
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              vueExports.unref(holeriteSelecionado) ? (vueExports.openBlock(), vueExports.createBlock(HoleriteEditForm, {
                key: 0,
                holerite: vueExports.unref(holeriteSelecionado),
                onSave: salvarEdicaoHolerite,
                onCancel: ($event) => modalEdicao.value = false
              }, null, 8, ["holerite", "onCancel"])) : vueExports.createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(mostrarModalGerar),
        "onUpdate:modelValue": ($event) => vueExports.isRef(mostrarModalGerar) ? mostrarModalGerar.value = $event : null,
        title: vueExports.unref(tipoGeracao) === "adiantamento" ? "Gerar Adiantamento Salarial" : "Gerar Folha Mensal",
        "max-width": "max-w-lg"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="space-y-4"${_scopeId}>`);
            if (vueExports.unref(tipoGeracao) === "adiantamento") {
              _push2(`<div class="bg-blue-50 border border-blue-200 rounded-lg p-4"${_scopeId}><p class="text-sm text-blue-800"${_scopeId}><strong${_scopeId}> Adiantamento Salarial (40%):</strong><br${_scopeId}>  Gerar adiantamento de 40% do salrio base<br${_scopeId}>  Perodo: Primeira quinzena do ms atual<br${_scopeId}>  O valor ser descontado automaticamente na folha mensal<br${_scopeId}>  Sem clculo de INSS e IRRF (apenas adiantamento) </p></div>`);
            } else {
              _push2(`<div class="bg-blue-50 border border-blue-200 rounded-lg p-4"${_scopeId}><p class="text-sm text-blue-800"${_scopeId}><strong${_scopeId}> Folha de Pagamento Mensal:</strong><br${_scopeId}>  Gerar holerites completos para todos os funcionrios ativos<br${_scopeId}>  Perodo: Ms completo<br${_scopeId}>  Clculos automticos de INSS, IRRF e descontos<br${_scopeId}>  Desconto automtico de adiantamentos j pagos </p></div>`);
            }
            _push2(`<div class="flex items-center gap-3 p-4 bg-yellow-50 border border-yellow-200 rounded-lg"${_scopeId}><input type="checkbox" id="recriar"${ssrIncludeBooleanAttr(Array.isArray(vueExports.unref(opcoesGeracao).recriar) ? ssrLooseContain_1(vueExports.unref(opcoesGeracao).recriar, null) : vueExports.unref(opcoesGeracao).recriar) ? " checked" : ""} class="w-5 h-5 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"${_scopeId}><label for="recriar" class="text-sm text-yellow-800 cursor-pointer"${_scopeId}><strong${_scopeId}> Recriar holerites existentes</strong><br${_scopeId}><span class="text-xs"${_scopeId}>Se marcado, holerites j gerados para este perodo sero excludos e recriados</span></label></div><div class="flex gap-3 justify-end pt-4 border-t"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "secondary",
              onClick: ($event) => mostrarModalGerar.value = false
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Cancelar `);
                } else {
                  return [
                    vueExports.createTextVNode(" Cancelar ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              onClick: confirmarGeracaoHolerites,
              disabled: vueExports.unref(loading)
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${ssrInterpolate_1(vueExports.unref(loading) ? "Gerando..." : " Confirmar Gerao")}`);
                } else {
                  return [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(loading) ? "Gerando..." : " Confirmar Gerao"), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "space-y-4" }, [
                vueExports.unref(tipoGeracao) === "adiantamento" ? (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 0,
                  class: "bg-blue-50 border border-blue-200 rounded-lg p-4"
                }, [
                  vueExports.createVNode("p", { class: "text-sm text-blue-800" }, [
                    vueExports.createVNode("strong", null, " Adiantamento Salarial (40%):"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  Gerar adiantamento de 40% do salrio base"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  Perodo: Primeira quinzena do ms atual"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  O valor ser descontado automaticamente na folha mensal"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  Sem clculo de INSS e IRRF (apenas adiantamento) ")
                  ])
                ])) : (vueExports.openBlock(), vueExports.createBlock("div", {
                  key: 1,
                  class: "bg-blue-50 border border-blue-200 rounded-lg p-4"
                }, [
                  vueExports.createVNode("p", { class: "text-sm text-blue-800" }, [
                    vueExports.createVNode("strong", null, " Folha de Pagamento Mensal:"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  Gerar holerites completos para todos os funcionrios ativos"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  Perodo: Ms completo"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  Clculos automticos de INSS, IRRF e descontos"),
                    vueExports.createVNode("br"),
                    vueExports.createTextVNode("  Desconto automtico de adiantamentos j pagos ")
                  ])
                ])),
                vueExports.createVNode("div", { class: "flex items-center gap-3 p-4 bg-yellow-50 border border-yellow-200 rounded-lg" }, [
                  vueExports.withDirectives(vueExports.createVNode("input", {
                    type: "checkbox",
                    id: "recriar",
                    "onUpdate:modelValue": ($event) => vueExports.unref(opcoesGeracao).recriar = $event,
                    class: "w-5 h-5 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                  }, null, 8, ["onUpdate:modelValue"]), [
                    [vueExports.vModelCheckbox, vueExports.unref(opcoesGeracao).recriar]
                  ]),
                  vueExports.createVNode("label", {
                    for: "recriar",
                    class: "text-sm text-yellow-800 cursor-pointer"
                  }, [
                    vueExports.createVNode("strong", null, " Recriar holerites existentes"),
                    vueExports.createVNode("br"),
                    vueExports.createVNode("span", { class: "text-xs" }, "Se marcado, holerites j gerados para este perodo sero excludos e recriados")
                  ])
                ]),
                vueExports.createVNode("div", { class: "flex gap-3 justify-end pt-4 border-t" }, [
                  vueExports.createVNode(_component_UiButton, {
                    variant: "secondary",
                    onClick: ($event) => mostrarModalGerar.value = false
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(" Cancelar ")
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  vueExports.createVNode(_component_UiButton, {
                    onClick: confirmarGeracaoHolerites,
                    disabled: vueExports.unref(loading)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(loading) ? "Gerando..." : " Confirmar Gerao"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(mostrarModalEnvio),
        "onUpdate:modelValue": ($event) => vueExports.isRef(mostrarModalEnvio) ? mostrarModalEnvio.value = $event : null,
        title: "Enviar Holerites por Email",
        "max-width": "max-w-lg"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="space-y-4"${_scopeId}><div class="bg-blue-50 border border-blue-200 rounded-lg p-4"${_scopeId}><p class="text-sm text-blue-800 mb-3"${_scopeId}><strong${_scopeId}> Selecione o tipo de holerite para enviar:</strong></p><div class="space-y-3"${_scopeId}><div class="flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200"${_scopeId}><input type="radio" id="enviar-adiantamento" value="adiantamento"${ssrIncludeBooleanAttr(ssrLooseEqual_1(vueExports.unref(tipoEnvio), "adiantamento")) ? " checked" : ""} class="w-4 h-4 text-blue-600"${_scopeId}><label for="enviar-adiantamento" class="flex-1 cursor-pointer"${_scopeId}><strong class="text-gray-900"${_scopeId}> Apenas Adiantamentos</strong><br${_scopeId}><span class="text-xs text-gray-600"${_scopeId}>Enviar apenas holerites de adiantamento (primeira quinzena)</span></label></div><div class="flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200"${_scopeId}><input type="radio" id="enviar-mensal" value="mensal"${ssrIncludeBooleanAttr(ssrLooseEqual_1(vueExports.unref(tipoEnvio), "mensal")) ? " checked" : ""} class="w-4 h-4 text-blue-600"${_scopeId}><label for="enviar-mensal" class="flex-1 cursor-pointer"${_scopeId}><strong class="text-gray-900"${_scopeId}> Apenas Folhas Mensais</strong><br${_scopeId}><span class="text-xs text-gray-600"${_scopeId}>Enviar apenas holerites mensais completos</span></label></div><div class="flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200"${_scopeId}><input type="radio" id="enviar-todos" value="todos"${ssrIncludeBooleanAttr(ssrLooseEqual_1(vueExports.unref(tipoEnvio), "todos")) ? " checked" : ""} class="w-4 h-4 text-blue-600"${_scopeId}><label for="enviar-todos" class="flex-1 cursor-pointer"${_scopeId}><strong class="text-gray-900"${_scopeId}> Todos os Holerites</strong><br${_scopeId}><span class="text-xs text-gray-600"${_scopeId}>Enviar todos os holerites listados</span></label></div></div></div><div class="bg-gray-50 border border-gray-200 rounded-lg p-4"${_scopeId}><p class="text-sm text-gray-700"${_scopeId}><strong${_scopeId}>Total a enviar:</strong> ${ssrInterpolate_1(contarHoleritesPorTipo())} holerite(s) </p></div><div class="flex gap-3 justify-end pt-4 border-t"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "secondary",
              onClick: ($event) => mostrarModalEnvio.value = false
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Cancelar `);
                } else {
                  return [
                    vueExports.createTextVNode(" Cancelar ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              onClick: confirmarEnvioHolerites,
              disabled: vueExports.unref(loading) || contarHoleritesPorTipo() === 0
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${ssrInterpolate_1(vueExports.unref(loading) ? "Enviando..." : " Confirmar Envio")}`);
                } else {
                  return [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(loading) ? "Enviando..." : " Confirmar Envio"), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "space-y-4" }, [
                vueExports.createVNode("div", { class: "bg-blue-50 border border-blue-200 rounded-lg p-4" }, [
                  vueExports.createVNode("p", { class: "text-sm text-blue-800 mb-3" }, [
                    vueExports.createVNode("strong", null, " Selecione o tipo de holerite para enviar:")
                  ]),
                  vueExports.createVNode("div", { class: "space-y-3" }, [
                    vueExports.createVNode("div", { class: "flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200" }, [
                      vueExports.withDirectives(vueExports.createVNode("input", {
                        type: "radio",
                        id: "enviar-adiantamento",
                        value: "adiantamento",
                        "onUpdate:modelValue": ($event) => vueExports.isRef(tipoEnvio) ? tipoEnvio.value = $event : null,
                        class: "w-4 h-4 text-blue-600"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vueExports.vModelRadio, vueExports.unref(tipoEnvio)]
                      ]),
                      vueExports.createVNode("label", {
                        for: "enviar-adiantamento",
                        class: "flex-1 cursor-pointer"
                      }, [
                        vueExports.createVNode("strong", { class: "text-gray-900" }, " Apenas Adiantamentos"),
                        vueExports.createVNode("br"),
                        vueExports.createVNode("span", { class: "text-xs text-gray-600" }, "Enviar apenas holerites de adiantamento (primeira quinzena)")
                      ])
                    ]),
                    vueExports.createVNode("div", { class: "flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200" }, [
                      vueExports.withDirectives(vueExports.createVNode("input", {
                        type: "radio",
                        id: "enviar-mensal",
                        value: "mensal",
                        "onUpdate:modelValue": ($event) => vueExports.isRef(tipoEnvio) ? tipoEnvio.value = $event : null,
                        class: "w-4 h-4 text-blue-600"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vueExports.vModelRadio, vueExports.unref(tipoEnvio)]
                      ]),
                      vueExports.createVNode("label", {
                        for: "enviar-mensal",
                        class: "flex-1 cursor-pointer"
                      }, [
                        vueExports.createVNode("strong", { class: "text-gray-900" }, " Apenas Folhas Mensais"),
                        vueExports.createVNode("br"),
                        vueExports.createVNode("span", { class: "text-xs text-gray-600" }, "Enviar apenas holerites mensais completos")
                      ])
                    ]),
                    vueExports.createVNode("div", { class: "flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200" }, [
                      vueExports.withDirectives(vueExports.createVNode("input", {
                        type: "radio",
                        id: "enviar-todos",
                        value: "todos",
                        "onUpdate:modelValue": ($event) => vueExports.isRef(tipoEnvio) ? tipoEnvio.value = $event : null,
                        class: "w-4 h-4 text-blue-600"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vueExports.vModelRadio, vueExports.unref(tipoEnvio)]
                      ]),
                      vueExports.createVNode("label", {
                        for: "enviar-todos",
                        class: "flex-1 cursor-pointer"
                      }, [
                        vueExports.createVNode("strong", { class: "text-gray-900" }, " Todos os Holerites"),
                        vueExports.createVNode("br"),
                        vueExports.createVNode("span", { class: "text-xs text-gray-600" }, "Enviar todos os holerites listados")
                      ])
                    ])
                  ])
                ]),
                vueExports.createVNode("div", { class: "bg-gray-50 border border-gray-200 rounded-lg p-4" }, [
                  vueExports.createVNode("p", { class: "text-sm text-gray-700" }, [
                    vueExports.createVNode("strong", null, "Total a enviar:"),
                    vueExports.createTextVNode(" " + vueExports.toDisplayString(contarHoleritesPorTipo()) + " holerite(s) ", 1)
                  ])
                ]),
                vueExports.createVNode("div", { class: "flex gap-3 justify-end pt-4 border-t" }, [
                  vueExports.createVNode(_component_UiButton, {
                    variant: "secondary",
                    onClick: ($event) => mostrarModalEnvio.value = false
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(" Cancelar ")
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  vueExports.createVNode(_component_UiButton, {
                    onClick: confirmarEnvioHolerites,
                    disabled: vueExports.unref(loading) || contarHoleritesPorTipo() === 0
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(loading) ? "Enviando..." : " Confirmar Envio"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(mostrarModalDisponibilizar),
        "onUpdate:modelValue": ($event) => vueExports.isRef(mostrarModalDisponibilizar) ? mostrarModalDisponibilizar.value = $event : null,
        title: "Disponibilizar Holerites no Perfil",
        "max-width": "max-w-lg"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="space-y-4"${_scopeId}><div class="bg-blue-50 border border-blue-200 rounded-lg p-4"${_scopeId}><p class="text-sm text-blue-800 mb-3"${_scopeId}><strong${_scopeId}> Selecione o tipo de holerite para disponibilizar:</strong><br${_scopeId}><span class="text-xs"${_scopeId}>Os holerites ficaro disponveis para visualizao no perfil do funcionrio</span></p><div class="space-y-3"${_scopeId}><div class="flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200"${_scopeId}><input type="radio" id="disp-adiantamento" value="adiantamento"${ssrIncludeBooleanAttr(ssrLooseEqual_1(vueExports.unref(tipoDisponibilizar), "adiantamento")) ? " checked" : ""} class="w-4 h-4 text-blue-600"${_scopeId}><label for="disp-adiantamento" class="flex-1 cursor-pointer"${_scopeId}><strong class="text-gray-900"${_scopeId}> Apenas Adiantamentos</strong><br${_scopeId}><span class="text-xs text-gray-600"${_scopeId}>Disponibilizar apenas holerites de adiantamento</span></label></div><div class="flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200"${_scopeId}><input type="radio" id="disp-mensal" value="mensal"${ssrIncludeBooleanAttr(ssrLooseEqual_1(vueExports.unref(tipoDisponibilizar), "mensal")) ? " checked" : ""} class="w-4 h-4 text-blue-600"${_scopeId}><label for="disp-mensal" class="flex-1 cursor-pointer"${_scopeId}><strong class="text-gray-900"${_scopeId}> Apenas Folhas Mensais</strong><br${_scopeId}><span class="text-xs text-gray-600"${_scopeId}>Disponibilizar apenas holerites mensais completos</span></label></div><div class="flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200"${_scopeId}><input type="radio" id="disp-todos" value="todos"${ssrIncludeBooleanAttr(ssrLooseEqual_1(vueExports.unref(tipoDisponibilizar), "todos")) ? " checked" : ""} class="w-4 h-4 text-blue-600"${_scopeId}><label for="disp-todos" class="flex-1 cursor-pointer"${_scopeId}><strong class="text-gray-900"${_scopeId}> Todos os Holerites</strong><br${_scopeId}><span class="text-xs text-gray-600"${_scopeId}>Disponibilizar todos os holerites listados</span></label></div></div></div><div class="bg-gray-50 border border-gray-200 rounded-lg p-4"${_scopeId}><p class="text-sm text-gray-700"${_scopeId}><strong${_scopeId}>Total a disponibilizar:</strong> ${ssrInterpolate_1(contarHoleritesPorTipoDisp())} holerite(s) </p><p class="text-xs text-gray-500 mt-2"${_scopeId}> Os funcionrios podero visualizar e baixar seus holerites na rea &quot;Meus Holerites&quot; </p></div><div class="flex gap-3 justify-end pt-4 border-t"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "secondary",
              onClick: ($event) => mostrarModalDisponibilizar.value = false
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Cancelar `);
                } else {
                  return [
                    vueExports.createTextVNode(" Cancelar ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              onClick: confirmarDisponibilizacao,
              disabled: vueExports.unref(loading) || contarHoleritesPorTipoDisp() === 0
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${ssrInterpolate_1(vueExports.unref(loading) ? "Disponibilizando..." : " Confirmar")}`);
                } else {
                  return [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(loading) ? "Disponibilizando..." : " Confirmar"), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "space-y-4" }, [
                vueExports.createVNode("div", { class: "bg-blue-50 border border-blue-200 rounded-lg p-4" }, [
                  vueExports.createVNode("p", { class: "text-sm text-blue-800 mb-3" }, [
                    vueExports.createVNode("strong", null, " Selecione o tipo de holerite para disponibilizar:"),
                    vueExports.createVNode("br"),
                    vueExports.createVNode("span", { class: "text-xs" }, "Os holerites ficaro disponveis para visualizao no perfil do funcionrio")
                  ]),
                  vueExports.createVNode("div", { class: "space-y-3" }, [
                    vueExports.createVNode("div", { class: "flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200" }, [
                      vueExports.withDirectives(vueExports.createVNode("input", {
                        type: "radio",
                        id: "disp-adiantamento",
                        value: "adiantamento",
                        "onUpdate:modelValue": ($event) => vueExports.isRef(tipoDisponibilizar) ? tipoDisponibilizar.value = $event : null,
                        class: "w-4 h-4 text-blue-600"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vueExports.vModelRadio, vueExports.unref(tipoDisponibilizar)]
                      ]),
                      vueExports.createVNode("label", {
                        for: "disp-adiantamento",
                        class: "flex-1 cursor-pointer"
                      }, [
                        vueExports.createVNode("strong", { class: "text-gray-900" }, " Apenas Adiantamentos"),
                        vueExports.createVNode("br"),
                        vueExports.createVNode("span", { class: "text-xs text-gray-600" }, "Disponibilizar apenas holerites de adiantamento")
                      ])
                    ]),
                    vueExports.createVNode("div", { class: "flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200" }, [
                      vueExports.withDirectives(vueExports.createVNode("input", {
                        type: "radio",
                        id: "disp-mensal",
                        value: "mensal",
                        "onUpdate:modelValue": ($event) => vueExports.isRef(tipoDisponibilizar) ? tipoDisponibilizar.value = $event : null,
                        class: "w-4 h-4 text-blue-600"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vueExports.vModelRadio, vueExports.unref(tipoDisponibilizar)]
                      ]),
                      vueExports.createVNode("label", {
                        for: "disp-mensal",
                        class: "flex-1 cursor-pointer"
                      }, [
                        vueExports.createVNode("strong", { class: "text-gray-900" }, " Apenas Folhas Mensais"),
                        vueExports.createVNode("br"),
                        vueExports.createVNode("span", { class: "text-xs text-gray-600" }, "Disponibilizar apenas holerites mensais completos")
                      ])
                    ]),
                    vueExports.createVNode("div", { class: "flex items-center gap-3 p-3 bg-white rounded-lg border border-blue-200" }, [
                      vueExports.withDirectives(vueExports.createVNode("input", {
                        type: "radio",
                        id: "disp-todos",
                        value: "todos",
                        "onUpdate:modelValue": ($event) => vueExports.isRef(tipoDisponibilizar) ? tipoDisponibilizar.value = $event : null,
                        class: "w-4 h-4 text-blue-600"
                      }, null, 8, ["onUpdate:modelValue"]), [
                        [vueExports.vModelRadio, vueExports.unref(tipoDisponibilizar)]
                      ]),
                      vueExports.createVNode("label", {
                        for: "disp-todos",
                        class: "flex-1 cursor-pointer"
                      }, [
                        vueExports.createVNode("strong", { class: "text-gray-900" }, " Todos os Holerites"),
                        vueExports.createVNode("br"),
                        vueExports.createVNode("span", { class: "text-xs text-gray-600" }, "Disponibilizar todos os holerites listados")
                      ])
                    ])
                  ])
                ]),
                vueExports.createVNode("div", { class: "bg-gray-50 border border-gray-200 rounded-lg p-4" }, [
                  vueExports.createVNode("p", { class: "text-sm text-gray-700" }, [
                    vueExports.createVNode("strong", null, "Total a disponibilizar:"),
                    vueExports.createTextVNode(" " + vueExports.toDisplayString(contarHoleritesPorTipoDisp()) + " holerite(s) ", 1)
                  ]),
                  vueExports.createVNode("p", { class: "text-xs text-gray-500 mt-2" }, ' Os funcionrios podero visualizar e baixar seus holerites na rea "Meus Holerites" ')
                ]),
                vueExports.createVNode("div", { class: "flex gap-3 justify-end pt-4 border-t" }, [
                  vueExports.createVNode(_component_UiButton, {
                    variant: "secondary",
                    onClick: ($event) => mostrarModalDisponibilizar.value = false
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(" Cancelar ")
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  vueExports.createVNode(_component_UiButton, {
                    onClick: confirmarDisponibilizacao,
                    disabled: vueExports.unref(loading) || contarHoleritesPorTipoDisp() === 0
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(loading) ? "Disponibilizando..." : " Confirmar"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      if (vueExports.unref(mostrarNotificacao)) {
        _push(ssrRenderComponent_1(_component_UiNotification, {
          show: vueExports.unref(mostrarNotificacao),
          title: vueExports.unref(notificacao).title,
          message: vueExports.unref(notificacao).message,
          variant: vueExports.unref(notificacao).variant,
          onClose: ($event) => mostrarNotificacao.value = false
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$8 = _sfc_main$8.setup;
_sfc_main$8.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/holerites.vue");
  return _sfc_setup$8 ? _sfc_setup$8(props, ctx) : void 0;
};

const holeritesBztWzTbT = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$8
}, Symbol.toStringTag, { value: 'Module' }));

//#region src/index.ts
const DEBOUNCE_DEFAULTS = { trailing: true };
/**
Debounce functions
@param fn - Promise-returning/async function to debounce.
@param wait - Milliseconds to wait before calling `fn`. Default value is 25ms
@returns A function that delays calling `fn` until after `wait` milliseconds have elapsed since the last time it was called.
@example
```
import { debounce } from 'perfect-debounce';
const expensiveCall = async input => input;
const debouncedFn = debounce(expensiveCall, 200);
for (const number of [1, 2, 3]) {
console.log(await debouncedFn(number));
}
//=> 1
//=> 2
//=> 3
```
*/
function debounce(fn, wait = 25, options = {}) {
	options = {
		...DEBOUNCE_DEFAULTS,
		...options
	};
	if (!Number.isFinite(wait)) throw new TypeError("Expected `wait` to be a finite number");
	let leadingValue;
	let timeout;
	let resolveList = [];
	let currentPromise;
	let trailingArgs;
	const applyFn = (_this, args) => {
		currentPromise = _applyPromised(fn, _this, args);
		currentPromise.finally(() => {
			currentPromise = null;
			if (options.trailing && trailingArgs && !timeout) {
				const promise = applyFn(_this, trailingArgs);
				trailingArgs = null;
				return promise;
			}
		});
		return currentPromise;
	};
	const debounced = function(...args) {
		if (options.trailing) trailingArgs = args;
		if (currentPromise) return currentPromise;
		return new Promise((resolve) => {
			const shouldCallNow = !timeout && options.leading;
			clearTimeout(timeout);
			timeout = setTimeout(() => {
				timeout = null;
				const promise = options.leading ? leadingValue : applyFn(this, args);
				trailingArgs = null;
				for (const _resolve of resolveList) _resolve(promise);
				resolveList = [];
			}, wait);
			if (shouldCallNow) {
				leadingValue = applyFn(this, args);
				resolve(leadingValue);
			} else resolveList.push(resolve);
		});
	};
	const _clearTimeout = (timer) => {
		if (timer) {
			clearTimeout(timer);
			timeout = null;
		}
	};
	debounced.isPending = () => !!timeout;
	debounced.cancel = () => {
		_clearTimeout(timeout);
		resolveList = [];
		trailingArgs = null;
	};
	debounced.flush = () => {
		_clearTimeout(timeout);
		if (!trailingArgs || currentPromise) return;
		const args = trailingArgs;
		trailingArgs = null;
		return applyFn(this, args);
	};
	return debounced;
}
async function _applyPromised(fn, _this, args) {
	return await fn.apply(_this, args);
}

const clientOnlySymbol = /* @__PURE__ */ Symbol.for("nuxt:client-only");
vueExports.defineComponent({
  name: "ClientOnly",
  inheritAttrs: false,
  props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
  ...false,
  setup(props, { slots, attrs }) {
    const mounted = vueExports.shallowRef(false);
    const vm = vueExports.getCurrentInstance();
    if (vm) {
      vm._nuxtClientOnly = true;
    }
    vueExports.provide(clientOnlySymbol, true);
    return () => {
      if (mounted.value) {
        const vnodes = slots.default?.();
        if (vnodes && vnodes.length === 1) {
          return [vueExports.cloneVNode(vnodes[0], attrs)];
        }
        return vnodes;
      }
      const slot = slots.fallback || slots.placeholder;
      if (slot) {
        return vueExports.h(slot);
      }
      const fallbackStr = props.fallback || props.placeholder || "";
      const fallbackTag = props.fallbackTag || props.placeholderTag || "span";
      return vueExports.createElementBlock(fallbackTag, attrs, fallbackStr);
    };
  }
});
function useAsyncData(...args) {
  const autoKey = typeof args[args.length - 1] === "string" ? args.pop() : void 0;
  if (_isAutoKeyNeeded(args[0], args[1])) {
    args.unshift(autoKey);
  }
  let [_key, _handler, options = {}] = args;
  const key = vueExports.computed(() => vueExports.toValue(_key));
  if (typeof key.value !== "string") {
    throw new TypeError("[nuxt] [useAsyncData] key must be a string.");
  }
  if (typeof _handler !== "function") {
    throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");
  }
  const nuxtApp = useNuxtApp();
  options.server ??= true;
  options.default ??= getDefault;
  options.getCachedData ??= getDefaultCachedData;
  options.lazy ??= false;
  options.immediate ??= true;
  options.deep ??= asyncDataDefaults.deep;
  options.dedupe ??= "cancel";
  options._functionName || "useAsyncData";
  nuxtApp._asyncData[key.value];
  function createInitialFetch() {
    const initialFetchOptions = { cause: "initial", dedupe: options.dedupe };
    if (!nuxtApp._asyncData[key.value]?._init) {
      initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: "initial" });
      nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);
    }
    return () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);
  }
  const initialFetch = createInitialFetch();
  const asyncData = nuxtApp._asyncData[key.value];
  asyncData._deps++;
  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;
  if (fetchOnServer && options.immediate) {
    const promise = initialFetch();
    if (vueExports.getCurrentInstance()) {
      vueExports.onServerPrefetch(() => promise);
    } else {
      nuxtApp.hook("app:created", async () => {
        await promise;
      });
    }
  }
  const asyncReturn = {
    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),
    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),
    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),
    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),
    refresh: (...args2) => {
      if (!nuxtApp._asyncData[key.value]?._init) {
        const initialFetch2 = createInitialFetch();
        return initialFetch2();
      }
      return nuxtApp._asyncData[key.value].execute(...args2);
    },
    execute: (...args2) => asyncReturn.refresh(...args2),
    clear: () => {
      const entry = nuxtApp._asyncData[key.value];
      if (entry?._abortController) {
        try {
          entry._abortController.abort(new DOMException("AsyncData aborted by user.", "AbortError"));
        } finally {
          entry._abortController = void 0;
        }
      }
      clearNuxtDataByKey(nuxtApp, key.value);
    }
  };
  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);
  Object.assign(asyncDataPromise, asyncReturn);
  return asyncDataPromise;
}
function writableComputedRef(getter) {
  return vueExports.computed({
    get() {
      return getter()?.value;
    },
    set(value) {
      const ref2 = getter();
      if (ref2) {
        ref2.value = value;
      }
    }
  });
}
function _isAutoKeyNeeded(keyOrFetcher, fetcher) {
  if (typeof keyOrFetcher === "string") {
    return false;
  }
  if (typeof keyOrFetcher === "object" && keyOrFetcher !== null) {
    return false;
  }
  if (typeof keyOrFetcher === "function" && typeof fetcher === "function") {
    return false;
  }
  return true;
}
function clearNuxtDataByKey(nuxtApp, key) {
  if (key in nuxtApp.payload.data) {
    nuxtApp.payload.data[key] = void 0;
  }
  if (key in nuxtApp.payload._errors) {
    nuxtApp.payload._errors[key] = void 0;
  }
  if (nuxtApp._asyncData[key]) {
    nuxtApp._asyncData[key].data.value = vueExports.unref(nuxtApp._asyncData[key]._default());
    nuxtApp._asyncData[key].error.value = void 0;
    nuxtApp._asyncData[key].status.value = "idle";
  }
  if (key in nuxtApp._asyncDataPromises) {
    nuxtApp._asyncDataPromises[key] = void 0;
  }
}
function pick(obj, keys) {
  const newObj = {};
  for (const key of keys) {
    newObj[key] = obj[key];
  }
  return newObj;
}
function createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {
  nuxtApp.payload._errors[key] ??= void 0;
  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;
  const handler = _handler ;
  const _ref = options.deep ? vueExports.ref : vueExports.shallowRef;
  const hasCachedData = initialCachedData !== void 0;
  const unsubRefreshAsyncData = nuxtApp.hook("app:data:refresh", async (keys) => {
    if (!keys || keys.includes(key)) {
      await asyncData.execute({ cause: "refresh:hook" });
    }
  });
  const asyncData = {
    data: _ref(hasCachedData ? initialCachedData : options.default()),
    pending: vueExports.computed(() => asyncData.status.value === "pending"),
    error: vueExports.toRef(nuxtApp.payload._errors, key),
    status: vueExports.shallowRef("idle"),
    execute: (...args) => {
      const [_opts, newValue = void 0] = args;
      const opts = _opts && newValue === void 0 && typeof _opts === "object" ? _opts : {};
      if (nuxtApp._asyncDataPromises[key]) {
        if ((opts.dedupe ?? options.dedupe) === "defer") {
          return nuxtApp._asyncDataPromises[key];
        }
      }
      {
        const cachedData = "cachedData" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? "refresh:manual" });
        if (cachedData !== void 0) {
          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;
          asyncData.error.value = void 0;
          asyncData.status.value = "success";
          return Promise.resolve(cachedData);
        }
      }
      if (asyncData._abortController) {
        asyncData._abortController.abort(new DOMException("AsyncData request cancelled by deduplication", "AbortError"));
      }
      asyncData._abortController = new AbortController();
      asyncData.status.value = "pending";
      const cleanupController = new AbortController();
      const promise = new Promise(
        (resolve, reject) => {
          try {
            const timeout = opts.timeout ?? options.timeout;
            const mergedSignal = mergeAbortSignals([asyncData._abortController?.signal, opts?.signal], cleanupController.signal, timeout);
            if (mergedSignal.aborted) {
              const reason = mergedSignal.reason;
              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? "Aborted"), "AbortError"));
              return;
            }
            mergedSignal.addEventListener("abort", () => {
              const reason = mergedSignal.reason;
              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? "Aborted"), "AbortError"));
            }, { once: true, signal: cleanupController.signal });
            return Promise.resolve(handler(nuxtApp, { signal: mergedSignal })).then(resolve, reject);
          } catch (err) {
            reject(err);
          }
        }
      ).then(async (_result) => {
        let result = _result;
        if (options.transform) {
          result = await options.transform(_result);
        }
        if (options.pick) {
          result = pick(result, options.pick);
        }
        nuxtApp.payload.data[key] = result;
        asyncData.data.value = result;
        asyncData.error.value = void 0;
        asyncData.status.value = "success";
      }).catch((error) => {
        if (nuxtApp._asyncDataPromises[key] && nuxtApp._asyncDataPromises[key] !== promise) {
          return nuxtApp._asyncDataPromises[key];
        }
        if (asyncData._abortController?.signal.aborted) {
          return nuxtApp._asyncDataPromises[key];
        }
        if (typeof DOMException !== "undefined" && error instanceof DOMException && error.name === "AbortError") {
          asyncData.status.value = "idle";
          return nuxtApp._asyncDataPromises[key];
        }
        asyncData.error.value = createError(error);
        asyncData.data.value = vueExports.unref(options.default());
        asyncData.status.value = "error";
      }).finally(() => {
        cleanupController.abort();
        delete nuxtApp._asyncDataPromises[key];
      });
      nuxtApp._asyncDataPromises[key] = promise;
      return nuxtApp._asyncDataPromises[key];
    },
    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),
    _default: options.default,
    _deps: 0,
    _init: true,
    _hash: void 0,
    _off: () => {
      unsubRefreshAsyncData();
      if (nuxtApp._asyncData[key]?._init) {
        nuxtApp._asyncData[key]._init = false;
      }
      if (!hasCustomGetCachedData) {
        vueExports.nextTick(() => {
          if (!nuxtApp._asyncData[key]?._init) {
            clearNuxtDataByKey(nuxtApp, key);
            asyncData.execute = () => Promise.resolve();
          }
        });
      }
    }
  };
  return asyncData;
}
const getDefault = () => void 0;
const getDefaultCachedData = (key, nuxtApp, ctx) => {
  if (nuxtApp.isHydrating) {
    return nuxtApp.payload.data[key];
  }
  if (ctx.cause !== "refresh:manual" && ctx.cause !== "refresh:hook") {
    return nuxtApp.static.data[key];
  }
};
function mergeAbortSignals(signals, cleanupSignal, timeout) {
  const list = signals.filter((s) => !!s);
  if (typeof timeout === "number" && timeout >= 0) {
    const timeoutSignal = AbortSignal.timeout?.(timeout);
    if (timeoutSignal) {
      list.push(timeoutSignal);
    }
  }
  if (AbortSignal.any) {
    return AbortSignal.any(list);
  }
  const controller = new AbortController();
  for (const sig of list) {
    if (sig.aborted) {
      const reason = sig.reason ?? new DOMException("Aborted", "AbortError");
      try {
        controller.abort(reason);
      } catch {
        controller.abort();
      }
      return controller.signal;
    }
  }
  const onAbort = () => {
    const abortedSignal = list.find((s) => s.aborted);
    const reason = abortedSignal?.reason ?? new DOMException("Aborted", "AbortError");
    try {
      controller.abort(reason);
    } catch {
      controller.abort();
    }
  };
  for (const sig of list) {
    sig.addEventListener?.("abort", onAbort, { once: true, signal: cleanupSignal });
  }
  return controller.signal;
}
function useFetch(request, arg1, arg2) {
  const [opts = {}, autoKey] = [{}, arg1];
  const _request = vueExports.computed(() => vueExports.toValue(request));
  const key = vueExports.computed(() => vueExports.toValue(opts.key) || "$f" + hash$1([autoKey, typeof _request.value === "string" ? _request.value : "", ...generateOptionSegments(opts)]));
  if (!opts.baseURL && typeof _request.value === "string" && (_request.value[0] === "/" && _request.value[1] === "/")) {
    throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');
  }
  const {
    server,
    lazy,
    default: defaultFn,
    transform,
    pick: pick2,
    watch: watchSources,
    immediate,
    getCachedData,
    deep,
    dedupe,
    timeout,
    ...fetchOptions
  } = opts;
  const _fetchOptions = vueExports.reactive({
    ...fetchDefaults,
    ...fetchOptions,
    cache: typeof opts.cache === "boolean" ? void 0 : opts.cache
  });
  const _asyncDataOptions = {
    server,
    lazy,
    default: defaultFn,
    transform,
    pick: pick2,
    immediate,
    getCachedData,
    deep,
    dedupe,
    timeout,
    watch: watchSources === false ? [] : [...watchSources || [], _fetchOptions]
  };
  const asyncData = useAsyncData(watchSources === false ? key.value : key, (_, { signal }) => {
    let _$fetch = opts.$fetch || globalThis.$fetch;
    if (!opts.$fetch) {
      const isLocalFetch = typeof _request.value === "string" && _request.value[0] === "/" && (!vueExports.toValue(opts.baseURL) || vueExports.toValue(opts.baseURL)[0] === "/");
      if (isLocalFetch) {
        _$fetch = useRequestFetch();
      }
    }
    return _$fetch(_request.value, { signal, ..._fetchOptions });
  }, _asyncDataOptions);
  return asyncData;
}
function generateOptionSegments(opts) {
  const segments = [
    vueExports.toValue(opts.method)?.toUpperCase() || "GET",
    vueExports.toValue(opts.baseURL)
  ];
  for (const _obj of [opts.query || opts.params]) {
    const obj = vueExports.toValue(_obj);
    if (!obj) {
      continue;
    }
    const unwrapped = {};
    for (const [key, value] of Object.entries(obj)) {
      unwrapped[vueExports.toValue(key)] = vueExports.toValue(value);
    }
    segments.push(unwrapped);
  }
  if (opts.body) {
    const value = vueExports.toValue(opts.body);
    if (!value) {
      segments.push(hash$1(value));
    } else if (value instanceof ArrayBuffer) {
      segments.push(hash$1(Object.fromEntries([...new Uint8Array(value).entries()].map(([k, v]) => [k, v.toString()]))));
    } else if (value instanceof FormData) {
      const obj = {};
      for (const entry of value.entries()) {
        const [key, val] = entry;
        obj[key] = val instanceof File ? val.name : val;
      }
      segments.push(hash$1(obj));
    } else if (isPlainObject_1(value)) {
      segments.push(hash$1(vueExports.reactive(value)));
    } else {
      try {
        segments.push(hash$1(value));
      } catch {
        console.warn("[useFetch] Failed to hash body", value);
      }
    }
  }
  return segments;
}
const useAdmin = () => {
  const adminInfo = vueExports.ref(null);
  const loading = vueExports.ref(false);
  const buscarAdmin = async () => {
    console.log(" [useAdmin] Buscando informaes da admin...");
    loading.value = true;
    try {
      const { data } = await useFetch("/api/admin/info", "$64lVkas657");
      console.log(" [useAdmin] Resposta recebida:", data.value);
      if (data.value?.success) {
        adminInfo.value = data.value.data;
        console.log(" [useAdmin] Admin carregada:", adminInfo.value);
      } else {
        console.log(" [useAdmin] Resposta sem sucesso");
      }
    } catch (error) {
      console.error(" [useAdmin] Erro ao buscar admin:", error);
    } finally {
      loading.value = false;
    }
  };
  const nomeAdmin = vueExports.computed(() => {
    return adminInfo.value?.nome || "Silvana Qualitec";
  });
  const idAdmin = vueExports.computed(() => {
    return adminInfo.value?.id || null;
  });
  const emailAdmin = vueExports.computed(() => {
    return adminInfo.value?.email || "silvana@qualitec.com.br";
  });
  return {
    adminInfo: vueExports.readonly(adminInfo),
    loading: vueExports.readonly(loading),
    nomeAdmin,
    idAdmin,
    emailAdmin,
    buscarAdmin
  };
};

const _sfc_main$6 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "FuncionarioDadosPessoais",
  __ssrInlineRender: true,
  props: {
    form: {}
  },
  setup(__props) {
    const sexoOptions = [
      { value: "M", label: "Masculino" },
      { value: "F", label: "Feminino" },
      { value: "O", label: "Outro" }
    ];
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiInput = __nuxt_component_4;
      const _component_UiInputPIS = __nuxt_component_1$2;
      const _component_UiSelect = __nuxt_component_6$1;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-4" }, _attrs))}><h3 class="text-lg font-bold text-gray-800 mb-4"> Dados Pessoais</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="md:col-span-2">`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.nome_completo,
        "onUpdate:modelValue": ($event) => __props.form.nome_completo = $event,
        label: "Nome Completo",
        required: "",
        placeholder: "Digite o nome completo"
      }, null, _parent));
      _push(`</div>`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.cpf,
        "onUpdate:modelValue": ($event) => __props.form.cpf = $event,
        label: "CPF",
        required: "",
        placeholder: "000.000.000-00"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInputPIS, {
        modelValue: __props.form.pis_pasep,
        "onUpdate:modelValue": ($event) => __props.form.pis_pasep = $event,
        label: "PIS/PASEP",
        placeholder: "000.00000.00-0"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.rg,
        "onUpdate:modelValue": ($event) => __props.form.rg = $event,
        label: "RG",
        placeholder: "00.000.000-0"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.data_nascimento,
        "onUpdate:modelValue": ($event) => __props.form.data_nascimento = $event,
        type: "date",
        label: "Data de Nascimento"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.sexo,
        "onUpdate:modelValue": ($event) => __props.form.sexo = $event,
        options: sexoOptions,
        label: "Sexo",
        placeholder: "Selecione..."
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.telefone,
        "onUpdate:modelValue": ($event) => __props.form.telefone = $event,
        label: "Telefone",
        placeholder: "(11) 99999-9999"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.email_pessoal,
        "onUpdate:modelValue": ($event) => __props.form.email_pessoal = $event,
        type: "email",
        uppercase: false,
        label: "Email Pessoal",
        placeholder: "email@pessoal.com"
      }, null, _parent));
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$6 = _sfc_main$6.setup;
_sfc_main$6.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/funcionarios/FuncionarioDadosPessoais.vue");
  return _sfc_setup$6 ? _sfc_setup$6(props, ctx) : void 0;
};
const FuncionarioDadosPessoais = Object.assign(_sfc_main$6, { __name: "FuncionariosFuncionarioDadosPessoais" });
const _sfc_main$5$1 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "FuncionarioDadosProfissionais",
  __ssrInlineRender: true,
  props: {
    form: {},
    showEmpresaSelect: { type: Boolean, default: false },
    empresasOptions: {},
    departamentosOptions: {},
    cargosOptions: {},
    jornadaOptionsComputed: {},
    responsavelOptions: {}
  },
  setup(__props) {
    const tipoContratoOptions = [
      { value: "CLT", label: "CLT" },
      { value: "PJ", label: "PJ" },
      { value: "Estagio", label: "Estgio" },
      { value: "Temporario", label: "Temporrio" }
    ];
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiSelect = __nuxt_component_6$1;
      const _component_UiInput = __nuxt_component_4;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-4" }, _attrs))}><h3 class="text-lg font-bold text-gray-800 mb-4"> Dados Profissionais</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4">`);
      if (__props.showEmpresaSelect) {
        _push(`<div class="md:col-span-2">`);
        _push(ssrRenderComponent_1(_component_UiSelect, {
          modelValue: __props.form.empresa_id,
          "onUpdate:modelValue": ($event) => __props.form.empresa_id = $event,
          options: __props.empresasOptions,
          label: "Empresa",
          placeholder: "Selecione a empresa..."
        }, null, _parent));
        _push(`</div>`);
      } else {
        _push(`<!---->`);
      }
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.departamento_id,
        "onUpdate:modelValue": ($event) => __props.form.departamento_id = $event,
        options: __props.departamentosOptions,
        label: "Departamento",
        placeholder: "Selecione..."
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.cargo_id,
        "onUpdate:modelValue": ($event) => __props.form.cargo_id = $event,
        options: __props.cargosOptions,
        label: "Cargo",
        placeholder: "Selecione..."
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.tipo_contrato,
        "onUpdate:modelValue": ($event) => __props.form.tipo_contrato = $event,
        options: tipoContratoOptions,
        label: "Tipo de Contrato"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.data_admissao,
        "onUpdate:modelValue": ($event) => __props.form.data_admissao = $event,
        type: "date",
        label: "Data de Admisso"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.matricula,
        "onUpdate:modelValue": ($event) => __props.form.matricula = $event,
        label: "Matrcula/Registro",
        placeholder: "Gerado automaticamente"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.jornada_trabalho_id,
        "onUpdate:modelValue": ($event) => __props.form.jornada_trabalho_id = $event,
        options: __props.jornadaOptionsComputed,
        label: "Jornada de Trabalho"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.responsavel_id,
        "onUpdate:modelValue": ($event) => __props.form.responsavel_id = $event,
        options: __props.responsavelOptions,
        label: "Responsvel Direto",
        placeholder: "Selecione..."
      }, null, _parent));
      _push(`</div><div class="mt-4 p-4 bg-blue-50 rounded-xl"><p class="text-sm text-blue-700">  <strong>Responsvel Padro:</strong> Silvana  automaticamente definida como responsvel direto de todos os funcionrios. Voc pode alterar se necessrio, mas por padro ela supervisiona toda a equipe. </p></div></div>`);
    };
  }
});
const _sfc_setup$5$1 = _sfc_main$5$1.setup;
_sfc_main$5$1.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/funcionarios/FuncionarioDadosProfissionais.vue");
  return _sfc_setup$5$1 ? _sfc_setup$5$1(props, ctx) : void 0;
};
const FuncionarioDadosProfissionais = Object.assign(_sfc_main$5$1, { __name: "FuncionariosFuncionarioDadosProfissionais" });
const _sfc_main$4$1 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "FuncionarioAcessoSistema",
  __ssrInlineRender: true,
  props: {
    form: {}
  },
  setup(__props) {
    const tipoAcessoOptions = [
      { value: "funcionario", label: "Funcionrio" },
      { value: "admin", label: "Administrador" }
    ];
    const statusOptions = [
      { value: "ativo", label: "Ativo" },
      { value: "inativo", label: "Inativo" }
    ];
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiInput = __nuxt_component_4;
      const _component_UiSelect = __nuxt_component_6$1;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-4" }, _attrs))}><h3 class="text-lg font-bold text-gray-800 mb-4"> Acesso ao Sistema</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4">`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.email_login,
        "onUpdate:modelValue": ($event) => __props.form.email_login = $event,
        type: "email",
        uppercase: false,
        label: "Email de Login",
        required: "",
        placeholder: "email@empresa.com"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.senha,
        "onUpdate:modelValue": ($event) => __props.form.senha = $event,
        type: "password",
        label: "Senha",
        required: "",
        "show-password-toggle": "",
        placeholder: ""
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.tipo_acesso,
        "onUpdate:modelValue": ($event) => __props.form.tipo_acesso = $event,
        options: tipoAcessoOptions,
        label: "Tipo de Acesso"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.status,
        "onUpdate:modelValue": ($event) => __props.form.status = $event,
        options: statusOptions,
        label: "Status do Usurio"
      }, null, _parent));
      _push(`</div><div class="mt-4 p-4 bg-blue-50 rounded-xl"><h4 class="font-semibold text-blue-800 mb-2"> Tipos de Acesso:</h4><ul class="text-sm text-blue-700 space-y-1"><li><strong>Funcionrio:</strong> Visualiza apenas seus prprios dados</li><li><strong>Administrador:</strong> Acesso total ao sistema</li></ul></div></div>`);
    };
  }
});
const _sfc_setup$4$1 = _sfc_main$4$1.setup;
_sfc_main$4$1.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/funcionarios/FuncionarioAcessoSistema.vue");
  return _sfc_setup$4$1 ? _sfc_setup$4$1(props, ctx) : void 0;
};
const FuncionarioAcessoSistema = Object.assign(_sfc_main$4$1, { __name: "FuncionariosFuncionarioAcessoSistema" });
const _sfc_main$3$1 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "FuncionarioDadosFinanceiros",
  __ssrInlineRender: true,
  props: {
    form: {}
  },
  setup(__props) {
    const tipoSalarioOptions = [
      { value: "mensal", label: "Mensal" },
      { value: "quinzenal", label: "Quinzenal" },
      { value: "horista", label: "Horista" }
    ];
    const formaPagamentoOptions = [
      { value: "deposito", label: "Depsito Bancrio" },
      { value: "pix", label: "PIX" }
    ];
    const tipoContaOptions = [
      { value: "corrente", label: "Conta Corrente" },
      { value: "poupanca", label: "Conta Poupana" },
      { value: "salario", label: "Conta Salrio" }
    ];
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiInput = __nuxt_component_4;
      const _component_UiSelect = __nuxt_component_6$1;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-4" }, _attrs))}><h3 class="text-lg font-bold text-gray-800 mb-4"> Dados Financeiros</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4">`);
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.salario_base,
        "onUpdate:modelValue": ($event) => __props.form.salario_base = $event,
        type: "number",
        uppercase: false,
        step: "0.01",
        label: "Salrio Base (R$)",
        placeholder: "0,00"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.tipo_salario,
        "onUpdate:modelValue": ($event) => __props.form.tipo_salario = $event,
        options: tipoSalarioOptions,
        label: "Tipo de Salrio"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.numero_dependentes,
        "onUpdate:modelValue": ($event) => __props.form.numero_dependentes = $event,
        type: "number",
        uppercase: false,
        min: "0",
        step: "1",
        label: "Nmero de Dependentes (IRRF)",
        placeholder: "0"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.banco,
        "onUpdate:modelValue": ($event) => __props.form.banco = $event,
        label: "Banco",
        placeholder: "Nome do banco"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.agencia,
        "onUpdate:modelValue": ($event) => __props.form.agencia = $event,
        label: "Agncia",
        placeholder: "0000"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiInput, {
        modelValue: __props.form.conta,
        "onUpdate:modelValue": ($event) => __props.form.conta = $event,
        label: "Conta",
        placeholder: "00000-0"
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.tipo_conta,
        "onUpdate:modelValue": ($event) => __props.form.tipo_conta = $event,
        options: tipoContaOptions,
        label: "Tipo de Conta",
        placeholder: "Selecione..."
      }, null, _parent));
      _push(ssrRenderComponent_1(_component_UiSelect, {
        modelValue: __props.form.forma_pagamento,
        "onUpdate:modelValue": ($event) => __props.form.forma_pagamento = $event,
        options: formaPagamentoOptions,
        label: "Forma de Pagamento"
      }, null, _parent));
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$3$1 = _sfc_main$3$1.setup;
_sfc_main$3$1.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/funcionarios/FuncionarioDadosFinanceiros.vue");
  return _sfc_setup$3$1 ? _sfc_setup$3$1(props, ctx) : void 0;
};
const FuncionarioDadosFinanceiros = Object.assign(_sfc_main$3$1, { __name: "FuncionariosFuncionarioDadosFinanceiros" });
const useDepartamentos = () => {
  const departamentos = vueExports.ref([]);
  const loading = vueExports.ref(false);
  const carregarDepartamentos = async () => {
    loading.value = true;
    try {
      const resultado = await $fetch("/api/departamentos");
      if (resultado.success && resultado.data) {
        departamentos.value = Array.isArray(resultado.data) ? resultado.data : [];
        console.log(" Departamentos carregados:", departamentos.value.length);
      } else {
        departamentos.value = [];
      }
    } catch (error) {
      console.error("Erro ao carregar departamentos:", error);
      departamentos.value = [];
    } finally {
      loading.value = false;
    }
  };
  const opcoesDepartamentos = vueExports.computed(() => {
    if (!Array.isArray(departamentos.value)) {
      return [];
    }
    return departamentos.value.map((dep) => ({
      value: dep.id.toString(),
      label: dep.nome
    }));
  });
  return {
    departamentos,
    loading,
    carregarDepartamentos,
    opcoesDepartamentos
  };
};
const _sfc_main$2$1 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "FuncionarioForm",
  __ssrInlineRender: true,
  props: {
    form: {},
    isEditing: { type: Boolean },
    showEmpresaSelect: { type: Boolean, default: false },
    loading: { type: Boolean, default: false }
  },
  emits: ["submit", "cancel", "salvar-e-enviar"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const abaAtiva = vueExports.ref("pessoais");
    const tabs = [
      { id: "pessoais", label: "Dados Pessoais", icon: "" },
      { id: "profissionais", label: "Dados Profissionais", icon: "" },
      { id: "acesso", label: "Acesso ao Sistema", icon: "" },
      { id: "financeiros", label: "Dados Financeiros", icon: "" },
      { id: "beneficios", label: "Benefcios e Descontos", icon: "" }
    ];
    const tipoDescontoOptions = [
      { value: "sem_desconto", label: "Sem Desconto" },
      { value: "percentual", label: "Percentual (%)" },
      { value: "valor_fixo", label: "Valor Fixo (R$)" }
    ];
    const planoSaudeOptions = [
      { value: "individual", label: "Individual" },
      { value: "familiar", label: "Familiar" },
      { value: "coparticipacao", label: "Coparticipao" }
    ];
    const tipoBeneficioOptions = [
      { value: "diario", label: "Valor Dirio" },
      { value: "mensal", label: "Valor Mensal" },
      { value: "fixo", label: "Valor Fixo" }
    ];
    useJornadas();
    const { opcoesJornadas, carregarJornadas } = useJornadas();
    const { carregarEmpresas, obterOpcoesEmpresas } = useEmpresas();
    const { opcoesDepartamentos, carregarDepartamentos } = useDepartamentos();
    const { opcoesCargos, carregarCargos } = useCargos();
    const { nomeAdmin, idAdmin } = useAdmin();
    const inicializarBeneficios = () => {
      console.log(" [FuncionarioForm] Inicializando benefcios...");
      if (!props.form) {
        console.error(" [FuncionarioForm] ERRO: No  possvel inicializar benefcios - form  null!");
        return;
      }
      if (!props.form.beneficios) {
        console.log(" [FuncionarioForm] Criando estrutura de benefcios");
        props.form.beneficios = vueExports.reactive({
          vale_transporte: {
            ativo: false,
            valor: 0,
            valor_mensal: 0,
            tipo_desconto: "percentual",
            percentual_desconto: 6,
            valor_desconto: 0
          },
          cesta_basica: {
            ativo: false,
            valor: 0,
            valor_mensal: 0,
            tipo_desconto: "sem_desconto",
            percentual_desconto: 0,
            valor_desconto: 0
          },
          plano_saude: {
            ativo: false,
            plano: "individual",
            valor_empresa: 0,
            valor_funcionario: 0,
            dependentes: 0
          },
          plano_odonto: {
            ativo: false,
            valor_funcionario: 0,
            dependentes: 0
          },
          personalizados: []
        });
      } else {
        console.log(" [FuncionarioForm] Benefcios j existem");
      }
      if (!props.form.beneficios.personalizados) {
        console.log(" [FuncionarioForm] Criando array de benefcios personalizados");
        props.form.beneficios.personalizados = vueExports.reactive([]);
      } else if (!vueExports.isReactive(props.form.beneficios.personalizados)) {
        console.log(" [FuncionarioForm] Tornando benefcios personalizados reativos e convertendo tipos");
        const beneficiosConvertidos = props.form.beneficios.personalizados.map((beneficio) => ({
          ...beneficio,
          valor: typeof beneficio.valor === "string" ? parseFloat(beneficio.valor) || 0 : beneficio.valor,
          percentual_desconto: typeof beneficio.percentual_desconto === "string" ? parseFloat(beneficio.percentual_desconto) || 0 : beneficio.percentual_desconto,
          valor_desconto: typeof beneficio.valor_desconto === "string" ? parseFloat(beneficio.valor_desconto) || 0 : beneficio.valor_desconto
        }));
        props.form.beneficios.personalizados = vueExports.reactive(beneficiosConvertidos);
      } else {
        props.form.beneficios.personalizados.forEach((beneficio) => {
          if (typeof beneficio.valor === "string") {
            beneficio.valor = parseFloat(beneficio.valor) || 0;
          }
          if (typeof beneficio.percentual_desconto === "string") {
            beneficio.percentual_desconto = parseFloat(beneficio.percentual_desconto) || 0;
          }
          if (typeof beneficio.valor_desconto === "string") {
            beneficio.valor_desconto = parseFloat(beneficio.valor_desconto) || 0;
          }
        });
      }
      if (!props.form.descontos_personalizados) {
        console.log(" [FuncionarioForm] Criando array de descontos personalizados");
        props.form.descontos_personalizados = vueExports.reactive([]);
      } else if (!vueExports.isReactive(props.form.descontos_personalizados)) {
        console.log(" [FuncionarioForm] Tornando descontos personalizados reativos");
        props.form.descontos_personalizados = vueExports.reactive([...props.form.descontos_personalizados]);
      }
      console.log(" [FuncionarioForm] Benefcios inicializados:", {
        beneficiosExist: !!props.form.beneficios,
        valeTransporte: !!props.form.beneficios?.vale_transporte,
        cestaBasica: !!props.form.beneficios?.cesta_basica,
        personalizadosCount: props.form.beneficios?.personalizados?.length || 0
      });
    };
    vueExports.watch(() => props.form, (novoForm, formAnterior) => {
      console.log(" [FuncionarioForm] Watch form disparado:", {
        novoFormExists: !!novoForm,
        formAnteriorExists: !!formAnterior,
        novoFormKeys: novoForm ? Object.keys(novoForm) : "null",
        beneficiosExists: novoForm?.beneficios ? "Sim" : "No"
      });
      if (novoForm && !novoForm.beneficios) {
        console.log(" [FuncionarioForm] Benefcios no encontrados no watch, inicializando...");
        inicializarBeneficios();
      } else if (novoForm?.beneficios) {
        console.log(" [FuncionarioForm] Benefcios j existem no form");
      }
    }, { deep: true, immediate: true });
    vueExports.watch(() => props.form.beneficios?.personalizados, (novos, antigos) => {
      if (novos && novos.length > 0) {
        console.log(" Benefcios personalizados alterados:", novos);
        novos.forEach((beneficio, index) => {
          garantirValoresNumericos(beneficio);
          console.log(`Benefcio ${index}:`, {
            nome: beneficio.nome,
            tipo_valor: beneficio.tipo_valor,
            valor: beneficio.valor,
            valor_tipo: typeof beneficio.valor,
            ativo: beneficio.ativo
          });
        });
      }
    }, { deep: true });
    vueExports.watch(() => props.form.tipo_contrato, (novoTipo, tipoAnterior) => {
      if (novoTipo === "PJ" && tipoAnterior !== "PJ") {
        console.log(" Funcionrio alterado para PJ - removendo descontos em folha");
        if (props.form.beneficios) {
          if (props.form.beneficios.vale_transporte) {
            props.form.beneficios.vale_transporte.tipo_desconto = "sem_desconto";
            props.form.beneficios.vale_transporte.percentual_desconto = 0;
            props.form.beneficios.vale_transporte.valor_desconto = 0;
          }
          if (props.form.beneficios.cesta_basica) {
            props.form.beneficios.cesta_basica.tipo_desconto = "sem_desconto";
            props.form.beneficios.cesta_basica.percentual_desconto = 0;
            props.form.beneficios.cesta_basica.valor_desconto = 0;
          }
          if (props.form.beneficios.plano_saude) {
            props.form.beneficios.plano_saude.valor_funcionario = 0;
          }
          if (props.form.beneficios.plano_odonto) {
            props.form.beneficios.plano_odonto.valor_funcionario = 0;
          }
          if (props.form.beneficios.personalizados) {
            props.form.beneficios.personalizados.forEach((beneficio) => {
              beneficio.tipo_desconto = "sem_desconto";
              beneficio.percentual_desconto = 0;
              beneficio.valor_desconto = 0;
            });
          }
        }
        if (props.form.descontos_personalizados) {
          props.form.descontos_personalizados.splice(0);
        }
        console.log(" Descontos removidos para funcionrio PJ");
      }
    });
    vueExports.watch(() => props.form.nome_completo, async (novoNome, nomeAntigo) => {
      if (novoNome && !nomeAntigo || !novoNome && nomeAntigo) {
        console.log(" Recarregando dados dos selects...");
        await Promise.all([
          carregarJornadas(),
          carregarEmpresas(),
          carregarDepartamentos(),
          carregarCargos()
        ]);
      }
    });
    const departamentosOptions = vueExports.computed(() => opcoesDepartamentos.value);
    const cargosOptions = vueExports.computed(() => opcoesCargos.value);
    const responsavelOptions = vueExports.computed(() => {
      const options = [];
      options.push({
        value: 1,
        label: "Silvana (Responsvel Padro) "
      });
      if (idAdmin.value && nomeAdmin.value && idAdmin.value !== 1) {
        options.push({
          value: idAdmin.value,
          label: `${nomeAdmin.value} (Admin)`
        });
      }
      options.push({
        value: null,
        label: "Nenhum responsvel"
      });
      return options;
    });
    const empresasOptions = vueExports.computed(() => obterOpcoesEmpresas.value);
    const jornadaOptionsComputed = vueExports.computed(() => opcoesJornadas.value);
    const adicionarDesconto = () => {
      props.form.descontos_personalizados.push({
        descricao: "",
        tipo: "valor_fixo",
        valor: 0,
        percentual: 0,
        recorrente: true,
        parcelas: 1
      });
    };
    const removerDesconto = (index) => {
      if (props.form.descontos_personalizados) {
        props.form.descontos_personalizados.splice(index, 1);
      }
    };
    const adicionarBeneficioPersonalizado = () => {
      if (!props.form.beneficios.personalizados) {
        props.form.beneficios.personalizados = vueExports.reactive([]);
      }
      props.form.beneficios.personalizados.push({
        icone: "",
        nome: "",
        ativo: false,
        valor: 0,
        // Garantir que seja nmero
        tipo_valor: "mensal",
        tipo_desconto: "sem_desconto",
        percentual_desconto: 0,
        // Garantir que seja nmero
        valor_desconto: 0,
        // Garantir que seja nmero
        descricao: ""
      });
    };
    const removerBeneficioPersonalizado = (index) => {
      if (props.form.beneficios.personalizados) {
        props.form.beneficios.personalizados.splice(index, 1);
      }
    };
    const garantirValoresNumericos = (beneficio) => {
      if (typeof beneficio.valor === "string") {
        beneficio.valor = parseFloat(beneficio.valor) || 0;
      }
      if (typeof beneficio.percentual_desconto === "string") {
        beneficio.percentual_desconto = parseFloat(beneficio.percentual_desconto) || 0;
      }
      if (typeof beneficio.valor_desconto === "string") {
        beneficio.valor_desconto = parseFloat(beneficio.valor_desconto) || 0;
      }
    };
    const calcularTotalBeneficios = () => {
      let total = 0;
      if (props.form.beneficios?.vale_transporte?.ativo) {
        const valorMensal = props.form.beneficios.vale_transporte.valor_mensal || (props.form.beneficios.vale_transporte.valor || 0) * 22;
        total += valorMensal;
      }
      if (props.form.beneficios?.cesta_basica?.ativo) {
        const valorMensal = props.form.beneficios.cesta_basica.valor_mensal || (props.form.beneficios.cesta_basica.valor || 0) * 22;
        total += valorMensal;
      }
      if (props.form.beneficios?.plano_saude?.ativo) {
        total += props.form.beneficios.plano_saude.valor_empresa || 0;
      }
      if (props.form.beneficios?.personalizados) {
        props.form.beneficios.personalizados.forEach((beneficio) => {
          if (beneficio.ativo) {
            let valorBeneficio = beneficio.valor || 0;
            if (beneficio.tipo_valor === "diario") {
              valorBeneficio = valorBeneficio * 22;
            }
            total += valorBeneficio;
          }
        });
      }
      return total;
    };
    const calcularTotalDescontos = () => {
      let total = 0;
      const salarioBase = parseFloat(props.form.salario_base) || 0;
      if (props.form.tipo_contrato === "PJ") {
        return 0;
      }
      if (props.form.beneficios?.vale_transporte?.ativo) {
        const vt = props.form.beneficios.vale_transporte;
        if (vt.tipo_desconto === "percentual") {
          total += salarioBase * (vt.percentual_desconto || 0) / 100;
        } else if (vt.tipo_desconto === "valor_fixo") {
          total += vt.valor_desconto || 0;
        }
      }
      if (props.form.beneficios?.cesta_basica?.ativo) {
        const cb = props.form.beneficios.cesta_basica;
        if (cb.tipo_desconto === "percentual") {
          total += salarioBase * (cb.percentual_desconto || 0) / 100;
        } else if (cb.tipo_desconto === "valor_fixo") {
          total += cb.valor_desconto || 0;
        }
      }
      if (props.form.beneficios?.plano_saude?.ativo) {
        total += props.form.beneficios.plano_saude.valor_funcionario || 0;
      }
      if (props.form.beneficios?.plano_odonto?.ativo) {
        total += props.form.beneficios.plano_odonto.valor_funcionario || 0;
      }
      if (props.form.beneficios?.personalizados) {
        props.form.beneficios.personalizados.forEach((beneficio) => {
          if (beneficio.ativo) {
            if (beneficio.tipo_desconto === "percentual") {
              total += salarioBase * (beneficio.percentual_desconto || 0) / 100;
            } else if (beneficio.tipo_desconto === "valor_fixo") {
              total += beneficio.valor_desconto || 0;
            }
          }
        });
      }
      props.form.descontos_personalizados?.forEach((desconto) => {
        if (desconto.tipo === "percentual") {
          total += salarioBase * (desconto.percentual || 0) / 100;
        } else if (desconto.tipo === "valor_fixo") {
          total += desconto.valor || 0;
        }
      });
      return total;
    };
    const calcularSaldoLiquido = () => {
      return calcularTotalBeneficios() - calcularTotalDescontos();
    };
    const handleSubmit = () => {
      emit("submit");
    };
    const salvarEEnviarAcesso = () => {
      emit("salvar-e-enviar");
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiCheckbox = __nuxt_component_0$2;
      const _component_UiInput = __nuxt_component_4;
      const _component_UiSelect = __nuxt_component_6$1;
      const _component_UiButton = __nuxt_component_1$4;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "space-y-6" }, _attrs))}><div class="border-b border-gray-200"><nav class="-mb-px flex space-x-8"><!--[-->`);
      ssrRenderList_1(tabs, (tab) => {
        _push(`<button class="${ssrRenderClass_1([
          "py-2 px-1 border-b-2 font-medium text-sm transition-colors",
          vueExports.unref(abaAtiva) === tab.id ? "border-blue-500 text-blue-600" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"
        ])}">${ssrInterpolate_1(tab.icon)} ${ssrInterpolate_1(tab.label)}</button>`);
      });
      _push(`<!--]--></nav></div><div class="min-h-[400px]">`);
      if (vueExports.unref(abaAtiva) === "pessoais") {
        _push(ssrRenderComponent_1(FuncionarioDadosPessoais, { form: __props.form }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(abaAtiva) === "profissionais") {
        _push(ssrRenderComponent_1(FuncionarioDadosProfissionais, {
          form: __props.form,
          "show-empresa-select": __props.showEmpresaSelect,
          "empresas-options": vueExports.unref(empresasOptions),
          "departamentos-options": vueExports.unref(departamentosOptions),
          "cargos-options": vueExports.unref(cargosOptions),
          "jornada-options-computed": vueExports.unref(jornadaOptionsComputed),
          "responsavel-options": vueExports.unref(responsavelOptions)
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(abaAtiva) === "acesso") {
        _push(ssrRenderComponent_1(FuncionarioAcessoSistema, { form: __props.form }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(abaAtiva) === "financeiros") {
        _push(ssrRenderComponent_1(FuncionarioDadosFinanceiros, { form: __props.form }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (vueExports.unref(abaAtiva) === "beneficios") {
        _push(`<div class="space-y-6"><h3 class="text-lg font-bold text-gray-800 mb-4"> Benefcios e Descontos</h3>`);
        if (__props.form.tipo_contrato === "PJ") {
          _push(`<div class="p-4 bg-yellow-50 border border-yellow-200 rounded-xl"><div class="flex items-center gap-2 text-yellow-700"><span class="text-xl"></span><div><h4 class="font-semibold">Funcionrio PJ - Sem Descontos em Folha</h4><p class="text-sm">Funcionrios PJ no podem ter descontos em folha de pagamento. Apenas benefcios sem desconto so permitidos.</p></div></div></div>`);
        } else {
          _push(`<!---->`);
        }
        if (__props.form.beneficios) {
          _push(`<div class="space-y-4"><h4 class="text-md font-semibold text-gray-700 mb-3"> Benefcios Padro</h4><div class="grid grid-cols-1 md:grid-cols-2 gap-6">`);
          if (__props.form.beneficios.vale_transporte) {
            _push(`<div class="p-4 border border-gray-200 rounded-xl"><div class="flex items-center justify-between mb-3"><div class="flex items-center gap-2"><span class="text-2xl"></span><h5 class="font-semibold text-gray-800">Vale Transporte</h5></div>`);
            _push(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: __props.form.beneficios.vale_transporte.ativo,
              "onUpdate:modelValue": ($event) => __props.form.beneficios.vale_transporte.ativo = $event,
              label: ""
            }, null, _parent));
            _push(`</div>`);
            if (__props.form.beneficios.vale_transporte.ativo) {
              _push(`<div class="space-y-3">`);
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: __props.form.beneficios.vale_transporte.valor,
                "onUpdate:modelValue": ($event) => __props.form.beneficios.vale_transporte.valor = $event,
                type: "number",
                step: "0.01",
                label: "Valor Dirio (R$)",
                placeholder: "0,00"
              }, null, _parent));
              if (__props.form.tipo_contrato !== "PJ") {
                _push(`<div>`);
                _push(ssrRenderComponent_1(_component_UiSelect, {
                  modelValue: __props.form.beneficios.vale_transporte.tipo_desconto,
                  "onUpdate:modelValue": ($event) => __props.form.beneficios.vale_transporte.tipo_desconto = $event,
                  options: tipoDescontoOptions,
                  label: "Tipo de Desconto"
                }, null, _parent));
                if (__props.form.beneficios.vale_transporte.tipo_desconto === "percentual") {
                  _push(ssrRenderComponent_1(_component_UiInput, {
                    modelValue: __props.form.beneficios.vale_transporte.percentual_desconto,
                    "onUpdate:modelValue": ($event) => __props.form.beneficios.vale_transporte.percentual_desconto = $event,
                    type: "number",
                    step: "0.01",
                    label: "% de Desconto",
                    placeholder: "6.00"
                  }, null, _parent));
                } else {
                  _push(`<!---->`);
                }
                if (__props.form.beneficios.vale_transporte.tipo_desconto === "valor_fixo") {
                  _push(ssrRenderComponent_1(_component_UiInput, {
                    modelValue: __props.form.beneficios.vale_transporte.valor_desconto,
                    "onUpdate:modelValue": ($event) => __props.form.beneficios.vale_transporte.valor_desconto = $event,
                    type: "number",
                    step: "0.01",
                    label: "Valor do Desconto (R$)",
                    placeholder: "0,00"
                  }, null, _parent));
                } else {
                  _push(`<!---->`);
                }
                _push(`</div>`);
              } else {
                _push(`<div class="p-3 bg-blue-50 border border-blue-200 rounded-lg"><p class="text-sm text-blue-700">  <strong>Funcionrio PJ:</strong> Benefcio sem desconto em folha </p></div>`);
              }
              _push(`</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          } else {
            _push(`<!---->`);
          }
          if (__props.form.beneficios.cesta_basica) {
            _push(`<div class="p-4 border border-gray-200 rounded-xl"><div class="flex items-center justify-between mb-3"><div class="flex items-center gap-2"><span class="text-2xl"></span><h5 class="font-semibold text-gray-800">Cesta Bsica</h5></div>`);
            _push(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: __props.form.beneficios.cesta_basica.ativo,
              "onUpdate:modelValue": ($event) => __props.form.beneficios.cesta_basica.ativo = $event,
              label: ""
            }, null, _parent));
            _push(`</div>`);
            if (__props.form.beneficios.cesta_basica.ativo) {
              _push(`<div class="space-y-3">`);
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: __props.form.beneficios.cesta_basica.valor,
                "onUpdate:modelValue": ($event) => __props.form.beneficios.cesta_basica.valor = $event,
                type: "number",
                step: "0.01",
                label: "Valor Dirio (R$)",
                placeholder: "0,00"
              }, null, _parent));
              if (__props.form.tipo_contrato !== "PJ") {
                _push(`<div>`);
                _push(ssrRenderComponent_1(_component_UiSelect, {
                  modelValue: __props.form.beneficios.cesta_basica.tipo_desconto,
                  "onUpdate:modelValue": ($event) => __props.form.beneficios.cesta_basica.tipo_desconto = $event,
                  options: tipoDescontoOptions,
                  label: "Tipo de Desconto"
                }, null, _parent));
                if (__props.form.beneficios.cesta_basica.tipo_desconto === "percentual") {
                  _push(ssrRenderComponent_1(_component_UiInput, {
                    modelValue: __props.form.beneficios.cesta_basica.percentual_desconto,
                    "onUpdate:modelValue": ($event) => __props.form.beneficios.cesta_basica.percentual_desconto = $event,
                    type: "number",
                    step: "0.01",
                    label: "% de Desconto",
                    placeholder: "20.00"
                  }, null, _parent));
                } else {
                  _push(`<!---->`);
                }
                if (__props.form.beneficios.cesta_basica.tipo_desconto === "valor_fixo") {
                  _push(ssrRenderComponent_1(_component_UiInput, {
                    modelValue: __props.form.beneficios.cesta_basica.valor_desconto,
                    "onUpdate:modelValue": ($event) => __props.form.beneficios.cesta_basica.valor_desconto = $event,
                    type: "number",
                    step: "0.01",
                    label: "Valor do Desconto (R$)",
                    placeholder: "0,00"
                  }, null, _parent));
                } else {
                  _push(`<!---->`);
                }
                _push(`</div>`);
              } else {
                _push(`<div class="p-3 bg-blue-50 border border-blue-200 rounded-lg"><p class="text-sm text-blue-700">  <strong>Funcionrio PJ:</strong> Benefcio sem desconto em folha </p></div>`);
              }
              _push(`</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          } else {
            _push(`<!---->`);
          }
          if (__props.form.beneficios.plano_saude) {
            _push(`<div class="p-4 border border-gray-200 rounded-xl"><div class="flex items-center justify-between mb-3"><div class="flex items-center gap-2"><span class="text-2xl"></span><h5 class="font-semibold text-gray-800">Plano de Sade</h5></div>`);
            _push(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: __props.form.beneficios.plano_saude.ativo,
              "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_saude.ativo = $event,
              label: ""
            }, null, _parent));
            _push(`</div>`);
            if (__props.form.beneficios.plano_saude.ativo) {
              _push(`<div class="space-y-3">`);
              _push(ssrRenderComponent_1(_component_UiSelect, {
                modelValue: __props.form.beneficios.plano_saude.plano,
                "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_saude.plano = $event,
                options: planoSaudeOptions,
                label: "Tipo de Plano"
              }, null, _parent));
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: __props.form.beneficios.plano_saude.valor_empresa,
                "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_saude.valor_empresa = $event,
                type: "number",
                step: "0.01",
                label: "Valor Pago pela Empresa (R$)",
                placeholder: "0,00"
              }, null, _parent));
              if (__props.form.tipo_contrato !== "PJ") {
                _push(`<div>`);
                _push(ssrRenderComponent_1(_component_UiInput, {
                  modelValue: __props.form.beneficios.plano_saude.valor_funcionario,
                  "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_saude.valor_funcionario = $event,
                  type: "number",
                  step: "0.01",
                  label: "Valor Descontado do Funcionrio (R$)",
                  placeholder: "0,00"
                }, null, _parent));
                _push(`</div>`);
              } else {
                _push(`<div class="p-3 bg-blue-50 border border-blue-200 rounded-lg"><p class="text-sm text-blue-700">  <strong>Funcionrio PJ:</strong> Sem desconto em folha para plano de sade </p></div>`);
              }
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: __props.form.beneficios.plano_saude.dependentes,
                "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_saude.dependentes = $event,
                type: "number",
                label: "Nmero de Dependentes",
                placeholder: "0"
              }, null, _parent));
              _push(`</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          } else {
            _push(`<!---->`);
          }
          if (__props.form.beneficios.plano_odonto) {
            _push(`<div class="p-4 border border-gray-200 rounded-xl"><div class="flex items-center justify-between mb-3"><div class="flex items-center gap-2"><span class="text-2xl"></span><h5 class="font-semibold text-gray-800">Plano Odontolgico</h5></div>`);
            _push(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: __props.form.beneficios.plano_odonto.ativo,
              "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_odonto.ativo = $event,
              label: ""
            }, null, _parent));
            _push(`</div>`);
            if (__props.form.beneficios.plano_odonto.ativo) {
              _push(`<div class="space-y-3">`);
              if (__props.form.tipo_contrato !== "PJ") {
                _push(`<div>`);
                _push(ssrRenderComponent_1(_component_UiInput, {
                  modelValue: __props.form.beneficios.plano_odonto.valor_funcionario,
                  "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_odonto.valor_funcionario = $event,
                  type: "number",
                  step: "0.01",
                  label: "Valor Descontado (R$)",
                  placeholder: "0,00"
                }, null, _parent));
                _push(`</div>`);
              } else {
                _push(`<div class="p-3 bg-blue-50 border border-blue-200 rounded-lg"><p class="text-sm text-blue-700">  <strong>Funcionrio PJ:</strong> Sem desconto em folha para plano odontolgico </p></div>`);
              }
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: __props.form.beneficios.plano_odonto.dependentes,
                "onUpdate:modelValue": ($event) => __props.form.beneficios.plano_odonto.dependentes = $event,
                type: "number",
                label: "Nmero de Dependentes",
                placeholder: "0"
              }, null, _parent));
              _push(`</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div>`);
        } else {
          _push(`<div class="p-4 bg-red-50 border border-red-200 rounded-xl"><div class="flex items-center gap-2 text-red-700"><span class="text-xl"></span><div><h4 class="font-semibold">Benefcios no inicializados</h4><p class="text-sm">Clique no boto abaixo para inicializar os benefcios.</p><button class="mt-2 px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700">  Inicializar Benefcios </button></div></div></div>`);
        }
        if (__props.form.beneficios) {
          _push(`<div class="space-y-4"><div class="flex items-center justify-between"><h4 class="text-md font-semibold text-gray-700 mb-3"> Benefcios Personalizados</h4>`);
          _push(ssrRenderComponent_1(_component_UiButton, {
            variant: "secondary",
            size: "sm",
            onClick: adicionarBeneficioPersonalizado
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Adicionar Benefcio `);
              } else {
                return [
                  vueExports.createTextVNode("  Adicionar Benefcio ")
                ];
              }
            }),
            _: 1
          }, _parent));
          _push(`</div><div class="space-y-4"><!--[-->`);
          ssrRenderList_1(__props.form.beneficios.personalizados, (beneficio, index) => {
            _push(`<div class="p-4 border border-gray-200 rounded-xl"><div class="flex items-center justify-between mb-3"><div class="flex items-center gap-2">`);
            _push(ssrRenderComponent_1(_component_UiInput, {
              modelValue: beneficio.icone,
              "onUpdate:modelValue": ($event) => beneficio.icone = $event,
              label: "",
              placeholder: "",
              class: "w-12 text-center text-xl"
            }, null, _parent));
            _push(ssrRenderComponent_1(_component_UiInput, {
              modelValue: beneficio.nome,
              "onUpdate:modelValue": ($event) => beneficio.nome = $event,
              label: "",
              placeholder: "Nome do benefcio",
              class: "font-semibold"
            }, null, _parent));
            _push(`</div><div class="flex items-center gap-2">`);
            _push(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: beneficio.ativo,
              "onUpdate:modelValue": ($event) => beneficio.ativo = $event,
              label: ""
            }, null, _parent));
            _push(ssrRenderComponent_1(_component_UiButton, {
              variant: "danger",
              size: "sm",
              onClick: ($event) => removerBeneficioPersonalizado(Number(index))
            }, {
              default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`  `);
                } else {
                  return [
                    vueExports.createTextVNode("  ")
                  ];
                }
              }),
              _: 2
            }, _parent));
            _push(`</div></div>`);
            if (beneficio.ativo) {
              _push(`<div class="space-y-3"><div class="grid grid-cols-1 md:grid-cols-2 gap-3">`);
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: beneficio.valor,
                "onUpdate:modelValue": ($event) => beneficio.valor = $event,
                type: "number",
                step: "0.01",
                label: "Valor do Benefcio (R$)",
                placeholder: "0,00"
              }, null, _parent));
              _push(ssrRenderComponent_1(_component_UiSelect, {
                modelValue: beneficio.tipo_valor,
                "onUpdate:modelValue": ($event) => beneficio.tipo_valor = $event,
                options: tipoBeneficioOptions,
                label: "Tipo de Valor"
              }, null, _parent));
              _push(`</div>`);
              if (__props.form.tipo_contrato !== "PJ") {
                _push(`<div class="grid grid-cols-1 md:grid-cols-2 gap-3">`);
                _push(ssrRenderComponent_1(_component_UiSelect, {
                  modelValue: beneficio.tipo_desconto,
                  "onUpdate:modelValue": ($event) => beneficio.tipo_desconto = $event,
                  options: tipoDescontoOptions,
                  label: "Tipo de Desconto"
                }, null, _parent));
                if (beneficio.tipo_desconto === "percentual") {
                  _push(ssrRenderComponent_1(_component_UiInput, {
                    modelValue: beneficio.percentual_desconto,
                    "onUpdate:modelValue": ($event) => beneficio.percentual_desconto = $event,
                    type: "number",
                    step: "0.01",
                    label: "% de Desconto",
                    placeholder: "0,00"
                  }, null, _parent));
                } else {
                  _push(`<!---->`);
                }
                if (beneficio.tipo_desconto === "valor_fixo") {
                  _push(ssrRenderComponent_1(_component_UiInput, {
                    modelValue: beneficio.valor_desconto,
                    "onUpdate:modelValue": ($event) => beneficio.valor_desconto = $event,
                    type: "number",
                    step: "0.01",
                    label: "Valor do Desconto (R$)",
                    placeholder: "0,00"
                  }, null, _parent));
                } else {
                  _push(`<!---->`);
                }
                _push(`</div>`);
              } else {
                _push(`<div class="p-3 bg-blue-50 border border-blue-200 rounded-lg"><p class="text-sm text-blue-700">  <strong>Funcionrio PJ:</strong> Benefcio sem desconto em folha </p></div>`);
              }
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: beneficio.descricao,
                "onUpdate:modelValue": ($event) => beneficio.descricao = $event,
                label: "Descrio (opcional)",
                placeholder: "Ex: Auxlio creche, seguro de vida, etc."
              }, null, _parent));
              _push(`</div>`);
            } else {
              _push(`<!---->`);
            }
            _push(`</div>`);
          });
          _push(`<!--]-->`);
          if (!__props.form.beneficios.personalizados || __props.form.beneficios.personalizados.length === 0) {
            _push(`<div class="p-4 text-center text-gray-500 border-2 border-dashed border-gray-200 rounded-xl"><span class="text-2xl"></span><p class="mt-2">Nenhum benefcio personalizado adicionado</p><p class="text-sm">Clique em &quot;Adicionar Benefcio&quot; para criar um novo</p></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div>`);
        } else {
          _push(`<!---->`);
        }
        if (__props.form.descontos_personalizados && __props.form.tipo_contrato !== "PJ") {
          _push(`<div class="space-y-4"><div class="flex items-center justify-between"><h4 class="text-md font-semibold text-gray-700"> Descontos Personalizados</h4>`);
          _push(ssrRenderComponent_1(_component_UiButton, {
            variant: "secondary",
            size: "sm",
            onClick: adicionarDesconto
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`  Adicionar Desconto `);
              } else {
                return [
                  vueExports.createTextVNode("  Adicionar Desconto ")
                ];
              }
            }),
            _: 1
          }, _parent));
          _push(`</div><div class="space-y-3"><!--[-->`);
          ssrRenderList_1(__props.form.descontos_personalizados, (desconto, index) => {
            _push(`<div class="p-4 border border-gray-200 rounded-xl"><div class="grid grid-cols-1 md:grid-cols-4 gap-4">`);
            _push(ssrRenderComponent_1(_component_UiInput, {
              modelValue: desconto.descricao,
              "onUpdate:modelValue": ($event) => desconto.descricao = $event,
              label: "Descrio",
              placeholder: "Ex: Emprstimo, Seguro de Vida"
            }, null, _parent));
            _push(ssrRenderComponent_1(_component_UiSelect, {
              modelValue: desconto.tipo,
              "onUpdate:modelValue": ($event) => desconto.tipo = $event,
              options: tipoDescontoOptions,
              label: "Tipo"
            }, null, _parent));
            if (desconto.tipo === "percentual") {
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: desconto.percentual,
                "onUpdate:modelValue": ($event) => desconto.percentual = $event,
                type: "number",
                step: "0.01",
                label: "Percentual (%)",
                placeholder: "0,00"
              }, null, _parent));
            } else {
              _push(`<!---->`);
            }
            if (desconto.tipo === "valor_fixo") {
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: desconto.valor,
                "onUpdate:modelValue": ($event) => desconto.valor = $event,
                type: "number",
                step: "0.01",
                label: "Valor (R$)",
                placeholder: "0,00"
              }, null, _parent));
            } else {
              _push(`<!---->`);
            }
            _push(`<div class="flex items-end">`);
            _push(ssrRenderComponent_1(_component_UiButton, {
              variant: "danger",
              size: "sm",
              onClick: ($event) => removerDesconto(Number(index))
            }, {
              default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
                if (_push2) {
                  _push2(`  Remover `);
                } else {
                  return [
                    vueExports.createTextVNode("  Remover ")
                  ];
                }
              }),
              _: 2
            }, _parent));
            _push(`</div></div><div class="mt-3 flex gap-4">`);
            _push(ssrRenderComponent_1(_component_UiCheckbox, {
              modelValue: desconto.recorrente,
              "onUpdate:modelValue": ($event) => desconto.recorrente = $event,
              label: "Desconto recorrente"
            }, null, _parent));
            if (!desconto.recorrente) {
              _push(ssrRenderComponent_1(_component_UiInput, {
                modelValue: desconto.parcelas,
                "onUpdate:modelValue": ($event) => desconto.parcelas = $event,
                type: "number",
                label: "Nmero de parcelas",
                placeholder: "1",
                class: "w-32"
              }, null, _parent));
            } else {
              _push(`<!---->`);
            }
            _push(`</div></div>`);
          });
          _push(`<!--]-->`);
          if (__props.form.descontos_personalizados.length === 0) {
            _push(`<div class="p-4 text-center text-gray-500 border-2 border-dashed border-gray-200 rounded-xl"><span class="text-2xl"></span><p class="mt-2">Nenhum desconto personalizado adicionado</p><p class="text-sm">Clique em &quot;Adicionar Desconto&quot; para criar um novo</p></div>`);
          } else {
            _push(`<!---->`);
          }
          _push(`</div></div>`);
        } else if (__props.form.tipo_contrato === "PJ") {
          _push(`<div class="p-4 bg-gray-50 border border-gray-200 rounded-xl"><div class="flex items-center gap-2 text-gray-600"><span class="text-xl"></span><div><h4 class="font-semibold">Funcionrio PJ - Descontos No Aplicveis</h4><p class="text-sm">Funcionrios PJ no podem ter descontos personalizados em folha de pagamento.</p></div></div></div>`);
        } else {
          _push(`<div class="p-4 bg-orange-50 border border-orange-200 rounded-xl"><div class="flex items-center gap-2 text-orange-700"><span class="text-xl"></span><div><h4 class="font-semibold">Descontos personalizados no inicializados</h4><p class="text-sm">Clique no boto abaixo para inicializar os descontos.</p><button class="mt-2 px-3 py-1 bg-orange-600 text-white rounded text-sm hover:bg-orange-700">  Inicializar Descontos </button></div></div></div>`);
        }
        _push(`<div class="p-6 bg-gradient-to-r from-green-50 to-blue-50 rounded-xl border border-green-200"><h4 class="text-lg font-bold text-gray-800 mb-4"> Resumo dos Benefcios</h4>`);
        if (__props.form.tipo_contrato === "PJ") {
          _push(`<div class="text-center"><div class="text-xl font-bold text-blue-600 mb-2"> R$ ${ssrInterpolate_1(calcularTotalBeneficios().toFixed(2).replace(".", ","))}</div><div class="text-sm text-gray-600 mb-4">Total de Benefcios (Sem Descontos)</div><div class="p-3 bg-blue-100 rounded-lg"><p class="text-sm text-blue-700">  <strong>Funcionrio PJ:</strong> Recebe benefcios integralmente, sem descontos em folha </p></div></div>`);
        } else {
          _push(`<div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center"><div><div class="text-xl font-bold text-green-600"> R$ ${ssrInterpolate_1(calcularTotalBeneficios().toFixed(2).replace(".", ","))}</div><div class="text-sm text-gray-600">Total de Benefcios</div></div><div><div class="text-xl font-bold text-red-600"> R$ ${ssrInterpolate_1(calcularTotalDescontos().toFixed(2).replace(".", ","))}</div><div class="text-sm text-gray-600">Total de Descontos</div></div><div><div class="text-xl font-bold text-blue-600"> R$ ${ssrInterpolate_1(calcularSaldoLiquido().toFixed(2).replace(".", ","))}</div><div class="text-sm text-gray-600">Impacto no Salrio</div></div></div>`);
        }
        _push(`</div></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div><div class="flex justify-end gap-3 pt-6 border-t">`);
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "secondary",
        onClick: ($event) => _ctx.$emit("cancel")
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(` Cancelar `);
          } else {
            return [
              vueExports.createTextVNode(" Cancelar ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiButton, {
        variant: "success",
        onClick: salvarEEnviarAcesso,
        disabled: __props.loading
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  Salvar e Enviar Acesso `);
          } else {
            return [
              vueExports.createTextVNode("  Salvar e Enviar Acesso ")
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiButton, {
        onClick: handleSubmit,
        disabled: __props.loading
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`  ${ssrInterpolate_1(__props.isEditing ? "Atualizar" : "Salvar")} Funcionrio `);
          } else {
            return [
              vueExports.createTextVNode("  " + vueExports.toDisplayString(__props.isEditing ? "Atualizar" : "Salvar") + " Funcionrio ", 1)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div>`);
    };
  }
});
const _sfc_setup$2$1 = _sfc_main$2$1.setup;
_sfc_main$2$1.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/funcionarios/FuncionarioForm.vue");
  return _sfc_setup$2$1 ? _sfc_setup$2$1(props, ctx) : void 0;
};
const FuncionarioForm = Object.assign(_sfc_main$2$1, { __name: "FuncionariosFuncionarioForm" });
const _sfc_main$1$2 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "FuncionarioCard",
  __ssrInlineRender: true,
  props: {
    funcionario: {}
  },
  emits: ["edit", "toggle-status", "email-enviado", "email-erro"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const enviandoEmail = vueExports.ref(false);
    const verHolerites = () => {
      navigateTo("/admin/holerites");
    };
    const enviarCredenciais = async () => {
      if (enviandoEmail.value) return;
      enviandoEmail.value = true;
      try {
        await $fetch("/api/funcionarios/enviar-acesso", {
          method: "POST",
          body: {
            funcionario_id: props.funcionario.id
          }
        });
        emit("email-enviado", `Credenciais enviadas com sucesso para ${props.funcionario.email_login}!`);
      } catch (error) {
        emit("email-erro", error.data?.message || "Erro ao enviar credenciais. Verifique se o funcionrio possui email cadastrado.");
      } finally {
        enviandoEmail.value = false;
      }
    };
    const formatarData = (data) => {
      if (!data) return "";
      try {
        return new Date(data).toLocaleDateString("pt-BR");
      } catch (error) {
        return "Data invlida";
      }
    };
    const formatarMoeda = (valor) => {
      if (!valor) return "R$ 0,00";
      try {
        return new Intl.NumberFormat("pt-BR", {
          style: "currency",
          currency: "BRL"
        }).format(valor);
      } catch (error) {
        return "R$ 0,00";
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiCard = __nuxt_component_2$1;
      const _component_UiAvatar = __nuxt_component_1$3;
      const _component_UiBadge = __nuxt_component_2$2;
      const _component_UiButton = __nuxt_component_1$4;
      if (__props.funcionario && __props.funcionario.id) {
        _push(ssrRenderComponent_1(_component_UiCard, vueExports.mergeProps({ padding: "p-6" }, _attrs), {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`<div class="flex flex-col lg:flex-row lg:items-center justify-between gap-4"${_scopeId}><div class="flex items-center gap-4"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiAvatar, {
                name: __props.funcionario.nome_completo,
                "avatar-type": __props.funcionario.avatar,
                size: "lg"
              }, null, _parent2, _scopeId));
              _push2(`<div${_scopeId}><h3 class="text-xl font-bold text-gray-800"${_scopeId}>${ssrInterpolate_1(__props.funcionario.nome_completo)}</h3><p class="text-lg text-gray-600"${_scopeId}>${ssrInterpolate_1(__props.funcionario.cargo)} - ${ssrInterpolate_1(__props.funcionario.departamento)}</p><p class="text-gray-500"${_scopeId}>${ssrInterpolate_1(__props.funcionario.email_login)}</p><p class="text-sm text-gray-400"${_scopeId}>CPF: ${ssrInterpolate_1(__props.funcionario.cpf)}</p><p class="text-sm text-gray-400"${_scopeId}>Admisso: ${ssrInterpolate_1(formatarData(__props.funcionario.data_admissao))}</p><div class="mt-1 p-2 bg-blue-50 rounded-lg border border-blue-200"${_scopeId}><p class="text-sm text-blue-700"${_scopeId}>  <strong${_scopeId}>Cadastrado por:</strong> ${ssrInterpolate_1(__props.funcionario.responsavel_cadastro_nome)} `);
              if (__props.funcionario.responsavel_cadastro_email) {
                _push2(`<span class="text-blue-600"${_scopeId}> (${ssrInterpolate_1(__props.funcionario.responsavel_cadastro_email)}) </span>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`</p></div><div class="mt-2 p-2 bg-green-50 rounded-lg border border-green-200"${_scopeId}><p class="text-lg font-bold text-green-700"${_scopeId}>  Salrio: ${ssrInterpolate_1(formatarMoeda(__props.funcionario.salario_base))}</p></div><div class="flex gap-2 mt-2"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiBadge, {
                variant: __props.funcionario.status === "ativo" ? "success" : "gray"
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(__props.funcionario.status === "ativo" ? "Ativo" : "Inativo")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.status === "ativo" ? "Ativo" : "Inativo"), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiBadge, {
                variant: __props.funcionario.tipo_acesso === "admin" ? "warning" : "info"
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(__props.funcionario.tipo_acesso === "admin" ? "Administrador" : "Funcionrio")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.tipo_acesso === "admin" ? "Administrador" : "Funcionrio"), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiBadge, { variant: "gray" }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(__props.funcionario.telefone)}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.telefone), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(`</div></div></div><div class="flex gap-2"${_scopeId}>`);
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: ($event) => _ctx.$emit("edit", __props.funcionario)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Editar `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Editar ")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: verHolerites
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`  Holerites `);
                  } else {
                    return [
                      vueExports.createTextVNode("  Holerites ")
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: "ghost",
                onClick: enviarCredenciais,
                disabled: vueExports.unref(enviandoEmail)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(vueExports.unref(enviandoEmail) ? " Enviando..." : " Login")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(enviandoEmail) ? " Enviando..." : " Login"), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(ssrRenderComponent_1(_component_UiButton, {
                variant: __props.funcionario.status === "ativo" ? "danger" : "success",
                onClick: ($event) => _ctx.$emit("toggle-status", __props.funcionario)
              }, {
                default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`${ssrInterpolate_1(__props.funcionario.status === "ativo" ? " Inativar" : " Ativar")}`);
                  } else {
                    return [
                      vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.status === "ativo" ? " Inativar" : " Ativar"), 1)
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
              _push2(`</div></div>`);
            } else {
              return [
                vueExports.createVNode("div", { class: "flex flex-col lg:flex-row lg:items-center justify-between gap-4" }, [
                  vueExports.createVNode("div", { class: "flex items-center gap-4" }, [
                    vueExports.createVNode(_component_UiAvatar, {
                      name: __props.funcionario.nome_completo,
                      "avatar-type": __props.funcionario.avatar,
                      size: "lg"
                    }, null, 8, ["name", "avatar-type"]),
                    vueExports.createVNode("div", null, [
                      vueExports.createVNode("h3", { class: "text-xl font-bold text-gray-800" }, vueExports.toDisplayString(__props.funcionario.nome_completo), 1),
                      vueExports.createVNode("p", { class: "text-lg text-gray-600" }, vueExports.toDisplayString(__props.funcionario.cargo) + " - " + vueExports.toDisplayString(__props.funcionario.departamento), 1),
                      vueExports.createVNode("p", { class: "text-gray-500" }, vueExports.toDisplayString(__props.funcionario.email_login), 1),
                      vueExports.createVNode("p", { class: "text-sm text-gray-400" }, "CPF: " + vueExports.toDisplayString(__props.funcionario.cpf), 1),
                      vueExports.createVNode("p", { class: "text-sm text-gray-400" }, "Admisso: " + vueExports.toDisplayString(formatarData(__props.funcionario.data_admissao)), 1),
                      vueExports.createVNode("div", { class: "mt-1 p-2 bg-blue-50 rounded-lg border border-blue-200" }, [
                        vueExports.createVNode("p", { class: "text-sm text-blue-700" }, [
                          vueExports.createTextVNode("  "),
                          vueExports.createVNode("strong", null, "Cadastrado por:"),
                          vueExports.createTextVNode(" " + vueExports.toDisplayString(__props.funcionario.responsavel_cadastro_nome) + " ", 1),
                          __props.funcionario.responsavel_cadastro_email ? (vueExports.openBlock(), vueExports.createBlock("span", {
                            key: 0,
                            class: "text-blue-600"
                          }, " (" + vueExports.toDisplayString(__props.funcionario.responsavel_cadastro_email) + ") ", 1)) : vueExports.createCommentVNode("", true)
                        ])
                      ]),
                      vueExports.createVNode("div", { class: "mt-2 p-2 bg-green-50 rounded-lg border border-green-200" }, [
                        vueExports.createVNode("p", { class: "text-lg font-bold text-green-700" }, "  Salrio: " + vueExports.toDisplayString(formatarMoeda(__props.funcionario.salario_base)), 1)
                      ]),
                      vueExports.createVNode("div", { class: "flex gap-2 mt-2" }, [
                        vueExports.createVNode(_component_UiBadge, {
                          variant: __props.funcionario.status === "ativo" ? "success" : "gray"
                        }, {
                          default: vueExports.withCtx(() => [
                            vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.status === "ativo" ? "Ativo" : "Inativo"), 1)
                          ]),
                          _: 1
                        }, 8, ["variant"]),
                        vueExports.createVNode(_component_UiBadge, {
                          variant: __props.funcionario.tipo_acesso === "admin" ? "warning" : "info"
                        }, {
                          default: vueExports.withCtx(() => [
                            vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.tipo_acesso === "admin" ? "Administrador" : "Funcionrio"), 1)
                          ]),
                          _: 1
                        }, 8, ["variant"]),
                        vueExports.createVNode(_component_UiBadge, { variant: "gray" }, {
                          default: vueExports.withCtx(() => [
                            vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.telefone), 1)
                          ]),
                          _: 1
                        })
                      ])
                    ])
                  ]),
                  vueExports.createVNode("div", { class: "flex gap-2" }, [
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: ($event) => _ctx.$emit("edit", __props.funcionario)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Editar ")
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: verHolerites
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode("  Holerites ")
                      ]),
                      _: 1
                    }),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      onClick: enviarCredenciais,
                      disabled: vueExports.unref(enviandoEmail)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(enviandoEmail) ? " Enviando..." : " Login"), 1)
                      ]),
                      _: 1
                    }, 8, ["disabled"]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: __props.funcionario.status === "ativo" ? "danger" : "success",
                      onClick: ($event) => _ctx.$emit("toggle-status", __props.funcionario)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode(vueExports.toDisplayString(__props.funcionario.status === "ativo" ? " Inativar" : " Ativar"), 1)
                      ]),
                      _: 1
                    }, 8, ["variant", "onClick"])
                  ])
                ])
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$1$2 = _sfc_main$1$2.setup;
_sfc_main$1$2.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/funcionarios/FuncionarioCard.vue");
  return _sfc_setup$1$2 ? _sfc_setup$1$2(props, ctx) : void 0;
};
const FuncionarioCard = Object.assign(_sfc_main$1$2, { __name: "FuncionariosFuncionarioCard" });
const _sfc_main$7 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "funcionarios",
  __ssrInlineRender: true,
  setup(__props) {
    const busca = vueExports.ref("");
    const modalAberto = vueExports.ref(false);
    const funcionarioEditando = vueExports.ref(null);
    const loading = vueExports.ref(false);
    const mostrarNotificacao = vueExports.ref(false);
    const notificacao = vueExports.ref({
      title: "",
      message: "",
      variant: "success"
    });
    const form = vueExports.ref({
      // Dados Pessoais
      nome_completo: "",
      cpf: "",
      rg: "",
      pis_pasep: "",
      data_nascimento: "",
      sexo: "",
      estado_civil: "",
      telefone: "",
      email_pessoal: "",
      contato_emergencia_nome: "",
      contato_emergencia_telefone: "",
      // Endereo
      cep: "",
      logradouro: "",
      numero: "",
      complemento: "",
      bairro: "",
      cidade: "",
      estado: "",
      // Dados Profissionais
      empresa_id: "",
      departamento_id: "",
      cargo_id: "",
      responsavel_id: 1,
      tipo_contrato: "CLT",
      data_admissao: "",
      matricula: "",
      jornada_trabalho_id: "",
      // Acesso ao Sistema
      email_login: "",
      senha: "",
      tipo_acesso: "funcionario",
      status: "ativo",
      // Dados Financeiros
      salario_base: "",
      tipo_salario: "mensal",
      numero_dependentes: 0,
      banco: "",
      agencia: "",
      conta: "",
      tipo_conta: "",
      forma_pagamento: "deposito",
      // Benefcios
      beneficios: {
        vale_transporte: {
          ativo: false,
          valor: 0,
          valor_mensal: 0,
          tipo_desconto: "percentual",
          percentual_desconto: 6,
          valor_desconto: 0
        },
        cesta_basica: {
          ativo: false,
          valor: 0,
          valor_mensal: 0,
          tipo_desconto: "sem_desconto",
          percentual_desconto: 0,
          valor_desconto: 0
        },
        plano_saude: {
          ativo: false,
          plano: "individual",
          valor_empresa: 0,
          valor_funcionario: 0,
          dependentes: 0
        },
        plano_odonto: {
          ativo: false,
          valor_funcionario: 0,
          dependentes: 0
        },
        personalizados: []
      },
      // Descontos Personalizados
      descontos_personalizados: [],
      // Observaes
      observacoes_internas: ""
    });
    const funcionarios = vueExports.ref([]);
    const carregarFuncionarios = async () => {
      try {
        const data = await $fetch("/api/funcionarios");
        if (data) {
          funcionarios.value = data.map((f) => ({
            ...f,
            // Extrair nomes dos objetos relacionados
            cargo: f.cargos?.nome || "Cargo no definido",
            departamento: f.departamentos?.nome || "Departamento no definido",
            empresa: f.empresas?.nome_fantasia || f.empresas?.nome || "Empresa no definida"
          }));
        }
      } catch (error) {
        console.error("Erro ao carregar funcionrios:", error);
      }
    };
    const funcionariosFiltrados = vueExports.computed(() => {
      if (!busca.value) {
        return funcionarios.value;
      }
      const termo = busca.value.toLowerCase();
      return funcionarios.value.filter((f) => {
        return f.nome_completo?.toLowerCase().includes(termo) || f.cargo?.toLowerCase().includes(termo) || f.departamento?.toLowerCase().includes(termo) || f.email_login?.toLowerCase().includes(termo);
      });
    });
    const abrirModal = async (func) => {
      if (func) {
        try {
          const funcionarioCompleto = await $fetch(`/api/funcionarios/${func.id}`);
          funcionarioEditando.value = funcionarioCompleto;
          const beneficiosPadrao = {
            vale_transporte: {
              ativo: false,
              valor: 0,
              valor_mensal: 0,
              tipo_desconto: "percentual",
              percentual_desconto: 6,
              valor_desconto: 0
            },
            cesta_basica: {
              ativo: false,
              valor: 0,
              valor_mensal: 0,
              tipo_desconto: "sem_desconto",
              percentual_desconto: 0,
              valor_desconto: 0
            },
            plano_saude: {
              ativo: false,
              plano: "individual",
              valor_empresa: 0,
              valor_funcionario: 0,
              dependentes: 0
            },
            plano_odonto: {
              ativo: false,
              valor_funcionario: 0,
              dependentes: 0
            },
            personalizados: []
          };
          const beneficiosMesclados = {
            ...beneficiosPadrao,
            ...funcionarioCompleto.beneficios || {}
          };
          if (!Array.isArray(beneficiosMesclados.personalizados)) {
            beneficiosMesclados.personalizados = [];
          }
          form.value = {
            ...funcionarioCompleto,
            beneficios: beneficiosMesclados,
            descontos_personalizados: Array.isArray(funcionarioCompleto.descontos_personalizados) ? funcionarioCompleto.descontos_personalizados : []
          };
        } catch (error) {
          console.error("Erro ao buscar funcionrio:", error);
          notificacao.value = {
            title: "Erro!",
            message: "Erro ao carregar dados do funcionrio",
            variant: "error"
          };
          mostrarNotificacao.value = true;
          return;
        }
      } else {
        funcionarioEditando.value = null;
        form.value = {
          // Dados Pessoais
          nome_completo: "",
          cpf: "",
          rg: "",
          pis_pasep: "",
          data_nascimento: "",
          sexo: "",
          estado_civil: "",
          telefone: "",
          email_pessoal: "",
          contato_emergencia_nome: "",
          contato_emergencia_telefone: "",
          // Endereo
          cep: "",
          logradouro: "",
          numero: "",
          complemento: "",
          bairro: "",
          cidade: "",
          estado: "",
          // Dados Profissionais
          empresa_id: "",
          departamento_id: "",
          cargo_id: "",
          responsavel_id: 1,
          tipo_contrato: "CLT",
          data_admissao: "",
          matricula: "",
          jornada_trabalho_id: "",
          // Acesso ao Sistema
          email_login: "",
          senha: "",
          tipo_acesso: "funcionario",
          status: "ativo",
          // Dados Financeiros
          salario_base: "",
          tipo_salario: "mensal",
          numero_dependentes: 0,
          banco: "",
          agencia: "",
          conta: "",
          tipo_conta: "",
          forma_pagamento: "deposito",
          // Benefcios
          beneficios: {
            vale_transporte: {
              ativo: false,
              valor: 0,
              valor_mensal: 0,
              tipo_desconto: "percentual",
              percentual_desconto: 6,
              valor_desconto: 0
            },
            cesta_basica: {
              ativo: false,
              valor: 0,
              valor_mensal: 0,
              tipo_desconto: "sem_desconto",
              percentual_desconto: 0,
              valor_desconto: 0
            },
            plano_saude: {
              ativo: false,
              plano: "individual",
              valor_empresa: 0,
              valor_funcionario: 0,
              dependentes: 0
            },
            plano_odonto: {
              ativo: false,
              valor_funcionario: 0,
              dependentes: 0
            },
            personalizados: []
          },
          // Descontos Personalizados
          descontos_personalizados: [],
          // Observaes
          observacoes_internas: ""
        };
      }
      modalAberto.value = true;
    };
    const salvarFuncionario = async () => {
      loading.value = true;
      try {
        if (!form.value.nome_completo || !form.value.cpf) {
          throw new Error("Preencha o nome completo e CPF");
        }
        if (funcionarioEditando.value) {
          await $fetch(`/api/funcionarios/${funcionarioEditando.value.id}`, {
            method: "PATCH",
            body: form.value
          });
        } else {
          await $fetch("/api/funcionarios", {
            method: "POST",
            body: form.value
          });
        }
        notificacao.value = {
          title: "Sucesso!",
          message: `Funcionrio ${funcionarioEditando.value ? "atualizado" : "cadastrado"} com sucesso!`,
          variant: "success"
        };
        mostrarNotificacao.value = true;
        modalAberto.value = false;
        await carregarFuncionarios();
      } catch (error) {
        console.error("Erro ao salvar:", error);
        notificacao.value = {
          title: "Erro!",
          message: error.message || "Erro ao salvar funcionrio. Tente novamente.",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const salvarEEnviarAcesso = async () => {
      loading.value = true;
      try {
        if (!form.value.nome_completo || !form.value.cpf) {
          throw new Error("Preencha o nome completo e CPF");
        }
        const response = await $fetch("/api/funcionarios", {
          method: "POST",
          body: form.value
        });
        const funcionarioCriado = response?.data;
        if (!funcionarioCriado || !funcionarioCriado.id) {
          throw new Error("Funcionrio criado mas dados no retornados");
        }
        console.log(" Funcionrio criado:", funcionarioCriado.id);
        if (form.value.email_login) {
          console.log(" Enviando email para:", form.value.email_login);
          try {
            await $fetch("/api/funcionarios/enviar-acesso", {
              method: "POST",
              body: {
                funcionario_id: funcionarioCriado.id
              }
            });
            notificacao.value = {
              title: "Sucesso!",
              message: `Funcionrio cadastrado e email enviado para ${form.value.email_login}! `,
              variant: "success"
            };
          } catch (erroEmail) {
            console.warn(" Funcionrio criado mas erro ao enviar email:", erroEmail);
            notificacao.value = {
              title: "Ateno!",
              message: `Funcionrio cadastrado, mas no foi possvel enviar o email para ${form.value.email_login}. Envie manualmente.`,
              variant: "warning"
            };
          }
        } else {
          notificacao.value = {
            title: "Sucesso!",
            message: "Funcionrio cadastrado! Configure o email de login para enviar acesso.",
            variant: "success"
          };
        }
        mostrarNotificacao.value = true;
        modalAberto.value = false;
        await carregarFuncionarios();
      } catch (error) {
        console.error("Erro ao salvar:", error);
        notificacao.value = {
          title: "Erro!",
          message: error.message || "Erro ao salvar funcionrio.",
          variant: "error"
        };
        mostrarNotificacao.value = true;
      } finally {
        loading.value = false;
      }
    };
    const toggleStatus = (func) => {
      func.status = func.status === "ativo" ? "inativo" : "ativo";
      notificacao.value = {
        title: "Status Atualizado!",
        message: `Funcionrio ${func.nome_completo} ${func.status === "ativo" ? "ativado" : "inativado"} com sucesso!`,
        variant: "success"
      };
      mostrarNotificacao.value = true;
    };
    const handleEmailEnviado = (mensagem) => {
      notificacao.value = {
        title: "Email Enviado!",
        message: mensagem,
        variant: "success"
      };
      mostrarNotificacao.value = true;
    };
    const handleEmailErro = (mensagem) => {
      notificacao.value = {
        title: "Erro ao Enviar Email",
        message: mensagem,
        variant: "error"
      };
      mostrarNotificacao.value = true;
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiPageHeader = __nuxt_component_0$3;
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiCard = __nuxt_component_2$1;
      const _component_UiModal = __nuxt_component_3;
      const _component_UiNotification = __nuxt_component_7;
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      _push(ssrRenderComponent_1(_component_UiPageHeader, {
        title: "Funcionrios",
        description: "Gerencie todos os colaboradores da empresa"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent_1(_component_UiButton, {
              size: "lg",
              icon: "",
              onClick: ($event) => abrirModal()
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Novo Funcionrio `);
                } else {
                  return [
                    vueExports.createTextVNode(" Novo Funcionrio ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              vueExports.createVNode(_component_UiButton, {
                size: "lg",
                icon: "",
                onClick: ($event) => abrirModal()
              }, {
                default: vueExports.withCtx(() => [
                  vueExports.createTextVNode(" Novo Funcionrio ")
                ]),
                _: 1
              }, 8, ["onClick"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiCard, {
        padding: "p-4",
        class: "mb-6"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="relative"${_scopeId}><svg class="w-6 h-6 text-gray-400 absolute left-4 top-1/2 -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"${_scopeId}></path></svg><input${ssrRenderAttr_1("value", vueExports.unref(busca))} type="text" placeholder="Buscar funcionrio por nome, cargo ou departamento..." class="w-full pl-14 pr-4 py-4 text-lg border-2 border-gray-200 rounded-xl focus:border-primary-500 outline-none"${_scopeId}></div>`);
          } else {
            return [
              vueExports.createVNode("div", { class: "relative" }, [
                (vueExports.openBlock(), vueExports.createBlock("svg", {
                  class: "w-6 h-6 text-gray-400 absolute left-4 top-1/2 -translate-y-1/2",
                  fill: "none",
                  stroke: "currentColor",
                  viewBox: "0 0 24 24"
                }, [
                  vueExports.createVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                  })
                ])),
                vueExports.withDirectives(vueExports.createVNode("input", {
                  "onUpdate:modelValue": ($event) => vueExports.isRef(busca) ? busca.value = $event : null,
                  type: "text",
                  placeholder: "Buscar funcionrio por nome, cargo ou departamento...",
                  class: "w-full pl-14 pr-4 py-4 text-lg border-2 border-gray-200 rounded-xl focus:border-primary-500 outline-none"
                }, null, 8, ["onUpdate:modelValue"]), [
                  [vueExports.vModelText, vueExports.unref(busca)]
                ])
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`<div class="space-y-4"><!--[-->`);
      ssrRenderList_1(vueExports.unref(funcionariosFiltrados), (func, index) => {
        _push(ssrRenderComponent_1(FuncionarioCard, {
          funcionario: func,
          onEdit: abrirModal,
          onToggleStatus: toggleStatus,
          onEmailEnviado: handleEmailEnviado,
          onEmailErro: handleEmailErro
        }, null, _parent));
      });
      _push(`<!--]--></div>`);
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalAberto),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalAberto) ? modalAberto.value = $event : null,
        title: vueExports.unref(funcionarioEditando) ? "Editar Funcionrio" : "Novo Funcionrio",
        "max-width": "max-w-6xl",
        "content-max-height": "calc(90vh - 120px)",
        "close-on-backdrop": false
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent_1(FuncionarioForm, {
              form: vueExports.unref(form),
              "is-editing": !!vueExports.unref(funcionarioEditando),
              "show-empresa-select": true,
              loading: vueExports.unref(loading),
              onSubmit: salvarFuncionario,
              onSalvarEEnviar: salvarEEnviarAcesso,
              onCancel: ($event) => modalAberto.value = false
            }, null, _parent2, _scopeId));
          } else {
            return [
              vueExports.createVNode(FuncionarioForm, {
                form: vueExports.unref(form),
                "is-editing": !!vueExports.unref(funcionarioEditando),
                "show-empresa-select": true,
                loading: vueExports.unref(loading),
                onSubmit: salvarFuncionario,
                onSalvarEEnviar: salvarEEnviarAcesso,
                onCancel: ($event) => modalAberto.value = false
              }, null, 8, ["form", "is-editing", "loading", "onCancel"])
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiNotification, {
        show: vueExports.unref(mostrarNotificacao),
        title: vueExports.unref(notificacao).title,
        message: vueExports.unref(notificacao).message,
        variant: vueExports.unref(notificacao).variant,
        onClose: ($event) => mostrarNotificacao.value = false
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$7 = _sfc_main$7.setup;
_sfc_main$7.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/funcionarios.vue");
  return _sfc_setup$7 ? _sfc_setup$7(props, ctx) : void 0;
};

const funcionariosJNGLzgEn = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$7
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$5 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "departamentos",
  __ssrInlineRender: true,
  setup(__props) {
    const { nomeAdmin } = useAdmin();
    const modalAberto = vueExports.ref(false);
    const editando = vueExports.ref(null);
    const form = vueExports.ref({ nome: "", descricao: "", responsavel: "" });
    const carregando = vueExports.ref(true);
    const salvando = vueExports.ref(false);
    const mostrarNotificacao = vueExports.ref(false);
    const notificacao = vueExports.ref({
      title: "",
      message: "",
      variant: "success"
    });
    const departamentos = vueExports.ref([]);
    const responsaveisOptions = vueExports.computed(() => [
      { value: nomeAdmin.value, label: `${nomeAdmin.value} (Admin) ` }
      // Outros responsveis sero carregados da API
    ]);
    const carregarDepartamentos = async () => {
      carregando.value = true;
      try {
        const response = await $fetch("/api/departamentos");
        if (response.success && response.data) {
          departamentos.value = response.data.map((d) => ({
            ...d,
            funcionarios: 0
            // TODO: Contar funcionrios por departamento
          }));
        }
      } catch (error) {
        console.error("Erro ao carregar departamentos:", error);
        mostrarMensagem("Erro!", "No foi possvel carregar departamentos", "error");
      } finally {
        carregando.value = false;
      }
    };
    const abrirModal = (dept) => {
      editando.value = dept || null;
      form.value = dept ? { nome: dept.nome, descricao: dept.descricao, responsavel: dept.responsavel } : { nome: "", descricao: "", responsavel: nomeAdmin.value };
      modalAberto.value = true;
    };
    const salvar = async () => {
      salvando.value = true;
      try {
        const dados = editando.value ? { ...form.value, id: editando.value.id } : form.value;
        const response = await $fetch("/api/departamentos/criar", {
          method: "POST",
          body: dados
        });
        if (response.success) {
          mostrarMensagem("Sucesso!", response.message, "success");
          modalAberto.value = false;
          await carregarDepartamentos();
        }
      } catch (error) {
        console.error("Erro ao salvar departamento:", error);
        mostrarMensagem("Erro!", error.data?.message || "No foi possvel salvar o departamento", "error");
      } finally {
        salvando.value = false;
      }
    };
    const mostrarMensagem = (title, message, variant) => {
      notificacao.value = { title, message, variant };
      mostrarNotificacao.value = true;
      setTimeout(() => {
        mostrarNotificacao.value = false;
      }, 5e3);
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UiPageHeader = __nuxt_component_0$3;
      const _component_UiButton = __nuxt_component_1$4;
      const _component_UiCard = __nuxt_component_2$1;
      const _component_UiModal = __nuxt_component_3;
      const _component_UiInput = __nuxt_component_4;
      const _component_UiTextarea = __nuxt_component_5$1;
      const _component_UiSelect = __nuxt_component_6$1;
      const _component_UiNotification = __nuxt_component_7;
      _push(`<div${ssrRenderAttrs_1(_attrs)}>`);
      _push(ssrRenderComponent_1(_component_UiPageHeader, {
        title: "Departamentos",
        description: "Organize os setores da empresa"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent_1(_component_UiButton, {
              size: "lg",
              icon: "",
              onClick: ($event) => abrirModal()
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(` Novo Departamento `);
                } else {
                  return [
                    vueExports.createTextVNode(" Novo Departamento ")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              vueExports.createVNode(_component_UiButton, {
                size: "lg",
                icon: "",
                onClick: ($event) => abrirModal()
              }, {
                default: vueExports.withCtx(() => [
                  vueExports.createTextVNode(" Novo Departamento ")
                ]),
                _: 1
              }, 8, ["onClick"])
            ];
          }
        }),
        _: 1
      }, _parent));
      if (vueExports.unref(carregando)) {
        _push(`<div class="flex items-center justify-center py-12"><div class="text-center"><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600 mx-auto mb-4"></div><p class="text-gray-600">Carregando departamentos...</p></div></div>`);
      } else if (vueExports.unref(departamentos).length === 0) {
        _push(`<div class="text-center py-12"><p class="text-gray-500 mb-4">Nenhum departamento cadastrado</p>`);
        _push(ssrRenderComponent_1(_component_UiButton, {
          onClick: ($event) => abrirModal()
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(` Criar Primeiro Departamento`);
            } else {
              return [
                vueExports.createTextVNode(" Criar Primeiro Departamento")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`</div>`);
      } else {
        _push(`<div class="grid grid-cols-1 md:grid-cols-2 gap-4"><!--[-->`);
        ssrRenderList_1(vueExports.unref(departamentos), (dept) => {
          _push(ssrRenderComponent_1(_component_UiCard, {
            key: dept.id,
            padding: "p-6"
          }, {
            default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
              if (_push2) {
                _push2(`<div class="flex items-start justify-between mb-4"${_scopeId}><div class="w-14 h-14 bg-purple-100 rounded-xl flex items-center justify-center"${_scopeId}><svg class="w-7 h-7 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"${_scopeId}></path></svg></div>`);
                _push2(ssrRenderComponent_1(_component_UiButton, {
                  variant: "ghost",
                  size: "sm",
                  onClick: ($event) => abrirModal(dept)
                }, {
                  default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      _push3(` Editar`);
                    } else {
                      return [
                        vueExports.createTextVNode(" Editar")
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
                _push2(`</div><h3 class="text-xl font-bold text-gray-800 mb-1"${_scopeId}>${ssrInterpolate_1(dept.nome)}</h3><p class="text-gray-500 mb-3"${_scopeId}>${ssrInterpolate_1(dept.descricao)}</p><div class="flex items-center gap-2 text-sm text-gray-600"${_scopeId}><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"${_scopeId}></path></svg> Responsvel: ${ssrInterpolate_1(dept.responsavel)}</div><div class="mt-3 pt-3 border-t border-gray-100"${_scopeId}><span class="text-sm text-gray-500"${_scopeId}>${ssrInterpolate_1(dept.funcionarios)} funcionrios</span></div>`);
              } else {
                return [
                  vueExports.createVNode("div", { class: "flex items-start justify-between mb-4" }, [
                    vueExports.createVNode("div", { class: "w-14 h-14 bg-purple-100 rounded-xl flex items-center justify-center" }, [
                      (vueExports.openBlock(), vueExports.createBlock("svg", {
                        class: "w-7 h-7 text-purple-600",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24"
                      }, [
                        vueExports.createVNode("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"
                        })
                      ]))
                    ]),
                    vueExports.createVNode(_component_UiButton, {
                      variant: "ghost",
                      size: "sm",
                      onClick: ($event) => abrirModal(dept)
                    }, {
                      default: vueExports.withCtx(() => [
                        vueExports.createTextVNode(" Editar")
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  vueExports.createVNode("h3", { class: "text-xl font-bold text-gray-800 mb-1" }, vueExports.toDisplayString(dept.nome), 1),
                  vueExports.createVNode("p", { class: "text-gray-500 mb-3" }, vueExports.toDisplayString(dept.descricao), 1),
                  vueExports.createVNode("div", { class: "flex items-center gap-2 text-sm text-gray-600" }, [
                    (vueExports.openBlock(), vueExports.createBlock("svg", {
                      class: "w-5 h-5",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24"
                    }, [
                      vueExports.createVNode("path", {
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-width": "2",
                        d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"
                      })
                    ])),
                    vueExports.createTextVNode(" Responsvel: " + vueExports.toDisplayString(dept.responsavel), 1)
                  ]),
                  vueExports.createVNode("div", { class: "mt-3 pt-3 border-t border-gray-100" }, [
                    vueExports.createVNode("span", { class: "text-sm text-gray-500" }, vueExports.toDisplayString(dept.funcionarios) + " funcionrios", 1)
                  ])
                ];
              }
            }),
            _: 2
          }, _parent));
        });
        _push(`<!--]--></div>`);
      }
      _push(ssrRenderComponent_1(_component_UiModal, {
        modelValue: vueExports.unref(modalAberto),
        "onUpdate:modelValue": ($event) => vueExports.isRef(modalAberto) ? modalAberto.value = $event : null,
        title: vueExports.unref(editando) ? "Editar Departamento" : "Novo Departamento"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<form class="space-y-4"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiInput, {
              modelValue: vueExports.unref(form).nome,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).nome = $event,
              label: "Nome do Departamento",
              required: ""
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiTextarea, {
              modelValue: vueExports.unref(form).descricao,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).descricao = $event,
              label: "Descrio"
            }, null, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiSelect, {
              modelValue: vueExports.unref(form).responsavel,
              "onUpdate:modelValue": ($event) => vueExports.unref(form).responsavel = $event,
              options: vueExports.unref(responsaveisOptions),
              label: "Responsvel",
              placeholder: "Selecione..."
            }, null, _parent2, _scopeId));
            _push2(`<div class="flex justify-end gap-3 pt-4"${_scopeId}>`);
            _push2(ssrRenderComponent_1(_component_UiButton, {
              variant: "secondary",
              onClick: ($event) => modalAberto.value = false
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`Cancelar`);
                } else {
                  return [
                    vueExports.createTextVNode("Cancelar")
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(ssrRenderComponent_1(_component_UiButton, {
              type: "submit",
              icon: "",
              disabled: vueExports.unref(salvando)
            }, {
              default: vueExports.withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`${ssrInterpolate_1(vueExports.unref(salvando) ? "Salvando..." : "Salvar")}`);
                } else {
                  return [
                    vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar"), 1)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            _push2(`</div></form>`);
          } else {
            return [
              vueExports.createVNode("form", {
                onSubmit: vueExports.withModifiers(salvar, ["prevent"]),
                class: "space-y-4"
              }, [
                vueExports.createVNode(_component_UiInput, {
                  modelValue: vueExports.unref(form).nome,
                  "onUpdate:modelValue": ($event) => vueExports.unref(form).nome = $event,
                  label: "Nome do Departamento",
                  required: ""
                }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                vueExports.createVNode(_component_UiTextarea, {
                  modelValue: vueExports.unref(form).descricao,
                  "onUpdate:modelValue": ($event) => vueExports.unref(form).descricao = $event,
                  label: "Descrio"
                }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                vueExports.createVNode(_component_UiSelect, {
                  modelValue: vueExports.unref(form).responsavel,
                  "onUpdate:modelValue": ($event) => vueExports.unref(form).responsavel = $event,
                  options: vueExports.unref(responsaveisOptions),
                  label: "Responsvel",
                  placeholder: "Selecione..."
                }, null, 8, ["modelValue", "onUpdate:modelValue", "options"]),
                vueExports.createVNode("div", { class: "flex justify-end gap-3 pt-4" }, [
                  vueExports.createVNode(_component_UiButton, {
                    variant: "secondary",
                    onClick: ($event) => modalAberto.value = false
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode("Cancelar")
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  vueExports.createVNode(_component_UiButton, {
                    type: "submit",
                    icon: "",
                    disabled: vueExports.unref(salvando)
                  }, {
                    default: vueExports.withCtx(() => [
                      vueExports.createTextVNode(vueExports.toDisplayString(vueExports.unref(salvando) ? "Salvando..." : "Salvar"), 1)
                    ]),
                    _: 1
                  }, 8, ["disabled"])
                ])
              ], 32)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(ssrRenderComponent_1(_component_UiNotification, {
        show: vueExports.unref(mostrarNotificacao),
        title: vueExports.unref(notificacao).title,
        message: vueExports.unref(notificacao).message,
        variant: vueExports.unref(notificacao).variant,
        onClose: ($event) => mostrarNotificacao.value = false
      }, null, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$5 = _sfc_main$5.setup;
_sfc_main$5.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("pages/admin/departamentos.vue");
  return _sfc_setup$5 ? _sfc_setup$5(props, ctx) : void 0;
};

const departamentosCq7NYvfm = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$5
}, Symbol.toStringTag, { value: 'Module' }));

const admin = defineNuxtRouteMiddleware(() => {
  const { isAdmin, isAuthenticated } = useAuth();
  if (!isAuthenticated.value) {
    return navigateTo("/login");
  }
  if (!isAdmin.value) {
    return navigateTo("/dashboard");
  }
});

const adminDhGiD5Ok = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: admin
}, Symbol.toStringTag, { value: 'Module' }));

const auth = defineNuxtRouteMiddleware((to) => {
  const { isAuthenticated } = useAuth();
  if (to.path === "/login") {
    if (isAuthenticated.value) {
      return navigateTo("/dashboard");
    }
    return;
  }
  if (!isAuthenticated.value) {
    return navigateTo("/login");
  }
});

const authCudmmCPj = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: auth
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main$3 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "LayoutNavLink",
  __ssrInlineRender: true,
  props: {
    to: {},
    icon: {}
  },
  emits: ["click"],
  setup(__props) {
    const props = __props;
    const iconPaths = {
      home: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6",
      user: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z",
      document: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z",
      users: "M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z",
      building: "M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4",
      office: "M3 21h18M5 21V7l8-4v18M9 9h1m0 0v1m-1-1h1m0 0V9m0 0h1m0 0v1m-1-1h1M9 15h1m0 0v1m-1-1h1m0 0v-1m0 0h1m0 0v1m-1-1h1",
      briefcase: "M21 13.255A23.931 23.931 0 0112 15c-3.183 0-6.22-.62-9-1.745M16 6V4a2 2 0 00-2-2h-4a2 2 0 00-2 2v2m4 6h.01M5 20h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z",
      gift: "M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z",
      money: "M17 9V7a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2m2 4h10a2 2 0 002-2v-6a2 2 0 00-2-2H9a2 2 0 00-2 2v6a2 2 0 002 2zm7-5a2 2 0 11-4 0 2 2 0 014 0z",
      robot: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z",
      settings: "M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
    };
    const iconPath = vueExports.computed(() => iconPaths[props.icon] || iconPaths.home);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$5;
      _push(ssrRenderComponent_1(_component_NuxtLink, vueExports.mergeProps({
        to: __props.to,
        class: "flex items-center gap-3 px-4 py-3 text-lg font-medium text-gray-600 rounded-xl hover:bg-gray-100 hover:text-gray-900 transition-colors",
        "active-class": "bg-primary-50 text-primary-700 hover:bg-primary-100 hover:text-primary-800",
        onClick: ($event) => _ctx.$emit("click")
      }, _attrs), {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"${_scopeId}><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"${ssrRenderAttr_1("d", vueExports.unref(iconPath))}${_scopeId}></path></svg><span${_scopeId}>`);
            ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push2, _parent2, _scopeId);
            _push2(`</span>`);
          } else {
            return [
              (vueExports.openBlock(), vueExports.createBlock("svg", {
                class: "w-6 h-6",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24"
              }, [
                vueExports.createVNode("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: vueExports.unref(iconPath)
                }, null, 8, ["d"])
              ])),
              vueExports.createVNode("span", null, [
                vueExports.renderSlot(_ctx.$slots, "default")
              ])
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
});
const _sfc_setup$3 = _sfc_main$3.setup;
_sfc_main$3.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/layout/LayoutNavLink.vue");
  return _sfc_setup$3 ? _sfc_setup$3(props, ctx) : void 0;
};
const __nuxt_component_0$1 = Object.assign(_sfc_main$3, { __name: "LayoutNavLink" });
const _sfc_main$2 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "LayoutSidebar",
  __ssrInlineRender: true,
  props: {
    user: {},
    isAdmin: { type: Boolean }
  },
  emits: ["logout"],
  setup(__props) {
    useAuth();
    const cargosMap = vueExports.ref({});
    const obterNomeCargo = (id) => {
      if (!id) return "No informado";
      const idStr = id?.toString();
      return cargosMap.value[idStr] || "Carregando...";
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_LayoutNavLink = __nuxt_component_0$1;
      const _component_UiAvatar = __nuxt_component_1$3;
      _push(`<aside${ssrRenderAttrs_1(vueExports.mergeProps({ class: "hidden lg:flex lg:flex-col lg:w-72 lg:fixed lg:inset-y-0 bg-white border-r border-gray-200 shadow-sm" }, _attrs))}><div class="flex items-center gap-3 px-6 py-5 border-b border-gray-100"><div class="w-12 h-12 bg-primary-600 rounded-xl flex items-center justify-center"><span class="text-white font-bold text-xl">RH</span></div><div><h1 class="text-xl font-bold text-gray-800">Sistema RH</h1><p class="text-sm text-gray-500">Gesto de Pessoas</p></div></div><nav class="flex-1 px-4 py-6 space-y-2 overflow-y-auto">`);
      _push(ssrRenderComponent_1(_component_LayoutNavLink, {
        to: "/dashboard",
        icon: "home"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`Incio`);
          } else {
            return [
              vueExports.createTextVNode("Incio")
            ];
          }
        }),
        _: 1
      }, _parent));
      if (!__props.isAdmin) {
        _push(ssrRenderComponent_1(_component_LayoutNavLink, {
          to: "/holerites",
          icon: "document"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Meus Holerites`);
            } else {
              return [
                vueExports.createTextVNode("Meus Holerites")
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
      _push(ssrRenderComponent_1(_component_LayoutNavLink, {
        to: "/meus-dados",
        icon: "user"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`Meus Dados`);
          } else {
            return [
              vueExports.createTextVNode("Meus Dados")
            ];
          }
        }),
        _: 1
      }, _parent));
      if (__props.isAdmin) {
        _push(`<!--[--><div class="pt-4 mt-4 border-t border-gray-200"><p class="px-4 text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3"> Administrao </p></div>`);
        _push(ssrRenderComponent_1(_component_LayoutNavLink, {
          to: "/admin/funcionarios",
          icon: "users"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Funcionrios`);
            } else {
              return [
                vueExports.createTextVNode("Funcionrios")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_LayoutNavLink, {
          to: "/admin/jornadas",
          icon: "clock"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Jornadas de Trabalho`);
            } else {
              return [
                vueExports.createTextVNode("Jornadas de Trabalho")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_LayoutNavLink, {
          to: "/admin/empresas",
          icon: "office"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Empresas`);
            } else {
              return [
                vueExports.createTextVNode("Empresas")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_LayoutNavLink, {
          to: "/admin/departamentos",
          icon: "building"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Departamentos`);
            } else {
              return [
                vueExports.createTextVNode("Departamentos")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_LayoutNavLink, {
          to: "/admin/cargos",
          icon: "briefcase"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Cargos`);
            } else {
              return [
                vueExports.createTextVNode("Cargos")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(ssrRenderComponent_1(_component_LayoutNavLink, {
          to: "/admin/holerites",
          icon: "money"
        }, {
          default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(`Holerites`);
            } else {
              return [
                vueExports.createTextVNode("Holerites")
              ];
            }
          }),
          _: 1
        }, _parent));
        _push(`<!--]-->`);
      } else {
        _push(`<!---->`);
      }
      _push(`</nav><div class="p-4 border-t border-gray-200"><div class="flex items-center gap-3 p-3 rounded-xl bg-gray-50">`);
      _push(ssrRenderComponent_1(_component_UiAvatar, {
        name: __props.user?.nome || "",
        "avatar-type": __props.user?.avatar
      }, null, _parent));
      _push(`<div class="flex-1 min-w-0"><p class="text-base font-semibold text-gray-800 truncate">${ssrInterpolate_1(__props.user?.nome)}</p><p class="text-sm text-gray-500 truncate">${ssrInterpolate_1(obterNomeCargo(__props.user?.cargo))}</p></div></div><button class="mt-3 w-full flex items-center justify-center gap-2 px-4 py-3 text-base font-medium text-red-600 bg-red-50 rounded-xl hover:bg-red-100 transition-colors"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path></svg> Sair do Sistema </button></div></aside>`);
    };
  }
});
const _sfc_setup$2 = _sfc_main$2.setup;
_sfc_main$2.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/layout/LayoutSidebar.vue");
  return _sfc_setup$2 ? _sfc_setup$2(props, ctx) : void 0;
};
const __nuxt_component_0 = Object.assign(_sfc_main$2, { __name: "LayoutSidebar" });
const _sfc_main$1$1 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "LayoutMobileMenu",
  __ssrInlineRender: true,
  props: {
    open: { type: Boolean },
    user: {},
    isAdmin: { type: Boolean }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    useAuth();
    const cargosMap = vueExports.ref({});
    const obterNomeCargo = (id) => {
      if (!id) return "No informado";
      const idStr = id?.toString();
      return cargosMap.value[idStr] || "Carregando...";
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_LayoutNavLink = __nuxt_component_0$1;
      const _component_UiAvatar = __nuxt_component_1$3;
      ssrRenderTeleport_1(_push, (_push2) => {
        if (__props.open) {
          _push2(`<div class="lg:hidden fixed inset-0 z-50 bg-black/50" data-v-a39f9b9e></div>`);
        } else {
          _push2(`<!---->`);
        }
        if (__props.open) {
          _push2(`<div class="lg:hidden fixed inset-y-0 right-0 z-50 w-80 max-w-full bg-white shadow-xl" data-v-a39f9b9e><div class="flex items-center justify-between p-4 border-b" data-v-a39f9b9e><span class="text-lg font-bold text-gray-800" data-v-a39f9b9e>Menu</span><button class="p-2 rounded-lg hover:bg-gray-100" data-v-a39f9b9e><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-a39f9b9e><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" data-v-a39f9b9e></path></svg></button></div><nav class="p-4 space-y-2 overflow-y-auto max-h-[calc(100vh-200px)]" data-v-a39f9b9e>`);
          _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
            to: "/dashboard",
            icon: "home",
            onClick: ($event) => _ctx.$emit("close")
          }, {
            default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
              if (_push3) {
                _push3(`Incio`);
              } else {
                return [
                  vueExports.createTextVNode("Incio")
                ];
              }
            }),
            _: 1
          }, _parent));
          _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
            to: "/meus-dados",
            icon: "user",
            onClick: ($event) => _ctx.$emit("close")
          }, {
            default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
              if (_push3) {
                _push3(`Meus Dados`);
              } else {
                return [
                  vueExports.createTextVNode("Meus Dados")
                ];
              }
            }),
            _: 1
          }, _parent));
          if (!__props.isAdmin) {
            _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
              to: "/holerites",
              icon: "document",
              onClick: ($event) => _ctx.$emit("close")
            }, {
              default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
                if (_push3) {
                  _push3(`Meus Holerites`);
                } else {
                  return [
                    vueExports.createTextVNode("Meus Holerites")
                  ];
                }
              }),
              _: 1
            }, _parent));
          } else {
            _push2(`<!---->`);
          }
          if (__props.isAdmin) {
            _push2(`<!--[--><div class="pt-4 mt-4 border-t border-gray-200" data-v-a39f9b9e><p class="px-4 text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3" data-v-a39f9b9e> Administrao </p></div>`);
            _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
              to: "/admin/funcionarios",
              icon: "users",
              onClick: ($event) => _ctx.$emit("close")
            }, {
              default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
                if (_push3) {
                  _push3(`Funcionrios`);
                } else {
                  return [
                    vueExports.createTextVNode("Funcionrios")
                  ];
                }
              }),
              _: 1
            }, _parent));
            _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
              to: "/admin/empresas",
              icon: "office",
              onClick: ($event) => _ctx.$emit("close")
            }, {
              default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
                if (_push3) {
                  _push3(`Empresas`);
                } else {
                  return [
                    vueExports.createTextVNode("Empresas")
                  ];
                }
              }),
              _: 1
            }, _parent));
            _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
              to: "/admin/departamentos",
              icon: "building",
              onClick: ($event) => _ctx.$emit("close")
            }, {
              default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
                if (_push3) {
                  _push3(`Departamentos`);
                } else {
                  return [
                    vueExports.createTextVNode("Departamentos")
                  ];
                }
              }),
              _: 1
            }, _parent));
            _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
              to: "/admin/cargos",
              icon: "briefcase",
              onClick: ($event) => _ctx.$emit("close")
            }, {
              default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
                if (_push3) {
                  _push3(`Cargos`);
                } else {
                  return [
                    vueExports.createTextVNode("Cargos")
                  ];
                }
              }),
              _: 1
            }, _parent));
            _push2(ssrRenderComponent_1(_component_LayoutNavLink, {
              to: "/admin/holerites",
              icon: "money",
              onClick: ($event) => _ctx.$emit("close")
            }, {
              default: vueExports.withCtx((_, _push3, _parent2, _scopeId) => {
                if (_push3) {
                  _push3(`Holerites`);
                } else {
                  return [
                    vueExports.createTextVNode("Holerites")
                  ];
                }
              }),
              _: 1
            }, _parent));
            _push2(`<!--]-->`);
          } else {
            _push2(`<!---->`);
          }
          _push2(`</nav><div class="absolute bottom-0 left-0 right-0 p-4 border-t bg-white" data-v-a39f9b9e><div class="flex items-center gap-3 p-3 rounded-xl bg-gray-50 mb-3" data-v-a39f9b9e>`);
          _push2(ssrRenderComponent_1(_component_UiAvatar, {
            name: __props.user?.nome || "",
            "avatar-type": __props.user?.avatar,
            size: "sm"
          }, null, _parent));
          _push2(`<div class="flex-1 min-w-0" data-v-a39f9b9e><p class="text-sm font-semibold text-gray-800 truncate" data-v-a39f9b9e>${ssrInterpolate_1(__props.user?.nome)}</p><p class="text-xs text-gray-500 truncate" data-v-a39f9b9e>${ssrInterpolate_1(obterNomeCargo(__props.user?.cargo))}</p></div></div><button class="w-full flex items-center justify-center gap-2 px-4 py-3 text-base font-medium text-red-600 bg-red-50 rounded-xl hover:bg-red-100" data-v-a39f9b9e><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-a39f9b9e><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" data-v-a39f9b9e></path></svg> Sair </button></div></div>`);
        } else {
          _push2(`<!---->`);
        }
      }, "body", false, _parent);
    };
  }
});
const _sfc_setup$1$1 = _sfc_main$1$1.setup;
_sfc_main$1$1.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/layout/LayoutMobileMenu.vue");
  return _sfc_setup$1$1 ? _sfc_setup$1$1(props, ctx) : void 0;
};
const __nuxt_component_1 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$1$1, [["__scopeId", "data-v-a39f9b9e"]]), { __name: "LayoutMobileMenu" });
const _sfc_main$4 = /* @__PURE__ */ vueExports.defineComponent({
  __name: "default",
  __ssrInlineRender: true,
  setup(__props) {
    const { user, isAdmin } = useAuth();
    const mobileMenuOpen = vueExports.ref(false);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_LayoutSidebar = __nuxt_component_0;
      const _component_LayoutMobileMenu = __nuxt_component_1;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "min-h-screen bg-gray-50" }, _attrs))}>`);
      _push(ssrRenderComponent_1(_component_LayoutSidebar, {
        user: vueExports.unref(user),
        "is-admin": vueExports.unref(isAdmin)
      }, null, _parent));
      _push(`<div class="lg:pl-72"><header class="lg:hidden sticky top-0 z-40 bg-white border-b border-gray-200 shadow-sm"><div class="flex items-center justify-between px-4 py-3"><div class="flex items-center gap-2"><div class="w-10 h-10 bg-primary-600 rounded-lg flex items-center justify-center"><span class="text-white font-bold">RH</span></div><span class="font-bold text-gray-800">Sistema RH</span></div><button class="p-2 rounded-lg hover:bg-gray-100"><svg class="w-7 h-7 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></header>`);
      _push(ssrRenderComponent_1(_component_LayoutMobileMenu, {
        open: vueExports.unref(mobileMenuOpen),
        user: vueExports.unref(user),
        "is-admin": vueExports.unref(isAdmin),
        onClose: ($event) => mobileMenuOpen.value = false
      }, null, _parent));
      _push(`<main class="p-4 lg:p-8">`);
      ssrRenderSlot_1(_ctx.$slots, "default", {}, null, _push, _parent);
      _push(`</main></div></div>`);
    };
  }
});
const _sfc_setup$4 = _sfc_main$4.setup;
_sfc_main$4.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("layouts/default.vue");
  return _sfc_setup$4 ? _sfc_setup$4(props, ctx) : void 0;
};

const defaultBkCi9lIN = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: _sfc_main$4
}, Symbol.toStringTag, { value: 'Module' }));

function injectHead(nuxtApp) {
  const nuxt = nuxtApp || useNuxtApp();
  return nuxt.ssrContext?.head || nuxt.runWithContext(() => {
    if (vueExports.hasInjectionContext()) {
      const head = vueExports.inject(headSymbol);
      if (!head) {
        throw new Error("[nuxt] [unhead] Missing Unhead instance.");
      }
      return head;
    }
  });
}
function useHead(input, options = {}) {
  const head = options.head || injectHead(options.nuxt);
  return useHead$1(input, { head, ...options });
}

const _sfc_main$1 = {
  __name: "error-404",
  __ssrInlineRender: true,
  props: {
    appName: {
      type: String,
      default: "Nuxt"
    },
    statusCode: {
      type: Number,
      default: 404
    },
    statusMessage: {
      type: String,
      default: "Page not found"
    },
    description: {
      type: String,
      default: "Sorry, the page you are looking for could not be found."
    },
    backHome: {
      type: String,
      default: "Go back home"
    }
  },
  setup(__props) {
    const props = __props;
    useHead({
      title: `${props.statusCode} - ${props.statusMessage} | ${props.appName}`,
      script: [
        {
          innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
        }
      ],
      style: [
        {
          innerHTML: `*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1,h2{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}h1,h2,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }`
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$5;
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "antialiased bg-white dark:bg-[#020420] dark:text-white font-sans grid min-h-screen overflow-hidden place-content-center text-[#020420] tracking-wide" }, _attrs))} data-v-cd31e6b7><div class="max-w-520px text-center" data-v-cd31e6b7><h1 class="font-semibold leading-none mb-4 sm:text-[110px] tabular-nums text-[80px]" data-v-cd31e6b7>${ssrInterpolate_1(__props.statusCode)}</h1><h2 class="font-semibold mb-2 sm:text-3xl text-2xl" data-v-cd31e6b7>${ssrInterpolate_1(__props.statusMessage)}</h2><p class="mb-4 px-2 text-[#64748B] text-md" data-v-cd31e6b7>${ssrInterpolate_1(__props.description)}</p><div class="flex items-center justify-center w-full" data-v-cd31e6b7>`);
      _push(ssrRenderComponent_1(_component_NuxtLink, {
        to: "/",
        class: "font-medium hover:text-[#00DC82] text-sm underline underline-offset-3"
      }, {
        default: vueExports.withCtx((_, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`${ssrInterpolate_1(__props.backHome)}`);
          } else {
            return [
              vueExports.createTextVNode(vueExports.toDisplayString(__props.backHome), 1)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div></div></div>`);
    };
  }
};
const _sfc_setup$1 = _sfc_main$1.setup;
_sfc_main$1.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/nuxt/dist/app/components/error-404.vue");
  return _sfc_setup$1 ? _sfc_setup$1(props, ctx) : void 0;
};
const error404 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-cd31e6b7"]]);

const error404EKQ7dIt = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: error404
}, Symbol.toStringTag, { value: 'Module' }));

const _sfc_main = {
  __name: "error-500",
  __ssrInlineRender: true,
  props: {
    appName: {
      type: String,
      default: "Nuxt"
    },
    statusCode: {
      type: Number,
      default: 500
    },
    statusMessage: {
      type: String,
      default: "Internal server error"
    },
    description: {
      type: String,
      default: "This page is temporarily unavailable."
    },
    refresh: {
      type: String,
      default: "Refresh this page"
    }
  },
  setup(__props) {
    const props = __props;
    useHead({
      title: `${props.statusCode} - ${props.statusMessage} | ${props.appName}`,
      script: [
        {
          innerHTML: `!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&r(e)}).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?r.credentials="include":"anonymous"===e.crossOrigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();`
        }
      ],
      style: [
        {
          innerHTML: `*,:after,:before{border-color:var(--un-default-border-color,#e5e7eb);border-style:solid;border-width:0;box-sizing:border-box}:after,:before{--un-content:""}html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;-moz-tab-size:4;tab-size:4;-webkit-tap-highlight-color:transparent}body{line-height:inherit;margin:0}h1,h2{font-size:inherit;font-weight:inherit}h1,h2,p{margin:0}*,:after,:before{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-pan-x: ;--un-pan-y: ;--un-pinch-zoom: ;--un-scroll-snap-strictness:proximity;--un-ordinal: ;--un-slashed-zero: ;--un-numeric-figure: ;--un-numeric-spacing: ;--un-numeric-fraction: ;--un-border-spacing-x:0;--un-border-spacing-y:0;--un-ring-offset-shadow:0 0 transparent;--un-ring-shadow:0 0 transparent;--un-shadow-inset: ;--un-shadow:0 0 transparent;--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgba(147,197,253,.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: }`
        }
      ]
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs_1(vueExports.mergeProps({ class: "antialiased bg-white dark:bg-[#020420] dark:text-white font-sans grid min-h-screen overflow-hidden place-content-center text-[#020420] tracking-wide" }, _attrs))} data-v-8851f357><div class="max-w-520px text-center" data-v-8851f357><h1 class="font-semibold leading-none mb-4 sm:text-[110px] tabular-nums text-[80px]" data-v-8851f357>${ssrInterpolate_1(__props.statusCode)}</h1><h2 class="font-semibold mb-2 sm:text-3xl text-2xl" data-v-8851f357>${ssrInterpolate_1(__props.statusMessage)}</h2><p class="mb-4 px-2 text-[#64748B] text-md" data-v-8851f357>${ssrInterpolate_1(__props.description)}</p></div></div>`);
    };
  }
};
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = vueExports.useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/nuxt/dist/app/components/error-500.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const error500 = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-8851f357"]]);

const error500WVnta9Y = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: error500
}, Symbol.toStringTag, { value: 'Module' }));

const login_vue_vue_type_style_index_0_scoped_adb25b66_lang = ".fade-enter-active[data-v-adb25b66],.fade-leave-active[data-v-adb25b66]{transition:opacity .3s ease}.fade-enter-from[data-v-adb25b66],.fade-leave-to[data-v-adb25b66]{opacity:0}";

const loginStyles_b2cz1sfn = [
  login_vue_vue_type_style_index_0_scoped_adb25b66_lang
];

const loginStyles_b2cz1sfn$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: loginStyles_b2cz1sfn
}, Symbol.toStringTag, { value: 'Module' }));

const error500_vue_vue_type_style_index_0_scoped_8851f357_lang = ".grid[data-v-8851f357]{display:grid}.mb-2[data-v-8851f357]{margin-bottom:.5rem}.mb-4[data-v-8851f357]{margin-bottom:1rem}.max-w-520px[data-v-8851f357]{max-width:520px}.min-h-screen[data-v-8851f357]{min-height:100vh}.place-content-center[data-v-8851f357]{place-content:center}.overflow-hidden[data-v-8851f357]{overflow:hidden}.bg-white[data-v-8851f357]{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.px-2[data-v-8851f357]{padding-left:.5rem;padding-right:.5rem}.text-center[data-v-8851f357]{text-align:center}.text-\\[80px\\][data-v-8851f357]{font-size:80px}.text-2xl[data-v-8851f357]{font-size:1.5rem;line-height:2rem}.text-\\[\\#020420\\][data-v-8851f357]{--un-text-opacity:1;color:rgb(2 4 32/var(--un-text-opacity))}.text-\\[\\#64748B\\][data-v-8851f357]{--un-text-opacity:1;color:rgb(100 116 139/var(--un-text-opacity))}.font-semibold[data-v-8851f357]{font-weight:600}.leading-none[data-v-8851f357]{line-height:1}.tracking-wide[data-v-8851f357]{letter-spacing:.025em}.font-sans[data-v-8851f357]{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.tabular-nums[data-v-8851f357]{--un-numeric-spacing:tabular-nums;font-variant-numeric:var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)}.antialiased[data-v-8851f357]{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media(prefers-color-scheme:dark){.dark\\:bg-\\[\\#020420\\][data-v-8851f357]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:text-white[data-v-8851f357]{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media(min-width:640px){.sm\\:text-\\[110px\\][data-v-8851f357]{font-size:110px}.sm\\:text-3xl[data-v-8851f357]{font-size:1.875rem;line-height:2.25rem}}";

const error500Styles_Dw4YpQp = [
  error500_vue_vue_type_style_index_0_scoped_8851f357_lang
];

const error500Styles_Dw4YpQp$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: error500Styles_Dw4YpQp
}, Symbol.toStringTag, { value: 'Module' }));

const error404_vue_vue_type_style_index_0_scoped_cd31e6b7_lang = ".grid[data-v-cd31e6b7]{display:grid}.mb-2[data-v-cd31e6b7]{margin-bottom:.5rem}.mb-4[data-v-cd31e6b7]{margin-bottom:1rem}.max-w-520px[data-v-cd31e6b7]{max-width:520px}.min-h-screen[data-v-cd31e6b7]{min-height:100vh}.w-full[data-v-cd31e6b7]{width:100%}.flex[data-v-cd31e6b7]{display:flex}.place-content-center[data-v-cd31e6b7]{place-content:center}.items-center[data-v-cd31e6b7]{align-items:center}.justify-center[data-v-cd31e6b7]{justify-content:center}.overflow-hidden[data-v-cd31e6b7]{overflow:hidden}.bg-white[data-v-cd31e6b7]{--un-bg-opacity:1;background-color:rgb(255 255 255/var(--un-bg-opacity))}.px-2[data-v-cd31e6b7]{padding-left:.5rem;padding-right:.5rem}.text-center[data-v-cd31e6b7]{text-align:center}.text-\\[80px\\][data-v-cd31e6b7]{font-size:80px}.text-2xl[data-v-cd31e6b7]{font-size:1.5rem;line-height:2rem}.text-sm[data-v-cd31e6b7]{font-size:.875rem;line-height:1.25rem}.text-\\[\\#020420\\][data-v-cd31e6b7]{--un-text-opacity:1;color:rgb(2 4 32/var(--un-text-opacity))}.text-\\[\\#64748B\\][data-v-cd31e6b7]{--un-text-opacity:1;color:rgb(100 116 139/var(--un-text-opacity))}.hover\\:text-\\[\\#00DC82\\][data-v-cd31e6b7]:hover{--un-text-opacity:1;color:rgb(0 220 130/var(--un-text-opacity))}.font-medium[data-v-cd31e6b7]{font-weight:500}.font-semibold[data-v-cd31e6b7]{font-weight:600}.leading-none[data-v-cd31e6b7]{line-height:1}.tracking-wide[data-v-cd31e6b7]{letter-spacing:.025em}.font-sans[data-v-cd31e6b7]{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.tabular-nums[data-v-cd31e6b7]{--un-numeric-spacing:tabular-nums;font-variant-numeric:var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)}.underline[data-v-cd31e6b7]{text-decoration-line:underline}.underline-offset-3[data-v-cd31e6b7]{text-underline-offset:3px}.antialiased[data-v-cd31e6b7]{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}@media(prefers-color-scheme:dark){.dark\\:bg-\\[\\#020420\\][data-v-cd31e6b7]{--un-bg-opacity:1;background-color:rgb(2 4 32/var(--un-bg-opacity))}.dark\\:text-white[data-v-cd31e6b7]{--un-text-opacity:1;color:rgb(255 255 255/var(--un-text-opacity))}}@media(min-width:640px){.sm\\:text-\\[110px\\][data-v-cd31e6b7]{font-size:110px}.sm\\:text-3xl[data-v-cd31e6b7]{font-size:1.875rem;line-height:2.25rem}}";

const error404Styles_SO9LtFGn = [
  error404_vue_vue_type_style_index_0_scoped_cd31e6b7_lang
];

const error404Styles_SO9LtFGn$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: error404Styles_SO9LtFGn
}, Symbol.toStringTag, { value: 'Module' }));

const UiNotification_vue_vue_type_style_index_0_scoped_09772c10_lang = ".notification-enter-active[data-v-09772c10],.notification-leave-active[data-v-09772c10]{transition:all .3s ease}.notification-enter-from[data-v-09772c10],.notification-leave-to[data-v-09772c10]{opacity:0;transform:translate(100%)}";

const UiNotificationStyles_BJrdoWL = [
  UiNotification_vue_vue_type_style_index_0_scoped_09772c10_lang
];

const UiNotificationStyles_BJrdoWL$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: UiNotificationStyles_BJrdoWL
}, Symbol.toStringTag, { value: 'Module' }));

const UiModal_vue_vue_type_style_index_0_scoped_d7b8f265_lang = ".fade-enter-active[data-v-d7b8f265],.fade-leave-active[data-v-d7b8f265]{transition:opacity .2s ease}.fade-enter-from[data-v-d7b8f265],.fade-leave-to[data-v-d7b8f265]{opacity:0}";

const UiModalStyles_0VvhfPF = [
  UiModal_vue_vue_type_style_index_0_scoped_d7b8f265_lang
];

const UiModalStyles_0VvhfPF$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: UiModalStyles_0VvhfPF
}, Symbol.toStringTag, { value: 'Module' }));

const LayoutMobileMenu_vue_vue_type_style_index_0_scoped_a39f9b9e_lang = ".fade-enter-active[data-v-a39f9b9e],.fade-leave-active[data-v-a39f9b9e]{transition:opacity .2s ease}.fade-enter-from[data-v-a39f9b9e],.fade-leave-to[data-v-a39f9b9e]{opacity:0}.slide-enter-active[data-v-a39f9b9e],.slide-leave-active[data-v-a39f9b9e]{transition:transform .3s ease}.slide-enter-from[data-v-a39f9b9e],.slide-leave-to[data-v-a39f9b9e]{transform:translate(100%)}";

const LayoutMobileMenuStyles_D4G5Vume = [
  LayoutMobileMenu_vue_vue_type_style_index_0_scoped_a39f9b9e_lang
];

const LayoutMobileMenuStyles_D4G5Vume$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: LayoutMobileMenuStyles_D4G5Vume
}, Symbol.toStringTag, { value: 'Module' }));

export { listener as default };
//# sourceMappingURL=index.mjs.map
